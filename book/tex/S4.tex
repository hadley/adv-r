\hypertarget{the-s4-object-system}{%
\chapter{The S4 object system}\label{the-s4-object-system}}

R has three object oriented (OO) systems: {[}{[}S3{]}{]}, {[}{[}S4{]}{]}
and {[}{[}R5{]}{]}. This page describes S4.

Compared to S3, the S4 object system is much stricter, and much closer
to other OO systems. I recommend you familiarise yourself with the way
that {[}{[}S3{]}{]} works before reading this document - many of
underlying ideas are the same, but the implementation is much stricter.
There are two major differences from S3:

\begin{itemize}
\item
  formal class definitions: unlike S3, S4 formally defines the
  representation and inheritance for each class
\item
  multiple dispatch: the generic function can be dispatched to a method
  based on the class of any number of argument, not just one
\end{itemize}

Here we introduce the basics of S4, trying to stay away from the
esoterica and focussing on the ideas that you need to understand and
write the majority of S4 code.

\hypertarget{classes-and-instances}{%
\section{Classes and instances}\label{classes-and-instances}}

In S3, you can turn any object into an object of a particular class just
by setting the class attribute. S4 is much stricter: you must define the
representation of the call using \texttt{setClass}, and the only way to
create it is through the constructer function \texttt{new}.

A class has three key properties:

\begin{itemize}
\item
  a \textbf{name}: an alpha-numeric string that identifies the class
\item
  \textbf{representation}: a list of \textbf{slots} (or attributes),
  giving their names and classes. For example, a person class might be
  represented by a character name and a numeric age, as follows:
  \texttt{representation(name\ =\ "character",\ age\ =\ "numeric")}
\item
  a character vector of classes that it inherits from, or in S4
  terminology, \textbf{contains}. Note that S4 supports multiple
  inheritance, but this should be used with extreme caution as it makes
  method lookup extremely complicated.
\end{itemize}

You create a class with \texttt{setClass}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\KeywordTok{representation}\NormalTok{(}\DataTypeTok{name =} \StringTok{"character"}\NormalTok{, }\DataTypeTok{age =} \StringTok{"numeric"}\NormalTok{))}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Employee"}\NormalTok{, }\KeywordTok{representation}\NormalTok{(}\DataTypeTok{boss =} \StringTok{"Person"}\NormalTok{), }\DataTypeTok{contains =} \StringTok{"Person"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

and create an instance of a class with \texttt{new}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hadley <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{31}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Unlike S3, S4 checks that all of the slots have the correct type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hadley <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \StringTok{"thirty"}\NormalTok{)}
\CommentTok{# invalid class "Person" object: invalid object for slot "age" in class}
\CommentTok{#  "Person": got class "character", should be or extend class "numeric"}
    
\NormalTok{hadley <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{sex =} \StringTok{"male"}\NormalTok{)}
\CommentTok{# invalid names for slots of class "Person": sex}
\end{Highlighting}
\end{Shaded}

If you omit a slot, it will initiate it with the default object of the
class.

To access slots of an S4 object you use \texttt{@}, not \texttt{\$}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hadley <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{)}
\NormalTok{hadley}\OperatorTok{@}\NormalTok{age}
\CommentTok{# numeric(0)}
\end{Highlighting}
\end{Shaded}

Or if you have a character string giving a slot name, you use the
\texttt{slot} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{slot}\NormalTok{(hadley, }\StringTok{"age"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This is the equivalent of \texttt{{[}{[}}.

An empty value for \texttt{age} is probably not what you want, so you
can also assign a default \textbf{prototype} for the class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\KeywordTok{representation}\NormalTok{(}\DataTypeTok{name =} \StringTok{"character"}\NormalTok{, }\DataTypeTok{age =} \StringTok{"numeric"}\NormalTok{), }
  \KeywordTok{prototype}\NormalTok{(}\DataTypeTok{name =} \OtherTok{NA_character_}\NormalTok{, }\DataTypeTok{age =} \OtherTok{NA_real_}\NormalTok{))}
\NormalTok{hadley <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{)}
\NormalTok{hadley}\OperatorTok{@}\NormalTok{age}
\CommentTok{# [1] NA}
\end{Highlighting}
\end{Shaded}

\texttt{getSlots} will return a description of all the slots of a class:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getSlots}\NormalTok{(}\StringTok{"Person"}\NormalTok{)}
\CommentTok{#        name         age }
\CommentTok{# "character"   "numeric" }
\end{Highlighting}
\end{Shaded}

You can find out the class of an object with \texttt{is}.

Note that there's some tension between the usual interactive functional
style of R and the global side-effect causing S4 class definitions. In
most programming languages, class definition occurs at compile-time,
while object instantiation occurs at run-time - it's unusual to be able
to create new classes interactively. In particular, note that the
examples rely on the fact that multiple calls to \texttt{setClass} with
the same class name will silently override the previous definition
unless the first definition is sealed with \texttt{sealed\ =\ TRUE}.

\hypertarget{checking-validity}{%
\subsection{Checking validity}\label{checking-validity}}

You can also provide an optional method that applies additional
restrictions. This function should have a single argument called
\texttt{object} and should return \texttt{TRUE} if the object is valid,
and if not it should return a character vector giving all reasons it is
not valid.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{check_person <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{  errors <-}\StringTok{ }\KeywordTok{character}\NormalTok{()}
\NormalTok{  length_age <-}\StringTok{ }\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{age)}
  \ControlFlowTok{if}\NormalTok{ (length_age }\OperatorTok{!=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\StringTok{"Age is length "}\NormalTok{, length_age, }\StringTok{".  Should be 1"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{    errors <-}\StringTok{ }\KeywordTok{c}\NormalTok{(errors, msg)}
\NormalTok{  \}}

\NormalTok{  length_name <-}\StringTok{ }\KeywordTok{length}\NormalTok{(object}\OperatorTok{@}\NormalTok{name)}
  \ControlFlowTok{if}\NormalTok{ (length_name }\OperatorTok{!=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
\NormalTok{    msg <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(}\StringTok{"Name is length "}\NormalTok{, length_name, }\StringTok{".  Should be 1"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{    errors <-}\StringTok{ }\KeywordTok{c}\NormalTok{(errors, msg)}
\NormalTok{  \}}
      
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(errors) }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{) }\OtherTok{TRUE} \ControlFlowTok{else}\NormalTok{ errors}
\NormalTok{\}}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\KeywordTok{representation}\NormalTok{(}\DataTypeTok{name =} \StringTok{"character"}\NormalTok{, }\DataTypeTok{age =} \StringTok{"numeric"}\NormalTok{), }
  \DataTypeTok{validity =}\NormalTok{ check_person)}
    
\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{)}
\CommentTok{# invalid class "Person" object: Age is length 0.  Should be 1}
\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{)}
\NormalTok{Error }\ControlFlowTok{in} \KeywordTok{validObject}\NormalTok{(.Object) }\OperatorTok{:}\StringTok{ }
\StringTok{  }\NormalTok{invalid class }\StringTok{"Person"}\NormalTok{ object}\OperatorTok{:}\StringTok{ }\NormalTok{Age is length }\FloatTok{10.}\NormalTok{  Should be }\DecValTok{1}
      
\CommentTok{# But note that the check is not automatically applied when we modify }
\CommentTok{# slots directly}
\NormalTok{hadley <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"Person"}\NormalTok{, }\DataTypeTok{name =} \StringTok{"Hadley"}\NormalTok{, }\DataTypeTok{age =} \DecValTok{31}\NormalTok{)}
\NormalTok{hadley}\OperatorTok{@}\NormalTok{age <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
    
\CommentTok{# Can force check with validObject:}
\KeywordTok{validObject}\NormalTok{(hadley)}
\CommentTok{# invalid class "Person" object: Age is length 10.  Should be 1}
\end{Highlighting}
\end{Shaded}

\hypertarget{generic-functions-and-methods}{%
\section{Generic functions and
methods}\label{generic-functions-and-methods}}

Generic functions and methods work similarly to S3, but dispatch is
based on the class of all arguments, and there is a special syntax for
creating both generic functions and new methods.

The \texttt{setGeneric} function provides two main ways to create a new
generic. You can either convert an existing function to a generic
function, or you can create a new one from scratch.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sides <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(object) }\DecValTok{0}
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"sides"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you create your own, the second argument to \texttt{setGeneric}
should be a function that defines all the arguments that you want to
dispatch on and contains a call to \texttt{standardGeneric}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"sides"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
  \KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"sides"}\NormalTok{)}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

The following example sets up a simple hierarchy of shapes to use with
the sides function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Shape"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Polygon"}\NormalTok{, }\KeywordTok{representation}\NormalTok{(}\DataTypeTok{sides =} \StringTok{"integer"}\NormalTok{), }\DataTypeTok{contains =} \StringTok{"Shape"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Triangle"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"Polygon"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Square"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"Polygon"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Circle"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"Shape"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Defining a method for polygons is straightforward: we just use the sides
slot. The \texttt{setMethod} function takes three arguments: the name of
the generic function, the signature to match for this method and a
function to compute the result. Unfortunately R doesn't offer any
syntactic sugar for this task so the code is a little verbose and
repetitive.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"sides"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\DataTypeTok{object =} \StringTok{"Polygon"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(object) \{}
\NormalTok{  object}\OperatorTok{@}\NormalTok{sides}
\NormalTok{\})}
\end{Highlighting}
\end{Shaded}

For the others we supply exact values. Note that that for generics with
few arguments you can simplify the signature without giving the argument
names. This saves spaces at the expense of having to remember which
position corresponds to which argument - not a problem if there's only
one argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"sides"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"Triangle"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(object) }\DecValTok{3}\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"sides"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"Square"}\NormalTok{),   }\ControlFlowTok{function}\NormalTok{(object) }\DecValTok{4}\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"sides"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"Circle"}\NormalTok{),   }\ControlFlowTok{function}\NormalTok{(object) }\OtherTok{Inf}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

You can optionally also specify \texttt{valueClass} to define the
expected output of the generic. This will raise a run-time error if a
method returns output of the wrong class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"sides"}\NormalTok{, }\DataTypeTok{valueClass =} \StringTok{"numeric"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(object) \{}
  \KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"sides"}\NormalTok{)}
\NormalTok{\})}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"sides"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"Triangle"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(object) }\StringTok{"three"}\NormalTok{)}
\KeywordTok{sides}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Triangle"}\NormalTok{))}
\CommentTok{# invalid value from generic function "sides", class "character", expected}
\CommentTok{# "numeric"}
\end{Highlighting}
\end{Shaded}

Note that arguments that the generic dispatches on can't be lazily
evaluated - otherwise how would R know which class the object was? This
also means that you can't use \texttt{substitute} to access the
unevaluated expression.

To find what methods are already defined for a generic function, use
\texttt{showMethods}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{showMethods}\NormalTok{(}\StringTok{"sides"}\NormalTok{)}
\CommentTok{# Function: sides (package .GlobalEnv)}
\CommentTok{# object="Circle"}
\CommentTok{# object="Polygon"}
\CommentTok{# object="Square"}
\CommentTok{# object="Triangle"}
    
\KeywordTok{showMethods}\NormalTok{(}\DataTypeTok{class =} \StringTok{"Polygon"}\NormalTok{)}
\CommentTok{# Function: initialize (package methods)}
\CommentTok{# .Object="Polygon"}
\CommentTok{#    (inherited from: .Object="ANY")}
\CommentTok{# }
\CommentTok{# Function: sides (package .GlobalEnv)}
\CommentTok{# object="Polygon"}
\end{Highlighting}
\end{Shaded}

\hypertarget{method-dispatch}{%
\subsection{Method dispatch}\label{method-dispatch}}

This section describes the strategy for matching a call to a generic
function to the correct method. If there's an exact match between the
class of the objects in the call, and the signature of a method, it's
easy - the generic function just calls that method. Otherwise, R will
figure out the method using the following method:

\begin{itemize}
\item
  For each argument to the function, calculate the distance between the
  class in the class, and the class in the signature. If they are the
  same, the distance is zero. If the class in the signature is a parent
  of the class in the call, then the distance is 1. If it's a
  grandparent, 2, and so on. Compute the total distance by adding
  together the individual distances.
\item
  Calculate this distance for every method. If there's a method with a
  unique smallest distance, use that. Otherwise, give a warning and call
  one of the matching methods as described below.
\end{itemize}

Note that it's possible to create methods that are ambiguous - i.e.~it's
not clear which method the generic should pick. In this case R will pick
the method that is first alphabetically and return a warning message
about the situation:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"A"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"A1"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"A"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"A2"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"A1"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"A3"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"A2"}\NormalTok{)}

\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(a, b) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"foo"}\NormalTok{)) }
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"A1"}\NormalTok{, }\StringTok{"A2"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(a, b) }\StringTok{"1-2"}\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"A2"}\NormalTok{, }\StringTok{"A1"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(a, b) }\StringTok{"2-1"}\NormalTok{)}
    
\KeywordTok{foo}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"A2"}\NormalTok{), }\KeywordTok{new}\NormalTok{(}\StringTok{"A2"}\NormalTok{))}
\CommentTok{# Note: Method with signature "A2#A1" chosen for function "foo",}
\CommentTok{# target signature "A2#A2". "A1#A2" would also be valid}
\end{Highlighting}
\end{Shaded}

Generally, you should avoid this ambiguity by providing a more specific
method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"A2"}\NormalTok{, }\StringTok{"A2"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(a, b) }\StringTok{"2-2"}\NormalTok{)}
\KeywordTok{foo}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"A2"}\NormalTok{), }\KeywordTok{new}\NormalTok{(}\StringTok{"A2"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

(The computation is cached for this combination of classes so that it
doesn't have to be done again.)

There are two special classes that can be used in the signature:
\texttt{missing} and \texttt{ANY}. \texttt{missing} matches the case
where the argument is not supplied, and \texttt{ANY} is used for setting
up default methods. \texttt{ANY} has the lowest possible precedence in
method matching.

You can also use basic classes like \texttt{numeric}, \texttt{character}
and \texttt{matrix}. A matrix of (e.g.) characters will have class
\texttt{matrix}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"type"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"type"}\NormalTok{))}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"type"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"matrix"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"matrix"}\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"type"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"character"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"character"}\NormalTok{)}
    
\KeywordTok{type}\NormalTok{(letters)}
\KeywordTok{type}\NormalTok{(}\KeywordTok{matrix}\NormalTok{(letters, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

You can also dispatch on S3 classes provided that you have made S4 aware
of them by calling \texttt{setOldClass}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{foo <-}\StringTok{ }\KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{), }\DataTypeTok{class =} \StringTok{"foo"}\NormalTok{)}
\KeywordTok{type}\NormalTok{(foo)}

\KeywordTok{setOldClass}\NormalTok{(}\StringTok{"foo"}\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"type"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"foo"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x) }\StringTok{"foo"}\NormalTok{)}
    
\KeywordTok{type}\NormalTok{(foo)}
    
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"+"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\DataTypeTok{e1 =} \StringTok{"foo"}\NormalTok{, }\DataTypeTok{e2 =} \StringTok{"numeric"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(e1, e2) \{}
  \KeywordTok{structure}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ e1}\OperatorTok{$}\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{e2), }\DataTypeTok{class =} \StringTok{"foo"}\NormalTok{)}
\NormalTok{\})}
\NormalTok{foo }\OperatorTok{+}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

It's also possible to dispatch on \texttt{...} under special
circumstances. See \texttt{?dotsMethods} for more details.

\hypertarget{inheritance}{%
\subsection{Inheritance}\label{inheritance}}

Let's develop a fuller example. This is inspired by an example from the
\href{http://opendylan.org/documentation/intro-dylan/index.html}{Dylan
language reference}, one of the languages that inspired the S4 object
system. In this example we'll develop a simple model of vehicle
inspections that vary depending on the type of vehicle (car or truck)
and type of inspector (normal or state).

In S4, it's the \texttt{callNextMethod} that (surprise!) is used to call
the next method. It figures out which method to call by pretending the
current method doesn't exist, and looking for the next closest match.

First we set up the classes: two types of vehicle (car and truck), and
two types of inspect.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Vehicle"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Truck"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"Vehicle"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"Car"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"Vehicle"}\NormalTok{)}

\KeywordTok{setClass}\NormalTok{(}\StringTok{"Inspector"}\NormalTok{, }\KeywordTok{representation}\NormalTok{(}\DataTypeTok{name =} \StringTok{"character"}\NormalTok{))}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"StateInspector"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"Inspector"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Next we define the generic function for inspecting a vehicle. It has two
arguments: the vehicle being inspected and the person doing the
inspection.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"inspect.vehicle"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(v, i) \{}
   \KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"inspect.vehicle"}\NormalTok{)}
\NormalTok{ \})}
\end{Highlighting}
\end{Shaded}

All vehicle must be checked for rust by all inspectors, so we'll add the
first. Cars also need to have working seatbelts.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"inspect.vehicle"}\NormalTok{, }
  \KeywordTok{signature}\NormalTok{(}\DataTypeTok{v =} \StringTok{"Vehicle"}\NormalTok{, }\DataTypeTok{i =} \StringTok{"Inspector"}\NormalTok{), }
  \ControlFlowTok{function}\NormalTok{(v, i) \{}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Looking for rust"}\NormalTok{)}
\NormalTok{  \})}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{"inspect.vehicle"}\NormalTok{, }
  \KeywordTok{signature}\NormalTok{(}\DataTypeTok{v =} \StringTok{"Car"}\NormalTok{, }\DataTypeTok{i =} \StringTok{"Inspector"}\NormalTok{),}
  \ControlFlowTok{function}\NormalTok{(v, i) \{  }
   \KeywordTok{callNextMethod}\NormalTok{() }\CommentTok{# perform vehicle inspection}
   \KeywordTok{message}\NormalTok{(}\StringTok{"Checking seat belts"}\NormalTok{)}
\NormalTok{  \})}

\KeywordTok{inspect.vehicle}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Car"}\NormalTok{), }\KeywordTok{new}\NormalTok{(}\StringTok{"Inspector"}\NormalTok{))}
\CommentTok{# Looking for rust}
\CommentTok{# Checking seat belts}
\end{Highlighting}
\end{Shaded}

Note that it's the most specific method that's responsible for ensuring
that the more generic methods are called.

We'll next add methods for trucks (cargo attachments need to be ok), and
the special task that the state inspector performs on cars: checking for
insurance.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"inspect.vehicle"}\NormalTok{, }
  \KeywordTok{signature}\NormalTok{(}\DataTypeTok{v =} \StringTok{"Truck"}\NormalTok{, }\DataTypeTok{i =} \StringTok{"Inspector"}\NormalTok{),}
  \ControlFlowTok{function}\NormalTok{(v, i) \{}
    \KeywordTok{callNextMethod}\NormalTok{() }\CommentTok{# perform vehicle inspection}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Checking cargo attachments"}\NormalTok{)}
\NormalTok{  \})}

\KeywordTok{inspect.vehicle}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Truck"}\NormalTok{), }\KeywordTok{new}\NormalTok{(}\StringTok{"Inspector"}\NormalTok{))}
\CommentTok{# Looking for rust}
\CommentTok{# Checking cargo attachments}

\KeywordTok{setMethod}\NormalTok{(}\StringTok{"inspect.vehicle"}\NormalTok{, }
  \KeywordTok{signature}\NormalTok{(}\DataTypeTok{v =} \StringTok{"Car"}\NormalTok{, }\DataTypeTok{i =} \StringTok{"StateInspector"}\NormalTok{),}
  \ControlFlowTok{function}\NormalTok{(v, i) \{}
    \KeywordTok{callNextMethod}\NormalTok{() }\CommentTok{# perform car inspection}
    \KeywordTok{message}\NormalTok{(}\StringTok{"Checking insurance"}\NormalTok{)}
\NormalTok{\})}

\KeywordTok{inspect.vehicle}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Car"}\NormalTok{), }\KeywordTok{new}\NormalTok{(}\StringTok{"StateInspector"}\NormalTok{))}
\CommentTok{# Looking for rust}
\CommentTok{# Checking seat belts}
\CommentTok{# Checking insurance}
\end{Highlighting}
\end{Shaded}

This set up ensures that when a state inspector checks a truck, they
perform all of the checks a regular inspector would:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{inspect.vehicle}\NormalTok{(}\KeywordTok{new}\NormalTok{(}\StringTok{"Truck"}\NormalTok{), }\KeywordTok{new}\NormalTok{(}\StringTok{"StateInspector"}\NormalTok{))}
\CommentTok{# Looking for rust}
\CommentTok{# Checking cargo attachments}
\end{Highlighting}
\end{Shaded}

\hypertarget{method-dispatch-2}{%
\section{Method dispatch 2}\label{method-dispatch-2}}

To make the ideas in this section concrete, we'll create a simple class
structure. We have three classes, C which inherits from a character
vector, B inherits from C and A inherits from B. We then instantiate an
object from each class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"character"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"C"}\NormalTok{)}
\KeywordTok{setClass}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"B"}\NormalTok{)}

\NormalTok{a <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"a"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"b"}\NormalTok{)}
\NormalTok{c <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\StringTok{"c"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This creates a class graph that looks like this:

\includegraphics{diagrams/class-graph-1.png}

Next, we create a generic f, which will dispatch on two arguments:
\texttt{x} and \texttt{y}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setGeneric}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\ControlFlowTok{function}\NormalTok{(x, y) }\KeywordTok{standardGeneric}\NormalTok{(}\StringTok{"f"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

To predict which method a generic will dispatch to, you need to know:

\begin{itemize}
\tightlist
\item
  the name and arguments to the generic
\item
  the signatures of the methods
\item
  the class of arguments supplied to the generic
\end{itemize}

The simplest type of method dispatch occurs if there's an exact match
between the class of arguments (arg-classes) and the signature of
(sig-classes). In the following example, we define methods with
sig-classes \texttt{c("C",\ "C")} and \texttt{c("A",\ "A")}, and then
call them with arg classes \texttt{c("C",\ "C")} and
\texttt{c("A",\ "A")}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\StringTok{"C"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x, y) }\StringTok{"c-c"}\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"A"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x, y) }\StringTok{"a-a"}\NormalTok{)}

\KeywordTok{f}\NormalTok{(c, c)}
\KeywordTok{f}\NormalTok{(a, a)}
\end{Highlighting}
\end{Shaded}

If there isn't an exact match, R looks for the closest method. The
distance between the sig-class and arg-class is the sum of the distances
between each class (matched by named and excluding \ldots{}). The
distance between classes is the shortest distance between them in the
class graph. For example, the distance A -\textgreater{} B is 1, A
-\textgreater{} C is 2 and B -\textgreater{} C is 1. The distances C
-\textgreater{} B, C -\textgreater{} A and B -\textgreater{} A are all
infinite. That means that of the following two calls will dispatch to
the same method:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{f}\NormalTok{(b, b)}
\KeywordTok{f}\NormalTok{(a, c)}
\end{Highlighting}
\end{Shaded}

If we added another class, BC, that inherited from both B and C, then
this class would have distance one to both B and C, and distance two to
A. As you can imagine, this can get quite tricky if you have a
complicated class graph: for this reason it's better to avoid multiple
inheritance unless absolutely necessary.

\includegraphics{diagrams/class-graph-2.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{(}\StringTok{"BC"}\NormalTok{, }\DataTypeTok{contains =} \KeywordTok{c}\NormalTok{(}\StringTok{"B"}\NormalTok{, }\StringTok{"C"}\NormalTok{))}
\NormalTok{bc <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"BC"}\NormalTok{, }\StringTok{"bc"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's add a more complicated case:

\begin{verbatim}
setMethod("f", signature("B", "C"), function(x, y) "b-c")
setMethod("f", signature("C", "B"), function(x, y) "c-b")
f(b, b)
\end{verbatim}

Now we have two signatures that have the same distance (1 = 1 + 0 = 0 +
1), and there is not unique closest method. In this situation R gives a
warning and calls the method that comes first alphabetically.

There are two special classes that can be used in the signature:
\texttt{missing} and \texttt{ANY}. \texttt{missing} matches the case
where the argument is not supplied, and \texttt{ANY} is used for setting
up default methods. \texttt{ANY} has the lowest possible precedence in
method matching - in other words, it has a distance value higher than
any other parent class.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\StringTok{"ANY"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x,y) }\StringTok{"C-*"}\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"f"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\StringTok{"C"}\NormalTok{, }\StringTok{"missing"}\NormalTok{), }\ControlFlowTok{function}\NormalTok{(x,y) }\StringTok{"C-?"}\NormalTok{)}

\KeywordTok{setClass}\NormalTok{(}\StringTok{"D"}\NormalTok{, }\DataTypeTok{contains =} \StringTok{"character"}\NormalTok{)}
\NormalTok{d <-}\StringTok{ }\KeywordTok{new}\NormalTok{(}\StringTok{"D"}\NormalTok{, }\StringTok{"d"}\NormalTok{)}

\KeywordTok{f}\NormalTok{(c)}
\KeywordTok{f}\NormalTok{(c, d)}
\end{Highlighting}
\end{Shaded}

It's also possible to dispatch on \texttt{...} under special
circumstances. See \texttt{?dotsMethods} for more details.

\hypertarget{in-the-wild}{%
\section{In the wild}\label{in-the-wild}}

To conclude, lets look at some S4 code in practice. The Bioconductor
\texttt{EBImage}, by Oleg Sklyar, Gregoire Pau, Mike Smith and Wolfgang
Huber, package is a good place to start because it's so simple. It has
only one class, an \texttt{Image}, which represents a image as an array
of pixel values.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setClass}\NormalTok{ (}\StringTok{"Image"}\NormalTok{,}
  \KeywordTok{representation}\NormalTok{ (}\DataTypeTok{colormode=}\StringTok{"integer"}\NormalTok{),}
  \KeywordTok{prototype}\NormalTok{ (}\DataTypeTok{colormode=}\NormalTok{Grayscale),}
  \DataTypeTok{contains =} \StringTok{"array"}
\NormalTok{)}

\NormalTok{imageData =}\StringTok{ }\ControlFlowTok{function}\NormalTok{ (y) \{}
  \ControlFlowTok{if}\NormalTok{ (}\KeywordTok{is}\NormalTok{(y, }\StringTok{'Image'}\NormalTok{)) y}\OperatorTok{@}\NormalTok{.Data}
  \ControlFlowTok{else}\NormalTok{ y}
\NormalTok{\}    }
\end{Highlighting}
\end{Shaded}

The author wrote the \texttt{imageData} convenience method to extract
the underlying S3 object, the array. They could have also used the
\texttt{S3Part} function to extract this.

Methods are used to define numeric operations for combining two images,
or an image with a constant. Here the author is using the \texttt{Ops}
group generic which will match all calls to \texttt{+}, \texttt{-},
\texttt{*}, \texttt{\^{}}, \texttt{\%\%}, \texttt{\%/\%}, \texttt{/},
\texttt{==}, \texttt{\textgreater{}}, \texttt{\textless{}}, \texttt{!=},
\texttt{\textless{}=}, \texttt{\textgreater{}=}, \texttt{\&}, and
\texttt{\textbar{}}. The \texttt{callGeneric} function then passed on
this call to the generic method for arrays. Finally, each method checks
that the modified object is valid, before returning it.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"Ops"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\DataTypeTok{e1=}\StringTok{"Image"}\NormalTok{, }\DataTypeTok{e2=}\StringTok{"Image"}\NormalTok{),}
    \ControlFlowTok{function}\NormalTok{(e1, e2) \{}
\NormalTok{          e1}\OperatorTok{@}\NormalTok{.Data=}\KeywordTok{callGeneric}\NormalTok{(}\KeywordTok{imageData}\NormalTok{(e1), }\KeywordTok{imageData}\NormalTok{(e2))}
           \KeywordTok{validObject}\NormalTok{(e1)}
          \KeywordTok{return}\NormalTok{(e1)}
\NormalTok{    \}}
\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"Ops"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\DataTypeTok{e1=}\StringTok{"Image"}\NormalTok{, }\DataTypeTok{e2=}\StringTok{"numeric"}\NormalTok{),}
    \ControlFlowTok{function}\NormalTok{(e1, e2) \{}
\NormalTok{          e1}\OperatorTok{@}\NormalTok{.Data=}\KeywordTok{callGeneric}\NormalTok{(}\KeywordTok{imageData}\NormalTok{(e1), e2)}
          \KeywordTok{validObject}\NormalTok{(e1)}
          \KeywordTok{return}\NormalTok{(e1)}
\NormalTok{    \}}
\NormalTok{)}
\KeywordTok{setMethod}\NormalTok{(}\StringTok{"Ops"}\NormalTok{, }\KeywordTok{signature}\NormalTok{(}\DataTypeTok{e1=}\StringTok{"numeric"}\NormalTok{, }\DataTypeTok{e2=}\StringTok{"Image"}\NormalTok{),}
    \ControlFlowTok{function}\NormalTok{(e1, e2) \{}
\NormalTok{          e2}\OperatorTok{@}\NormalTok{.Data=}\KeywordTok{callGeneric}\NormalTok{(e1, }\KeywordTok{imageData}\NormalTok{(e2))}
          \KeywordTok{validObject}\NormalTok{(e2)}
          \KeywordTok{return}\NormalTok{(e2)}
\NormalTok{    \}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{Matrix} package by Douglas Bates and Martin Maechler is a
great example of a more complicated setup. It is designed to efficiently
store and compute with many different special types of matrix. As at
version 0.999375-50 it defines 130 classes and 24 generic functions. The
package is well written, well commented and fairly easy to read. The
accompanying
\href{http://cran.r-project.org/web/packages/Matrix/vignettes/Intro2Matrix.pdf}{vignette}
gives a good overview of the structure of the package. I'd highly
recommend downloading the source and then skimming the following R
files:

\begin{itemize}
\item
  \texttt{AllClass.R}: where all classes are defined
\item
  \texttt{AllGenerics.R}: where all generics are defined
\item
  \texttt{Ops.R}: where pairwise operators are defined, including
  automatic conversion of standard S3 matrices
\end{itemize}

Most of the hard work is done in C for efficiency, but it's still useful
to look at the other R files to see how the code is arranged.
