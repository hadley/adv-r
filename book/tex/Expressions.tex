\chapter{Expressions}\label{metaprogramming}

In \hyperref[nse]{non-standard evaluation}, you learned the basics of
accessing and evaluating the expressions underlying computation in R. In
this chapter, you'll learn how to manipulate these expressions with
code. You're going to learn how to metaprogram: how to create programs
with other programs! \index{metaprogramming}
\index{computing on the language|see{metaprogramming}}

\paragraph{Outline}

\begin{itemize}
\item
  \hyperref[structure-of-expressions]{Structure of expressions} begins
  with a deep dive into the structure of expressions. You'll learn about
  the four components of an expression: constants, names, calls, and
  pairlists.
\item
  \hyperref[names]{Names} goes into further details about names.
\item
  \hyperref[calls]{Calls} gives more details about calls.
\item
  \hyperref[capturing-call]{Capturing the current call} takes a minor
  detour to discuss some common uses of calls in base R.
\item
  \hyperref[pairlists]{Pairlists} completes the discussion of the four
  major components of an expression, and shows how you can create
  functions from their component pieces.
\item
  \hyperref[parsing-and-deparsing]{Parsing and deparsing} discusses how
  to convert back and forth between expressions and text.
\item
  \hyperref[ast-funs]{Walking the call tree with recursive functions}
  concludes the chapter, combining everything you've learned about
  writing functions that can compute on and modify arbitrary R code.
\end{itemize}

\paragraph{Prerequisites}

Throughout this chapter we're going to use tools from the \texttt{pryr}
package to help see what's going on. If you don't already have it,
install it by running \texttt{install.packages("pryr")}.

\hyperdef{}{structure-of-expressions}{\section{Structure of
expressions}\label{structure-of-expressions}}

To compute on the language, we first need to understand the structure of
the language. That will require some new vocabulary, some new tools, and
some new ways of thinking about R code. The first thing you'll need to
understand is the distinction between an operation and a result:
\index{expressions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{4}
\NormalTok{y <-}\StringTok{ }\NormalTok{x *}\StringTok{ }\DecValTok{10}
\NormalTok{y}
\CommentTok{#> [1] 40}
\end{Highlighting}
\end{Shaded}

We want to distinguish the action of multiplying \texttt{x} by 10 and
assigning that result to \texttt{y} from the actual result (40). As
we've seen in the previous chapter, we can capture the action with
\texttt{quote()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(y <-}\StringTok{ }\NormalTok{x *}\StringTok{ }\DecValTok{10}\NormalTok{)}
\NormalTok{z}
\CommentTok{#> y <- x * 10}
\end{Highlighting}
\end{Shaded}

\texttt{quote()} returns an \textbf{expression}: an object that
represents an action that can be performed by R. (Unfortunately
\texttt{expression()} does not return an expression in this sense.
Instead, it returns something more like a list of expressions. See
\hyperref[parsing-and-deparsing]{parsing and deparsing} for more
details.) \indexc{quote()}

An expression is also called an abstract syntax tree (AST) because it
represents the hierarchical tree structure of the code. We'll use
\texttt{pryr::ast()} to see this more clearly:
\index{abstract syntax tree} \indexc{ast()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(y <-}\StringTok{ }\NormalTok{x *}\StringTok{ }\DecValTok{10}\NormalTok{)}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `<-}
\CommentTok{#>   \textbackslash{}- `y}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `*}
\CommentTok{#>     \textbackslash{}- `x}
\CommentTok{#>     \textbackslash{}-  10}
\end{Highlighting}
\end{Shaded}

There are four possible components of an expression: constants, names,
calls, and pairlists.

\begin{itemize}
\item
  \textbf{constants} are length one atomic vectors, like \texttt{"a"} or
  \texttt{10}. \texttt{ast()} displays them as is. \index{constants}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
\CommentTok{#> \textbackslash{}-  "a"}
\KeywordTok{ast}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> \textbackslash{}-  1}
\KeywordTok{ast}\NormalTok{(1L)}
\CommentTok{#> \textbackslash{}-  1L}
\KeywordTok{ast}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> \textbackslash{}-  TRUE}
\end{Highlighting}
\end{Shaded}

  Quoting a constant returns it unchanged:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{identical}\NormalTok{(}\DecValTok{1}\NormalTok{, }\KeywordTok{quote}\NormalTok{(}\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] TRUE}
\KeywordTok{identical}\NormalTok{(}\StringTok{"test"}\NormalTok{, }\KeywordTok{quote}\NormalTok{(}\StringTok{"test"}\NormalTok{))}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{names}, or symbols, represent the name of an object rather
  than its value. \texttt{ast()} prefixes names with a backtick.
  \index{names} \index{symbols|see{names}}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(x)}
\CommentTok{#> \textbackslash{}- `x}
\KeywordTok{ast}\NormalTok{(mean)}
\CommentTok{#> \textbackslash{}- `mean}
\KeywordTok{ast}\NormalTok{(}\StringTok{`}\DataTypeTok{an unusual name}\StringTok{`}\NormalTok{)}
\CommentTok{#> \textbackslash{}- `an unusual name}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{calls} represent the action of calling a function. Like lists,
  calls are recursive: they can contain constants, names, pairlists, and
  other calls. \texttt{ast()} prints \texttt{()} and then lists the
  children. The first child is the function that is called, and the
  remaining children are the function's arguments. \index{calls}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{())}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `f}
\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `f}
\CommentTok{#>   \textbackslash{}-  1}
\CommentTok{#>   \textbackslash{}-  2}
\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(a, b))}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `f}
\CommentTok{#>   \textbackslash{}- `a}
\CommentTok{#>   \textbackslash{}- `b}
\KeywordTok{ast}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\KeywordTok{g}\NormalTok{(), }\KeywordTok{h}\NormalTok{(}\DecValTok{1}\NormalTok{, a)))}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `f}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `g}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `h}
\CommentTok{#>     \textbackslash{}-  1}
\CommentTok{#>     \textbackslash{}- `a}
\end{Highlighting}
\end{Shaded}

  As mentioned in \hyperref[all-calls]{every operation is a function
  call}, even things that don't look like function calls still have this
  hierarchical structure:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(a +}\StringTok{ }\NormalTok{b)}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `+}
\CommentTok{#>   \textbackslash{}- `a}
\CommentTok{#>   \textbackslash{}- `b}
\KeywordTok{ast}\NormalTok{(if (x >}\StringTok{ }\DecValTok{1}\NormalTok{) x else }\DecValTok{1}\NormalTok{/x)}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `if}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `>}
\CommentTok{#>     \textbackslash{}- `x}
\CommentTok{#>     \textbackslash{}-  1}
\CommentTok{#>   \textbackslash{}- `x}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `/}
\CommentTok{#>     \textbackslash{}-  1}
\CommentTok{#>     \textbackslash{}- `x}
\end{Highlighting}
\end{Shaded}
\item
  \textbf{pairlists}, short for dotted pair lists, are a legacy of R's
  past. They are only used in one place: the formal arguments of a
  function. \texttt{ast()} prints \texttt{{[}{]}} at the top-level of a
  pairlist. Like calls, pairlists are also recursive and can contain
  constants, names, and calls. \index{pairlists}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(function(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, y) x)}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `function}
\CommentTok{#>   \textbackslash{}- []}
\CommentTok{#>     \textbackslash{} x = 1}
\CommentTok{#>     \textbackslash{} y =`MISSING}
\CommentTok{#>   \textbackslash{}- `x}
\CommentTok{#>   \textbackslash{}- <srcref>}
\KeywordTok{ast}\NormalTok{(function(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{, }\DataTypeTok{y =} \NormalTok{x *}\StringTok{ }\DecValTok{2}\NormalTok{) \{x /}\StringTok{ }\NormalTok{y\})}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `function}
\CommentTok{#>   \textbackslash{}- []}
\CommentTok{#>     \textbackslash{} x = 1}
\CommentTok{#>     \textbackslash{} y =()}
\CommentTok{#>       \textbackslash{}- `*}
\CommentTok{#>       \textbackslash{}- `x}
\CommentTok{#>       \textbackslash{}-  2}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `\{}
\CommentTok{#>     \textbackslash{}- ()}
\CommentTok{#>       \textbackslash{}- `/}
\CommentTok{#>       \textbackslash{}- `x}
\CommentTok{#>       \textbackslash{}- `y}
\CommentTok{#>   \textbackslash{}- <srcref>}
\end{Highlighting}
\end{Shaded}
\end{itemize}

Note that \texttt{str()} does not follow these naming conventions when
describing objects. Instead, it describes names as symbols and calls as
language objects:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{quote}\NormalTok{(a))}
\CommentTok{#>  symbol a}
\KeywordTok{str}\NormalTok{(}\KeywordTok{quote}\NormalTok{(a +}\StringTok{ }\NormalTok{b))}
\CommentTok{#>  language a + b}
\end{Highlighting}
\end{Shaded}

Using low-level functions, it is possible to create call trees that
contain objects other than constants, names, calls, and pairlists. The
following example uses \texttt{substitute()} to insert a data frame into
a call tree. This is a bad idea, however, because the object does not
print correctly: the printed call looks like it should return ``list''
but when evaluated, it returns ``data.frame''. \indexc{substitute()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{class_df <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(}\KeywordTok{class}\NormalTok{(df), }\KeywordTok{list}\NormalTok{(}\DataTypeTok{df =} \KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{10}\NormalTok{)))}
\NormalTok{class_df}
\CommentTok{#> class(list(x = 10))}
\KeywordTok{eval}\NormalTok{(class_df)}
\CommentTok{#> [1] "data.frame"}
\end{Highlighting}
\end{Shaded}

Together these four components define the structure of all R code. They
are explained in more detail in the following sections.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  There's no existing base function that checks if an element is a valid
  component of an expression (i.e., it's a constant, name, call, or
  pairlist). Implement one by guessing the names of the ``is'' functions
  for calls, names, and pairlists.
\item
  \texttt{pryr::ast()} uses non-standard evaluation. What's its escape
  hatch to standard evaluation?
\item
  What does the call tree of an if statement with multiple else
  conditions look like?
\item
  Compare \texttt{ast(x + y \%+\% z)} to \texttt{ast(x \^{} y \%+\% z)}.
  What do they tell you about the precedence of custom infix functions?
\item
  Why can't an expression contain an atomic vector of length greater
  than one? Which one of the six types of atomic vector can't appear in
  an expression? Why?
\end{enumerate}

\hyperdef{}{names}{\section{Names}\label{names}}

Typically, we use \texttt{quote()} to capture names. You can also
convert a string to a name with \texttt{as.name()}. However, this is
most useful only when your function receives strings as input. Otherwise
it involves more typing than using \texttt{quote()}. (You can use
\texttt{is.name()} to test if an object is a name.) \index{names}
\indexc{as.name()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.name}\NormalTok{(}\StringTok{"name"}\NormalTok{)}
\CommentTok{#> name}
\KeywordTok{identical}\NormalTok{(}\KeywordTok{quote}\NormalTok{(name), }\KeywordTok{as.name}\NormalTok{(}\StringTok{"name"}\NormalTok{))}
\CommentTok{#> [1] TRUE}

\KeywordTok{is.name}\NormalTok{(}\StringTok{"name"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{is.name}\NormalTok{(}\KeywordTok{quote}\NormalTok{(name))}
\CommentTok{#> [1] TRUE}
\KeywordTok{is.name}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{f}\NormalTok{(name)))}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

(Names are also called symbols. \texttt{as.symbol()} and
\texttt{is.symbol()} are identical to \texttt{as.name()} and
\texttt{is.name()}.)

Names that would otherwise be invalid are automatically surrounded by
backticks: \index{non-syntactic names}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.name}\NormalTok{(}\StringTok{"a b"}\NormalTok{)}
\CommentTok{#> `a b`}
\KeywordTok{as.name}\NormalTok{(}\StringTok{"if"}\NormalTok{)}
\CommentTok{#> `if`}
\end{Highlighting}
\end{Shaded}

There's one special name that needs a little extra discussion: the empty
name. It is used to represent missing arguments. This object behaves
strangely. You can't bind it to a variable. If you do, it triggers an
error about missing arguments. It's only useful if you want to
programmatically create a function with missing arguments.
\index{names|empty}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) }\DecValTok{10}
\KeywordTok{formals}\NormalTok{(f)$x}
\KeywordTok{is.name}\NormalTok{(}\KeywordTok{formals}\NormalTok{(f)$x)}
\CommentTok{#> [1] TRUE}
\KeywordTok{as.character}\NormalTok{(}\KeywordTok{formals}\NormalTok{(f)$x)}
\CommentTok{#> [1] ""}

\NormalTok{missing_arg <-}\StringTok{ }\KeywordTok{formals}\NormalTok{(f)$x}
\CommentTok{# Doesn't work!}
\KeywordTok{is.name}\NormalTok{(missing_arg)}
\CommentTok{#> Error in eval(expr, envir, enclos): argument "missing_arg" is missing, with no default}
\end{Highlighting}
\end{Shaded}

To explicitly create it when needed, call \texttt{quote()} with a named
argument:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{quote}\NormalTok{(}\DataTypeTok{expr =}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  You can use \texttt{formals()} to both get and set the arguments of a
  function. Use \texttt{formals()} to modify the following function so
  that the default value of \texttt{x} is missing and \texttt{y} is 10.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{x =} \DecValTok{20}\NormalTok{, y) \{}
  \NormalTok{x +}\StringTok{ }\NormalTok{y}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  Write an equivalent to \texttt{get()} using \texttt{as.name()} and
  \texttt{eval()}. Write an equivalent to \texttt{assign()} using
  \texttt{as.name()}, \texttt{substitute()}, and \texttt{eval()}. (Don't
  worry about the multiple ways of choosing an environment; assume that
  the user supplies it explicitly.)
\end{enumerate}

\hyperdef{}{calls}{\section{Calls}\label{calls}}

A call is very similar to a list. It has \texttt{length},
\texttt{{[}{[}} and \texttt{{[}} methods, and is recursive because calls
can contain other calls. The first element of the call is the function
that gets called. It's usually the \emph{name} of a function:
\index{calls}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{read.csv}\NormalTok{(}\StringTok{"important.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{))}
\NormalTok{x[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> read.csv}
\KeywordTok{is.name}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

But it can also be another call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{add}\NormalTok{(}\DecValTok{10}\NormalTok{)(}\DecValTok{20}\NormalTok{))}
\NormalTok{y[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> add(10)}
\KeywordTok{is.call}\NormalTok{(y[[}\DecValTok{1}\NormalTok{]])}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

The remaining elements are the arguments. They can be extracted by name
or by position.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{read.csv}\NormalTok{(}\StringTok{"important.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{))}
\NormalTok{x[[}\DecValTok{2}\NormalTok{]]}
\CommentTok{#> [1] "important.csv"}
\NormalTok{x$row.names}
\CommentTok{#> [1] FALSE}
\KeywordTok{names}\NormalTok{(x)}
\CommentTok{#> [1] ""          ""          "row.names"}
\end{Highlighting}
\end{Shaded}

The length of a call minus 1 gives the number of arguments:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(x) -}\StringTok{ }\DecValTok{1}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

\subsection{Modifying a call}

You can add, modify, and delete elements of the call with the standard
replacement operators, \texttt{\$\textless{}-} and
\texttt{{[}{[}\textless{}-}: \index{calls|modifying}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{read.csv}\NormalTok{(}\StringTok{"important.csv"}\NormalTok{, }\DataTypeTok{row.names =} \OtherTok{FALSE}\NormalTok{))}
\NormalTok{y$row.names <-}\StringTok{ }\OtherTok{TRUE}
\NormalTok{y$col.names <-}\StringTok{ }\OtherTok{FALSE}
\NormalTok{y}
\CommentTok{#> read.csv("important.csv", row.names = TRUE, col.names = FALSE)}

\NormalTok{y[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(filename, }\StringTok{".csv"}\NormalTok{))}
\NormalTok{y[[}\DecValTok{4}\NormalTok{]] <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{y}
\CommentTok{#> read.csv(paste0(filename, ".csv"), row.names = TRUE)}

\NormalTok{y$sep <-}\StringTok{ ","}
\NormalTok{y}
\CommentTok{#> read.csv(paste0(filename, ".csv"), row.names = TRUE, sep = ",")}
\end{Highlighting}
\end{Shaded}

Calls also support the \texttt{{[}} method. But use it with care.
Removing the first element is unlikely to create a useful call.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x[-}\DecValTok{3}\NormalTok{] }\CommentTok{# remove the second argument}
\CommentTok{#> read.csv("important.csv")}
\NormalTok{x[-}\DecValTok{1}\NormalTok{] }\CommentTok{# remove the function name - but it's still a call!}
\CommentTok{#> "important.csv"(row.names = FALSE)}
\NormalTok{x}
\CommentTok{#> read.csv("important.csv", row.names = FALSE)}
\end{Highlighting}
\end{Shaded}

If you want a list of the unevaluated arguments (expressions), use
explicit coercion:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# A list of the unevaluated arguments}
\KeywordTok{as.list}\NormalTok{(x[-}\DecValTok{1}\NormalTok{])}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] "important.csv"}
\CommentTok{#> }
\CommentTok{#> $row.names}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

Generally speaking, because R's function calling semantics are so
flexible, getting or setting arguments by position is dangerous. For
example, even though the values at each position are different, the
following three calls all have the same effect:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1 <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{read.delim}\NormalTok{(}\StringTok{"data.txt"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"|"}\NormalTok{))}
\NormalTok{m2 <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{read.delim}\NormalTok{(}\DataTypeTok{s =} \StringTok{"|"}\NormalTok{, }\StringTok{"data.txt"}\NormalTok{))}
\NormalTok{m3 <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{read.delim}\NormalTok{(}\DataTypeTok{file =} \StringTok{"data.txt"}\NormalTok{, , }\StringTok{"|"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

To work around this problem, pryr provides \texttt{standardise\_call()}.
It uses the base \texttt{match.call()} function to convert all
positional arguments to named arguments: \indexc{standardise\_call()}
\indexc{match.call()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{standardise_call}\NormalTok{(m1)}
\CommentTok{#> read.delim(file = "data.txt", sep = "|")}
\KeywordTok{standardise_call}\NormalTok{(m2)}
\CommentTok{#> read.delim(file = "data.txt", sep = "|")}
\KeywordTok{standardise_call}\NormalTok{(m3)}
\CommentTok{#> read.delim(file = "data.txt", sep = "|")}
\end{Highlighting}
\end{Shaded}

\subsection{Creating a call from its components}

To create a new call from its components, you can use \texttt{call()} or
\texttt{as.call()}. The first argument to \texttt{call()} is a string
which gives a function name. The other arguments are expressions that
represent the arguments of the call. \indexc{call()} \indexc{as.call()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{call}\NormalTok{(}\StringTok{":"}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{#> 1:10}
\KeywordTok{call}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\KeywordTok{quote}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> mean(1:10, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}

\texttt{as.call()} is a minor variant of \texttt{call()} that takes a
single list as input. The first element is a name or call. The
subsequent elements are the arguments.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.call}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{quote}\NormalTok{(mean), }\KeywordTok{quote}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean(1:10)}
\KeywordTok{as.call}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{adder}\NormalTok{(}\DecValTok{10}\NormalTok{)), }\DecValTok{20}\NormalTok{))}
\CommentTok{#> adder(10)(20)}
\end{Highlighting}
\end{Shaded}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The following two calls look the same, but are actually different:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a <-}\StringTok{ }\KeywordTok{call}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{))}
\CommentTok{#> mean(1:10)}
\NormalTok{(b <-}\StringTok{ }\KeywordTok{call}\NormalTok{(}\StringTok{"mean"}\NormalTok{, }\KeywordTok{quote}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean(1:10)}
\KeywordTok{identical}\NormalTok{(a, b)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

  What's the difference? Which one should you prefer?
\item
  Implement a pure R version of \texttt{do.call()}.
\item
  Concatenating a call and an expression with \texttt{c()} creates a
  list. Implement \texttt{concat()} so that the following code works to
  combine a call and an additional argument.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{concat}\NormalTok{(}\KeywordTok{quote}\NormalTok{(f), }\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(a)))}
\CommentTok{#> f(a = 1, b = mean(a))}
\end{Highlighting}
\end{Shaded}
\item
  Since \texttt{list()}s don't belong in expressions, we could create a
  more convenient call constructor that automatically combines lists
  into the arguments. Implement \texttt{make\_call()} so that the
  following code works.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{make_call}\NormalTok{(}\KeywordTok{quote}\NormalTok{(mean), }\KeywordTok{list}\NormalTok{(}\KeywordTok{quote}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> mean(x, na.rm = TRUE)}
\KeywordTok{make_call}\NormalTok{(}\KeywordTok{quote}\NormalTok{(mean), }\KeywordTok{quote}\NormalTok{(x), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> mean(x, na.rm = TRUE)}
\end{Highlighting}
\end{Shaded}
\item
  How does \texttt{mode\textless{}-} work? How does it use
  \texttt{call()}?
\item
  Read the source for \texttt{pryr::standardise\_call()}. How does it
  work? Why is \texttt{is.primitive()} needed?
\item
  \texttt{standardise\_call()} doesn't work so well for the following
  calls. Why?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{standardise_call}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, na.rm = TRUE)}
\KeywordTok{standardise_call}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DataTypeTok{n =} \NormalTok{T, }\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, n = T)}
\KeywordTok{standardise_call}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, , }\OtherTok{TRUE}\NormalTok{)))}
\CommentTok{#> mean(x = 1:10, , TRUE)}
\end{Highlighting}
\end{Shaded}
\item
  Read the documentation for \texttt{pryr::modify\_call()}. How do you
  think it works? Read the source code.
\item
  Use \texttt{ast()} and experimentation to figure out the three
  arguments in an \texttt{if()} call. Which components are required?
  What are the arguments to the \texttt{for()} and \texttt{while()}
  calls?
\end{enumerate}

\hyperdef{}{capturing-call}{\section{Capturing the current
call}\label{capturing-call}}

Many base R functions use the current call: the expression that caused
the current function to be run. There are two ways to capture a current
call: \indexc{calls|capturing current}

\begin{itemize}
\item
  \texttt{sys.call()} captures exactly what the user typed.
  \indexc{sys.call()}
\item
  \texttt{match.call()} makes a call that only uses named arguments.
  It's like automatically calling \texttt{pryr::standardise\_call()} on
  the result of \texttt{sys.call()} \indexc{match.call()}
\end{itemize}

The following example illustrates the difference between the two:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{abc =} \DecValTok{1}\NormalTok{, }\DataTypeTok{def =} \DecValTok{2}\NormalTok{, }\DataTypeTok{ghi =} \DecValTok{3}\NormalTok{) \{}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{sys =} \KeywordTok{sys.call}\NormalTok{(), }\DataTypeTok{match =} \KeywordTok{match.call}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DataTypeTok{d =} \DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> $sys}
\CommentTok{#> f(d = 2, 2)}
\CommentTok{#> }
\CommentTok{#> $match}
\CommentTok{#> f(abc = 2, def = 2)}
\end{Highlighting}
\end{Shaded}

Modelling functions often use \texttt{match.call()} to capture the call
used to create the model. This makes it possible to \texttt{update()} a
model, re-fitting the model after modifying some of original arguments.
Here's an example of \texttt{update()} in action: \indexc{update()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg ~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =} \NormalTok{mtcars)}
\KeywordTok{update}\NormalTok{(mod, }\DataTypeTok{formula =} \NormalTok{. ~}\StringTok{ }\NormalTok{. +}\StringTok{ }\NormalTok{cyl)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = mpg ~ wt + cyl, data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)           wt          cyl  }
\CommentTok{#>       39.69        -3.19        -1.51}
\end{Highlighting}
\end{Shaded}

How does \texttt{update()} work? We can rewrite it using some tools from
pryr to focus on the essence of the algorithm.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{update_call <-}\StringTok{ }\NormalTok{function (object, formula., ...) \{}
  \NormalTok{call <-}\StringTok{ }\NormalTok{object$call}

  \CommentTok{# Use update.formula to deal with formulas like . ~ .}
  \NormalTok{if (!}\KeywordTok{missing}\NormalTok{(formula.)) \{}
    \NormalTok{call$formula <-}\StringTok{ }\KeywordTok{update.formula}\NormalTok{(}\KeywordTok{formula}\NormalTok{(object), formula.)}
  \NormalTok{\}}

  \KeywordTok{modify_call}\NormalTok{(call, }\KeywordTok{dots}\NormalTok{(...))}
\NormalTok{\}}
\NormalTok{update_model <-}\StringTok{ }\NormalTok{function(object, formula., ...) \{}
  \NormalTok{call <-}\StringTok{ }\KeywordTok{update_call}\NormalTok{(object, formula., ...)}
  \KeywordTok{eval}\NormalTok{(call, }\KeywordTok{parent.frame}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{update_model}\NormalTok{(mod, }\DataTypeTok{formula =} \NormalTok{. ~}\StringTok{ }\NormalTok{. +}\StringTok{ }\NormalTok{cyl)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = mpg ~ wt + cyl, data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#> (Intercept)           wt          cyl  }
\CommentTok{#>       39.69        -3.19        -1.51}
\end{Highlighting}
\end{Shaded}

The original \texttt{update()} has an \texttt{evaluate} argument that
controls whether the function returns the call or the result. But I
think it's better, on principle, that a function returns only one type
of object, rather than different types depending on the function's
arguments.

This rewrite also allows us to fix a small bug in \texttt{update()}: it
re-evaluates the call in the global environment, when what we really
want is to re-evaluate it in the environment where the model was
originally fit --- in the formula.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{n <-}\StringTok{ }\DecValTok{3}
  \KeywordTok{lm}\NormalTok{(mpg ~}\StringTok{ }\KeywordTok{poly}\NormalTok{(wt, n), }\DataTypeTok{data =} \NormalTok{mtcars)}
\NormalTok{\}}
\NormalTok{mod <-}\StringTok{ }\KeywordTok{f}\NormalTok{()}
\KeywordTok{update}\NormalTok{(mod, }\DataTypeTok{data =} \NormalTok{mtcars)}
\CommentTok{#> Error in poly(wt, n): object 'n' not found}

\NormalTok{update_model <-}\StringTok{ }\NormalTok{function(object, formula., ...) \{}
  \NormalTok{call <-}\StringTok{ }\KeywordTok{update_call}\NormalTok{(object, formula., ...)}
  \KeywordTok{eval}\NormalTok{(call, }\KeywordTok{environment}\NormalTok{(}\KeywordTok{formula}\NormalTok{(object)))}
\NormalTok{\}}
\KeywordTok{update_model}\NormalTok{(mod, }\DataTypeTok{data =} \NormalTok{mtcars)}
\CommentTok{#> }
\CommentTok{#> Call:}
\CommentTok{#> lm(formula = mpg ~ poly(wt, n), data = mtcars)}
\CommentTok{#> }
\CommentTok{#> Coefficients:}
\CommentTok{#>  (Intercept)  poly(wt, n)1  poly(wt, n)2  poly(wt, n)3  }
\CommentTok{#>       20.091       -29.116         8.636         0.275}
\end{Highlighting}
\end{Shaded}

This is an important principle to remember: if you want to re-run code
captured with \texttt{match.call()}, you also need to capture the
environment in which it was evaluated, usually the
\texttt{parent.frame()}. The downside to this is that capturing the
environment also means capturing any large objects which happen to be in
that environment, which prevents their memory from being released. This
topic is explored in more detail in \hyperref[gc]{garbage collection}.
\index{environments|capturing}

Some base R functions use \texttt{match.call()} where it's not
necessary. For example, \texttt{write.csv()} captures the call to
\texttt{write.csv()} and mangles it to call \texttt{write.table()}
instead:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{write.csv <-}\StringTok{ }\NormalTok{function(...) \{}
  \NormalTok{Call <-}\StringTok{ }\KeywordTok{match.call}\NormalTok{(}\DataTypeTok{expand.dots =} \OtherTok{TRUE}\NormalTok{)}
  \NormalTok{for (arg in }\KeywordTok{c}\NormalTok{(}\StringTok{"append"}\NormalTok{, }\StringTok{"col.names"}\NormalTok{, }\StringTok{"sep"}\NormalTok{, }\StringTok{"dec"}\NormalTok{, }\StringTok{"qmethod"}\NormalTok{)) \{}
    \NormalTok{if (!}\KeywordTok{is.null}\NormalTok{(Call[[arg]])) \{}
      \KeywordTok{warning}\NormalTok{(}\KeywordTok{gettextf}\NormalTok{(}\StringTok{"attempt to set '%s' ignored"}\NormalTok{, arg))}
    \NormalTok{\}}
  \NormalTok{\}}
  \NormalTok{rn <-}\StringTok{ }\KeywordTok{eval.parent}\NormalTok{(Call$row.names)}
  \NormalTok{Call$append <-}\StringTok{ }\OtherTok{NULL}
  \NormalTok{Call$col.names <-}\StringTok{ }\NormalTok{if (}\KeywordTok{is.logical}\NormalTok{(rn) &&}\StringTok{ }\NormalTok{!rn) }\OtherTok{TRUE} \NormalTok{else }\OtherTok{NA}
  \NormalTok{Call$sep <-}\StringTok{ ","}
  \NormalTok{Call$dec <-}\StringTok{ "."}
  \NormalTok{Call$qmethod <-}\StringTok{ "double"}
  \NormalTok{Call[[1L]] <-}\StringTok{ }\KeywordTok{as.name}\NormalTok{(}\StringTok{"write.table"}\NormalTok{)}
  \KeywordTok{eval.parent}\NormalTok{(Call)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To fix this, we could implement \texttt{write.csv()} using regular
function call semantics:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{write.csv <-}\StringTok{ }\NormalTok{function(x, }\DataTypeTok{file =} \StringTok{""}\NormalTok{, }\DataTypeTok{sep =} \StringTok{","}\NormalTok{, }\DataTypeTok{qmethod =} \StringTok{"double"}\NormalTok{, }
                      \NormalTok{...) \{}
  \KeywordTok{write.table}\NormalTok{(}\DataTypeTok{x =} \NormalTok{x, }\DataTypeTok{file =} \NormalTok{file, }\DataTypeTok{sep =} \NormalTok{sep, }\DataTypeTok{qmethod =} \NormalTok{qmethod, }
    \NormalTok{...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is much easier to understand: it's just calling
\texttt{write.table()} with different defaults. This also fixes a subtle
bug in the original \texttt{write.csv()}:
\texttt{write.csv(mtcars, row = FALSE)} raises an error, but
\texttt{write.csv(mtcars, row.names = FALSE)} does not. The lesson here
is that it's always better to solve a problem with the simplest tool
possible.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Compare and contrast \texttt{update\_model()} with
  \texttt{update.default()}.
\item
  Why doesn't \texttt{write.csv(mtcars, "mtcars.csv", row = FALSE)}
  work? What property of argument matching has the original author
  forgotten?
\item
  Rewrite \texttt{update.formula()} to use R code instead of C code.
\item
  Sometimes it's necessary to uncover the function that called the
  function that called the current function (i.e., the grandparent, not
  the parent). How can you use \texttt{sys.call()} or
  \texttt{match.call()} to find this function?
\end{enumerate}

\hyperdef{}{pairlists}{\section{Pairlists}\label{pairlists}}

Pairlists are a holdover from R's past. They behave identically to
lists, but have a different internal representation (as a linked list
rather than a vector). Pairlists have been replaced by lists everywhere
except in function arguments. \index{pairlists}

The only place you need to care about the difference between a list and
a pairlist is if you're going to construct functions by hand. For
example, the following function allows you to construct a function from
its component pieces: a list of formal arguments, a body, and an
environment. The function uses \texttt{as.pairlist()} to ensure that the
\texttt{function()} has the pairlist of \texttt{args} it needs.
\indexc{as.pairlist()} \indexc{make\_function()}
\index{functions!creating with code}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{make_function <-}\StringTok{ }\NormalTok{function(args, body, }\DataTypeTok{env =} \KeywordTok{parent.frame}\NormalTok{()) \{}
  \NormalTok{args <-}\StringTok{ }\KeywordTok{as.pairlist}\NormalTok{(args)}

  \KeywordTok{eval}\NormalTok{(}\KeywordTok{call}\NormalTok{(}\StringTok{"function"}\NormalTok{, args, body), env)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This function is also available in pryr, where it does a little extra
checking of arguments. \texttt{make\_function()} is best used in
conjunction with \texttt{alist()}, the \textbf{a}rgument list function.
\texttt{alist()} doesn't evaluate its arguments so that
\texttt{alist(x = a)} is shorthand for \texttt{list(x = quote(a))}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\KeywordTok{make_function}\NormalTok{(}\KeywordTok{alist}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{), }\KeywordTok{quote}\NormalTok{(a +}\StringTok{ }\NormalTok{b))}
\KeywordTok{add}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 3}
\KeywordTok{add}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 3}

\CommentTok{# To have an argument with no default, you need an explicit =}
\KeywordTok{make_function}\NormalTok{(}\KeywordTok{alist}\NormalTok{(}\DataTypeTok{a =} \NormalTok{, }\DataTypeTok{b =} \NormalTok{a), }\KeywordTok{quote}\NormalTok{(a +}\StringTok{ }\NormalTok{b))}
\CommentTok{#> function (a, b = a) }
\CommentTok{#> a + b}
\CommentTok{# To take `...` as an argument put it on the LHS of =}
\KeywordTok{make_function}\NormalTok{(}\KeywordTok{alist}\NormalTok{(}\DataTypeTok{a =} \NormalTok{, }\DataTypeTok{b =} \NormalTok{, }\DataTypeTok{... =}\NormalTok{), }\KeywordTok{quote}\NormalTok{(a +}\StringTok{ }\NormalTok{b))}
\CommentTok{#> function (a, b, ...) }
\CommentTok{#> a + b}
\end{Highlighting}
\end{Shaded}

\texttt{make\_function()} has one advantage over using closures to
construct functions: with it, you can easily read the source code. For
example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{adder <-}\StringTok{ }\NormalTok{function(x) \{}
  \KeywordTok{make_function}\NormalTok{(}\KeywordTok{alist}\NormalTok{(}\DataTypeTok{y =}\NormalTok{), }\KeywordTok{substitute}\NormalTok{(\{x +}\StringTok{ }\NormalTok{y\}), }\KeywordTok{parent.frame}\NormalTok{())}
\NormalTok{\}}
\KeywordTok{adder}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> function (y) }
\CommentTok{#> \{}
\CommentTok{#>     10 + y}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

One useful application of \texttt{make\_function()} is in functions like
\texttt{curve()}. \texttt{curve()} allows you to plot a mathematical
function without creating an explicit R function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{curve}\NormalTok{(}\KeywordTok{sin}\NormalTok{(}\KeywordTok{exp}\NormalTok{(}\DecValTok{4} \NormalTok{*}\StringTok{ }\NormalTok{x)), }\DataTypeTok{n =} \DecValTok{1000}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\includegraphics{figures/curve-demo-1.pdf}

Here \texttt{x} is a pronoun. \texttt{x} doesn't represent a single
concrete value, but is instead a placeholder that varies over the range
of the plot. One way to implement \texttt{curve()} would be with
\texttt{make\_function()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{curve2 <-}\StringTok{ }\NormalTok{function(expr, }\DataTypeTok{xlim =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{n =} \DecValTok{100}\NormalTok{, }
                   \DataTypeTok{env =} \KeywordTok{parent.frame}\NormalTok{()) \{}
  \NormalTok{f <-}\StringTok{ }\KeywordTok{make_function}\NormalTok{(}\KeywordTok{alist}\NormalTok{(}\DataTypeTok{x =} \NormalTok{), }\KeywordTok{substitute}\NormalTok{(expr), env)}

  \NormalTok{x <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(xlim[}\DecValTok{1}\NormalTok{], xlim[}\DecValTok{2}\NormalTok{], }\DataTypeTok{length =} \NormalTok{n)}
  \NormalTok{y <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x)}

  \KeywordTok{plot}\NormalTok{(x, y, }\DataTypeTok{type =} \StringTok{"l"}\NormalTok{, }\DataTypeTok{ylab =} \KeywordTok{deparse}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(expr)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Functions that use a pronoun are called
\href{http://en.wikipedia.org/wiki/Anaphora_(linguistics)}{anaphoric}
functions. They are used in
\href{http://www.arcfn.com/doc/anaphoric.html}{Arc} (a lisp like
language),
\href{http://www.perlmonks.org/index.pl?node_id=666047}{Perl}, and
\href{http://amalloy.hubpages.com/hub/Unhygenic-anaphoric-Clojure-macros-for-fun-and-profit}{Clojure}.
\index{anaphoric functions} \index{functions!anaphoric}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How are \texttt{alist(a)} and \texttt{alist(a = )} different? Think
  about both the input and the output.
\item
  Read the documentation and source code for \texttt{pryr::partial()}.
  What does it do? How does it work? Read the documentation and source
  code for \texttt{pryr::unenclose()}. What does it do and how does it
  work?
\item
  The actual implementation of \texttt{curve()} looks more like

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{curve3 <-}\StringTok{ }\NormalTok{function(expr, }\DataTypeTok{xlim =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{), }\DataTypeTok{n =} \DecValTok{100}\NormalTok{,}
                   \DataTypeTok{env =} \KeywordTok{parent.frame}\NormalTok{()) \{}
  \NormalTok{env2 <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{(}\DataTypeTok{parent =} \NormalTok{env)}
  \NormalTok{env2$x <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(xlim[}\DecValTok{1}\NormalTok{], xlim[}\DecValTok{2}\NormalTok{], }\DataTypeTok{length =} \NormalTok{n)}

  \NormalTok{y <-}\StringTok{ }\KeywordTok{eval}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(expr), env2)}
  \KeywordTok{plot}\NormalTok{(env2$x, y, }\DataTypeTok{type =} \StringTok{"l"}\NormalTok{, }
    \DataTypeTok{ylab =} \KeywordTok{deparse}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(expr)))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

  How does this approach differ from \texttt{curve2()} defined above?
\end{enumerate}

\hyperdef{}{parsing-and-deparsing}{\section{Parsing and
deparsing}\label{parsing-and-deparsing}}

Sometimes code is represented as a string, rather than as an expression.
You can convert a string to an expression with \texttt{parse()}.
\texttt{parse()} is the opposite of \texttt{deparse()}: it takes a
character vector and returns an expression object. The primary use of
\texttt{parse()} is parsing files of code to disk, so the first argument
is a file path. Note that if you have code in a character vector, you
need to use the \texttt{text} argument: \indexc{parse()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(y <-}\StringTok{ }\NormalTok{x *}\StringTok{ }\DecValTok{10}\NormalTok{)}
\KeywordTok{deparse}\NormalTok{(z)}
\CommentTok{#> [1] "y <- x * 10"}

\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text =} \KeywordTok{deparse}\NormalTok{(z))}
\CommentTok{#> expression(y <- x * 10)}
\end{Highlighting}
\end{Shaded}

Because there might be many top-level calls in a file, \texttt{parse()}
doesn't return just a single expression. Instead, it returns an
expression object, which is essentially a list of expressions:
\index{expression object}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{exp <-}\StringTok{ }\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text =} \KeywordTok{c}\NormalTok{(}\StringTok{"}
\StringTok{  x <- 4}
\StringTok{  x}
\StringTok{  5}
\StringTok{"}\NormalTok{))}
\KeywordTok{length}\NormalTok{(exp)}
\CommentTok{#> [1] 3}
\KeywordTok{typeof}\NormalTok{(exp)}
\CommentTok{#> [1] "expression"}

\NormalTok{exp[[}\DecValTok{1}\NormalTok{]]}
\CommentTok{#> x <- 4}
\NormalTok{exp[[}\DecValTok{2}\NormalTok{]]}
\CommentTok{#> x}
\end{Highlighting}
\end{Shaded}

You can create expression objects by hand with \texttt{expression()},
but I wouldn't recommend it. There's no need to learn about this
esoteric data structure if you already know how to use expressions.
\indexc{expression()}

With \texttt{parse()} and \texttt{eval()}, it's possible to write a
simple version of \texttt{source()}. We read in the file from disk,
\texttt{parse()} it and then \texttt{eval()} each component in a
specified environment. This version defaults to a new environment, so it
doesn't affect existing objects. \texttt{source()} invisibly returns the
result of the last expression in the file, so \texttt{simple\_source()}
does the same. \index{source()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_source <-}\StringTok{ }\NormalTok{function(file, }\DataTypeTok{envir =} \KeywordTok{new.env}\NormalTok{()) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{file.exists}\NormalTok{(file))}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.environment}\NormalTok{(envir))}

  \NormalTok{lines <-}\StringTok{ }\KeywordTok{readLines}\NormalTok{(file, }\DataTypeTok{warn =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{exprs <-}\StringTok{ }\KeywordTok{parse}\NormalTok{(}\DataTypeTok{text =} \NormalTok{lines)}

  \NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(exprs)}
  \NormalTok{if (n ==}\StringTok{ }\NormalTok{0L) }\KeywordTok{return}\NormalTok{(}\KeywordTok{invisible}\NormalTok{())}

  \NormalTok{for (i in }\KeywordTok{seq_len}\NormalTok{(n -}\StringTok{ }\DecValTok{1}\NormalTok{)) \{}
    \KeywordTok{eval}\NormalTok{(exprs[i], envir)}
  \NormalTok{\}}
  \KeywordTok{invisible}\NormalTok{(}\KeywordTok{eval}\NormalTok{(exprs[n], envir))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The real \texttt{source()} is considerably more complicated because it
can \texttt{echo} input and output, and also has many additional
settings to control behaviour.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What are the differences between \texttt{quote()} and
  \texttt{expression()}?
\item
  Read the help for \texttt{deparse()} and construct a call that
  \texttt{deparse()} and \texttt{parse()} do not operate symmetrically
  on.
\item
  Compare and contrast \texttt{source()} and \texttt{sys.source()}.
\item
  Modify \texttt{simple\_source()} so it returns the result of
  \emph{every} expression, not just the last one.
\item
  The code generated by \texttt{simple\_source()} lacks source
  references. Read the source code for \texttt{sys.source()} and the
  help for \texttt{srcfilecopy()}, then modify \texttt{simple\_source()}
  to preserve source references. You can test your code by sourcing a
  function that contains a comment. If successful, when you look at the
  function, you'll see the comment and not just the source code.
\end{enumerate}

\hyperdef{}{ast-funs}{\section{Walking the AST with recursive
functions}\label{ast-funs}}

It's easy to modify a single call with \texttt{substitute()} or
\texttt{pryr::modify\_call()}. For more complicated tasks we need to
work directly with the AST. The base \texttt{codetools} package provides
some useful motivating examples of how we can do this:
\index{recursion!over ASTs}

\begin{itemize}
\item
  \texttt{findGlobals()} locates all global variables used by a
  function. This can be useful if you want to check that your function
  doesn't inadvertently rely on variables defined in their parent
  environment.
\item
  \texttt{checkUsage()} checks for a range of common problems including
  unused local variables, unused parameters, and the use of partial
  argument matching.
\end{itemize}

To write functions like \texttt{findGlobals()} and
\texttt{checkUsage()}, we'll need a new tool. Because expressions have a
tree structure, using a recursive function would be the natural choice.
The key to doing that is getting the recursion right. This means making
sure that you know what the base case is and figuring out how to combine
the results from the recursive case. For calls, there are two base cases
(atomic vectors and names) and two recursive cases (calls and
pairlists). This means that a function for working with expressions will
look like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{recurse_call <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x)) \{}
    \CommentTok{# Return a value}
  \NormalTok{\} else if (}\KeywordTok{is.name}\NormalTok{(x)) \{}
    \CommentTok{# Return a value}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \CommentTok{# Call recurse_call recursively}
  \NormalTok{\} else if (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \CommentTok{# Call recurse_call recursively}
  \NormalTok{\} else \{}
    \CommentTok{# User supplied incorrect input}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Finding F and T}

We'll start simple with a function that determines whether a function
uses the logical abbreviations \texttt{T} and \texttt{F}. Using
\texttt{T} and \texttt{F} is generally considered to be poor coding
practice, and is something that \texttt{R CMD check} will warn about.
Let's first compare the AST for \texttt{T} vs. \texttt{TRUE}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> \textbackslash{}-  TRUE}
\KeywordTok{ast}\NormalTok{(T)}
\CommentTok{#> \textbackslash{}- `T}
\end{Highlighting}
\end{Shaded}

\texttt{TRUE} is parsed as a logical vector of length one, while
\texttt{T} is parsed as a name. This tells us how to write our base
cases for the recursive function: while an atomic vector will never be a
logical abbreviation, a name might, so we'll need to test for both
\texttt{T} and \texttt{F}. The recursive cases can be combined because
they do the same thing in both cases: they recursively call
\texttt{logical\_abbr()} on each element of the object.
\indexc{logical\_abbr}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{logical_abbr <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x)) \{}
    \OtherTok{FALSE}
  \NormalTok{\} else if (}\KeywordTok{is.name}\NormalTok{(x)) \{}
    \KeywordTok{identical}\NormalTok{(x, }\KeywordTok{quote}\NormalTok{(T)) ||}\StringTok{ }\KeywordTok{identical}\NormalTok{(x, }\KeywordTok{quote}\NormalTok{(F))}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \NormalTok{for (i in }\KeywordTok{seq_along}\NormalTok{(x)) \{}
      \NormalTok{if (}\KeywordTok{logical_abbr}\NormalTok{(x[[i]])) }\KeywordTok{return}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
    \NormalTok{\}}
    \OtherTok{FALSE}
  \NormalTok{\} else \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> [1] FALSE}
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{quote}\NormalTok{(T))}
\CommentTok{#> [1] TRUE}
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \NormalTok{T)))}
\CommentTok{#> [1] TRUE}
\KeywordTok{logical_abbr}\NormalTok{(}\KeywordTok{quote}\NormalTok{(function(x, }\DataTypeTok{na.rm =} \NormalTok{T) }\OtherTok{FALSE}\NormalTok{))}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

\subsection{Finding all variables created by assignment}

\texttt{logical\_abbr()} is very simple: it only returns a single
\texttt{TRUE} or \texttt{FALSE}. The next task, listing all variables
created by assignment, is a little more complicated. We'll start simply,
and then make the function progressively more rigorous.
\indexc{find\_assign()}

Again, we start by looking at the AST for assignment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(x <-}\StringTok{ }\DecValTok{10}\NormalTok{)}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `<-}
\CommentTok{#>   \textbackslash{}- `x}
\CommentTok{#>   \textbackslash{}-  10}
\end{Highlighting}
\end{Shaded}

Assignment is a call where the first element is the name
\texttt{\textless{}-}, the second is the object the name is assigned to,
and the third is the value to be assigned. This makes the base cases
simple: constants and names don't create assignments, so they return
\texttt{NULL}. The recursive cases aren't too hard either. We
\texttt{lapply()} over pairlists and over calls to functions other than
\texttt{\textless{}-}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.name}\NormalTok{(x)) \{}
    \OtherTok{NULL}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \NormalTok{if (}\KeywordTok{identical}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]], }\KeywordTok{quote}\NormalTok{(}\StringTok{`}\DataTypeTok{<-}\StringTok{`}\NormalTok{))) \{}
      \NormalTok{x[[}\DecValTok{2}\NormalTok{]]}
    \NormalTok{\} else \{}
      \KeywordTok{lapply}\NormalTok{(x, find_assign)}
    \NormalTok{\}}
  \NormalTok{\} else if (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \KeywordTok{lapply}\NormalTok{(x, find_assign)}
  \NormalTok{\} else \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{quote}\NormalTok{(a <-}\StringTok{ }\DecValTok{1}\NormalTok{))}
\CommentTok{#> a}
\KeywordTok{find_assign}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
  \NormalTok{a <-}\StringTok{ }\DecValTok{1}
  \NormalTok{b <-}\StringTok{ }\DecValTok{2}
\NormalTok{\}))}
\CommentTok{#> [[1]]}
\CommentTok{#> NULL}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> a}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> b}
\end{Highlighting}
\end{Shaded}

This function works for these simple cases, but the output is rather
verbose and includes some extraneous \texttt{NULL}s. Instead of
returning a list, let's keep it simple and use a character vector. We'll
also test it with two slightly more complicated examples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign2 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.name}\NormalTok{(x)) \{}
    \KeywordTok{character}\NormalTok{()}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \NormalTok{if (}\KeywordTok{identical}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]], }\KeywordTok{quote}\NormalTok{(}\StringTok{`}\DataTypeTok{<-}\StringTok{`}\NormalTok{))) \{}
      \KeywordTok{as.character}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
    \NormalTok{\} else \{}
      \KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, find_assign2))}
    \NormalTok{\}}
  \NormalTok{\} else if (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, find_assign2))}
  \NormalTok{\} else \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{find_assign2}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
  \NormalTok{a <-}\StringTok{ }\DecValTok{1}
  \NormalTok{b <-}\StringTok{ }\DecValTok{2}
  \NormalTok{a <-}\StringTok{ }\DecValTok{3}
\NormalTok{\}))}
\CommentTok{#> [1] "a" "b" "a"}

\KeywordTok{find_assign2}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
  \KeywordTok{system.time}\NormalTok{(x <-}\StringTok{ }\KeywordTok{print}\NormalTok{(y <-}\StringTok{ }\DecValTok{5}\NormalTok{))}
\NormalTok{\}))}
\CommentTok{#> [1] "x"}
\end{Highlighting}
\end{Shaded}

This is better, but we have two problems: dealing with repeated names
and neglecting assignments inside other assignments. The fix for the
first problem is easy. We need to wrap \texttt{unique()} around the
recursive case to remove duplicate assignments. The fix for the second
problem is a bit more tricky. We also need to recurse when the call is
to \texttt{\textless{}-}. \texttt{find\_assign3()} implements both
strategies:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign3 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.name}\NormalTok{(x)) \{}
    \KeywordTok{character}\NormalTok{()}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \NormalTok{if (}\KeywordTok{identical}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]], }\KeywordTok{quote}\NormalTok{(}\StringTok{`}\DataTypeTok{<-}\StringTok{`}\NormalTok{))) \{}
      \NormalTok{lhs <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
    \NormalTok{\} else \{}
      \NormalTok{lhs <-}\StringTok{ }\KeywordTok{character}\NormalTok{()}
    \NormalTok{\}}

    \KeywordTok{unique}\NormalTok{(}\KeywordTok{c}\NormalTok{(lhs, }\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, find_assign3))))}
  \NormalTok{\} else if (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \KeywordTok{unique}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, find_assign3)))}
  \NormalTok{\} else \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{find_assign3}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
  \NormalTok{a <-}\StringTok{ }\DecValTok{1}
  \NormalTok{b <-}\StringTok{ }\DecValTok{2}
  \NormalTok{a <-}\StringTok{ }\DecValTok{3}
\NormalTok{\}))}
\CommentTok{#> [1] "a" "b"}

\KeywordTok{find_assign3}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
  \KeywordTok{system.time}\NormalTok{(x <-}\StringTok{ }\KeywordTok{print}\NormalTok{(y <-}\StringTok{ }\DecValTok{5}\NormalTok{))}
\NormalTok{\}))}
\CommentTok{#> [1] "x" "y"}
\end{Highlighting}
\end{Shaded}

We also need to test subassignment:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{find_assign3}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
  \NormalTok{l <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
  \NormalTok{l$a <-}\StringTok{ }\DecValTok{5}
  \KeywordTok{names}\NormalTok{(l) <-}\StringTok{ "b"}
\NormalTok{\}))}
\CommentTok{#> [1] "l"     "$"     "a"     "names"}
\end{Highlighting}
\end{Shaded}

We only want assignment of the object itself, not assignment that
modifies a property of the object. Drawing the tree for the quoted
object will help us see what condition to test for. The second element
of the call to \texttt{\textless{}-} should be a name, not another call.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ast}\NormalTok{(l$a <-}\StringTok{ }\DecValTok{5}\NormalTok{)}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `<-}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `$}
\CommentTok{#>     \textbackslash{}- `l}
\CommentTok{#>     \textbackslash{}- `a}
\CommentTok{#>   \textbackslash{}-  5}
\KeywordTok{ast}\NormalTok{(}\KeywordTok{names}\NormalTok{(l) <-}\StringTok{ "b"}\NormalTok{)}
\CommentTok{#> \textbackslash{}- ()}
\CommentTok{#>   \textbackslash{}- `<-}
\CommentTok{#>   \textbackslash{}- ()}
\CommentTok{#>     \textbackslash{}- `names}
\CommentTok{#>     \textbackslash{}- `l}
\CommentTok{#>   \textbackslash{}-  "b"}
\end{Highlighting}
\end{Shaded}

Now we have a complete version:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{find_assign4 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.name}\NormalTok{(x)) \{}
    \KeywordTok{character}\NormalTok{()}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \NormalTok{if (}\KeywordTok{identical}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]], }\KeywordTok{quote}\NormalTok{(}\StringTok{`}\DataTypeTok{<-}\StringTok{`}\NormalTok{)) &&}\StringTok{ }\KeywordTok{is.name}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])) \{}
      \NormalTok{lhs <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]])}
    \NormalTok{\} else \{}
      \NormalTok{lhs <-}\StringTok{ }\KeywordTok{character}\NormalTok{()}
    \NormalTok{\}}

    \KeywordTok{unique}\NormalTok{(}\KeywordTok{c}\NormalTok{(lhs, }\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, find_assign4))))}
  \NormalTok{\} else if (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \KeywordTok{unique}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, find_assign4)))}
  \NormalTok{\} else \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{find_assign4}\NormalTok{(}\KeywordTok{quote}\NormalTok{(\{}
  \NormalTok{l <-}\StringTok{ }\KeywordTok{list}\NormalTok{()}
  \NormalTok{l$a <-}\StringTok{ }\DecValTok{5}
  \KeywordTok{names}\NormalTok{(l) <-}\StringTok{ "b"}
\NormalTok{\}))}
\CommentTok{#> [1] "l"}
\end{Highlighting}
\end{Shaded}

While the complete version of this function is quite complicated, it's
important to remember we wrote it by working our way up by writing
simple component parts.

\subsection{Modifying the call tree}\label{modifying-code}

The next step up in complexity is returning a modified call tree, like
what you get with \texttt{bquote()}. \texttt{bquote()} is a slightly
more flexible form of quote: it allows you to optionally quote and
unquote some parts of an expression (it's similar to the backtick
operator in Lisp). Everything is quoted, \emph{unless} it's encapsulated
in \texttt{.()} in which case it's evaluated and the result is inserted:
\index{bquote()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{1}
\NormalTok{b <-}\StringTok{ }\DecValTok{3}
\KeywordTok{bquote}\NormalTok{(a +}\StringTok{ }\NormalTok{b)}
\CommentTok{#> a + b}
\KeywordTok{bquote}\NormalTok{(a +}\StringTok{ }\NormalTok{.(b))}
\CommentTok{#> a + 3}
\KeywordTok{bquote}\NormalTok{(.(a) +}\StringTok{ }\NormalTok{.(b))}
\CommentTok{#> 1 + 3}
\KeywordTok{bquote}\NormalTok{(.(a +}\StringTok{ }\NormalTok{b))}
\CommentTok{#> [1] 4}
\end{Highlighting}
\end{Shaded}

This provides a fairly easy way to control what gets evaluated and when.
How does \texttt{bquote()} work? Below, I've rewritten \texttt{bquote()}
to use the same style as our other functions: it expects input to be
quoted already, and makes the base and recursive cases more explicit:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bquote2 <-}\StringTok{ }\NormalTok{function (x, }\DataTypeTok{where =} \KeywordTok{parent.frame}\NormalTok{()) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.name}\NormalTok{(x)) \{}
    \CommentTok{# Leave unchanged}
    \NormalTok{x}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \NormalTok{if (}\KeywordTok{identical}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]], }\KeywordTok{quote}\NormalTok{(.))) \{}
      \CommentTok{# Call to .(), so evaluate}
      \KeywordTok{eval}\NormalTok{(x[[}\DecValTok{2}\NormalTok{]], where)}
    \NormalTok{\} else \{}
      \CommentTok{# Otherwise apply recursively, turning result back into call}
      \KeywordTok{as.call}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, bquote2, }\DataTypeTok{where =} \NormalTok{where))}
    \NormalTok{\}}
  \NormalTok{\} else if (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \KeywordTok{as.pairlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x, bquote2, }\DataTypeTok{where =} \NormalTok{where))}
  \NormalTok{\} else \{}
    \CommentTok{# User supplied incorrect input}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}

\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{y <-}\StringTok{ }\DecValTok{2}
\KeywordTok{bquote2}\NormalTok{(}\KeywordTok{quote}\NormalTok{(x ==}\StringTok{ }\NormalTok{.(x)))}
\CommentTok{#> x == 1}
\KeywordTok{bquote2}\NormalTok{(}\KeywordTok{quote}\NormalTok{(function(}\DataTypeTok{x =} \NormalTok{.(x)) \{}
  \NormalTok{x +}\StringTok{ }\NormalTok{.(y)}
\NormalTok{\}))}
\CommentTok{#> function(x = 1) \{}
\CommentTok{#>     x + 2}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

The main difference between this and the previous recursive functions is
that after we process each element of calls and pairlists, we need to
coerce them back to their original types.

Note that functions that modify the source tree are most useful for
creating expressions that are used at run-time, rather than those that
are saved back to the original source file. This is because all non-code
information is lost:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bquote2}\NormalTok{(}\KeywordTok{quote}\NormalTok{(function(}\DataTypeTok{x =} \NormalTok{.(x)) \{}
  \CommentTok{# This is a comment}
  \NormalTok{x +}\StringTok{  }\CommentTok{# funky spacing}
\StringTok{    }\NormalTok{.(y)}
\NormalTok{\}))}
\CommentTok{#> function(x = 1) \{}
\CommentTok{#>     x + 2}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

These tools are somewhat similar to Lisp macros, as discussed in
\href{http://www.r-project.org/doc/Rnews/Rnews_2001-3.pdf\#page=10}{Programmer's
Niche: Macros in R} by Thomas Lumley. However, macros are run at
compile-time, which doesn't have any meaning in R, and always return
expressions. They're also somewhat like Lisp
\href{http://en.wikipedia.org/wiki/Fexpr}{fexprs}. A fexpr is a function
where the arguments are not evaluated by default. The terms macro and
fexpr are useful to know when looking for useful techniques from other
languages. \index{macros} \index{fexprs}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Why does \texttt{logical\_abbr()} use a for loop instead of a
  functional like \texttt{lapply()}?
\item
  \texttt{logical\_abbr()} works when given quoted objects, but doesn't
  work when given an existing function, as in the example below. Why
  not? How could you modify \texttt{logical\_abbr()} to work with
  functions? Think about what components make up a function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{x =} \OtherTok{TRUE}\NormalTok{) \{}
  \KeywordTok{g}\NormalTok{(x +}\StringTok{ }\NormalTok{T)}
\NormalTok{\}}
\KeywordTok{logical_abbr}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}
\item
  Write a function called \texttt{ast\_type()} that returns either
  ``constant'', ``name'', ``call'', or ``pairlist''. Rewrite
  \texttt{logical\_abbr()}, \texttt{find\_assign()}, and
  \texttt{bquote2()} to use this function with \texttt{switch()} instead
  of nested if statements.
\item
  Write a function that extracts all calls to a function. Compare your
  function to \texttt{pryr::fun\_calls()}.
\item
  Write a wrapper around \texttt{bquote2()} that does non-standard
  evaluation so that you don't need to explicitly \texttt{quote()} the
  input.
\item
  Compare \texttt{bquote2()} to \texttt{bquote()}. There is a subtle bug
  in \texttt{bquote()}: it won't replace calls to functions with no
  arguments. Why?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{bquote}\NormalTok{(.(x)(), }\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{quote}\NormalTok{(f)))}
\CommentTok{#> .(x)()}
\KeywordTok{bquote}\NormalTok{(.(x)(}\DecValTok{1}\NormalTok{), }\KeywordTok{list}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{quote}\NormalTok{(f)))}
\CommentTok{#> f(1)}
\end{Highlighting}
\end{Shaded}
\item
  Improve the base \texttt{recurse\_call()} template to also work with
  lists of functions and expressions (e.g., as from
  \texttt{parse(path\_to\_file))}.
\end{enumerate}
