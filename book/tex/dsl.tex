\chapter{Domain specific languages}\label{dsl}

The combination of first class environments, lexical scoping,
non-standard evaluation, and metaprogramming gives us a powerful toolkit
for creating embedded domain specific languages (DSLs) in R. Embedded
DSLs take advantage of a host language's parsing and execution
framework, but adjust the semantics to make them more suitable for a
specific task. DSLs are a very large topic, and this chapter will only
scratch the surface, focussing on important implementation techniques
rather than on how you might come up with the language in the first
place. If you're interested in learning more, I highly recommend
\href{http://amzn.com/0321712943?tag=devtools-20}{\emph{Domain Specific
Languages}} by Martin Fowler. It discusses many options for creating a
DSL and provides many examples of different languages.
\index{domain specific languages}

R's most popular DSL is the formula specification, which provides a
succinct way of describing the relationship between predictors and the
response in a model. Other examples include ggplot2 (for visualisation)
and plyr (for data manipulation). Another package that makes extensive
use of these ideas is dplyr, which provides \texttt{translate\_sql()} to
convert R expressions into SQL:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\KeywordTok{translate_sql}\NormalTok{(}\KeywordTok{sin}\NormalTok{(x) +}\StringTok{ }\KeywordTok{tan}\NormalTok{(y))}
\CommentTok{#> <SQL> SIN("x") + TAN("y")}
\KeywordTok{translate_sql}\NormalTok{(x <}\StringTok{ }\DecValTok{5} \NormalTok{&}\StringTok{ }\NormalTok{!(y >=}\StringTok{ }\DecValTok{5}\NormalTok{))}
\CommentTok{#> <SQL> "x" < 5.0 AND NOT(("y" >= 5.0))}
\KeywordTok{translate_sql}\NormalTok{(first %like%}\StringTok{ "Had*"}\NormalTok{)}
\CommentTok{#> <SQL> "first" LIKE 'Had*'}
\KeywordTok{translate_sql}\NormalTok{(first %in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"John"}\NormalTok{, }\StringTok{"Roger"}\NormalTok{, }\StringTok{"Robert"}\NormalTok{))}
\CommentTok{#> <SQL> "first" IN ('John', 'Roger', 'Robert')}
\KeywordTok{translate_sql}\NormalTok{(like ==}\StringTok{ }\DecValTok{7}\NormalTok{)}
\CommentTok{#> <SQL> "like" = 7.0}
\end{Highlighting}
\end{Shaded}

This chapter will develop two simple, but useful DSLs: one to generate
HTML, and the other to turn mathematical expressions expressed in R code
into LaTeX.

\paragraph{Prerequisites}

This chapter together pulls together many techniques discussed elsewhere
in the book. In particular, you'll need to understand environments,
functionals, non-standard evaluation, and metaprogramming.

\section{HTML}\label{html}

HTML (hypertext markup language) is the language that underlies the
majority of the web. It's a special case of SGML (standard generalised
markup language), and it's similar but not identical to XML (extensible
markup language). HTML looks like this: \index{HTML}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<body>}
  \KeywordTok{<h1}\OtherTok{ id=}\StringTok{'first'}\KeywordTok{>}\NormalTok{A heading}\KeywordTok{</h1>}
  \KeywordTok{<p>}\NormalTok{Some text }\DecValTok{&amp;} \KeywordTok{<b>}\NormalTok{some bold text.}\KeywordTok{</b></p>}
  \KeywordTok{<img}\OtherTok{ src=}\StringTok{'myimg.png'}\OtherTok{ width=}\StringTok{'100'}\OtherTok{ height=}\StringTok{'100'} \KeywordTok{/>}
\KeywordTok{</body>}
\end{Highlighting}
\end{Shaded}

Even if you've never looked at HTML before, you can still see that the
key component of its coding structure is tags,
\texttt{\textless{}tag\textgreater{}\textless{}/tag\textgreater{}}. Tags
can be contained inside other tags and intermingled with text.
Generally, HTML ignores whitespaces (a sequence of whitespace is
equivalent to a single space) so you could put the previous example on a
single line and it would still display the same in a browser:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<body><h1}\OtherTok{ id=}\StringTok{'first'}\KeywordTok{>}\NormalTok{A heading}\KeywordTok{</h1><p>}\NormalTok{Some text }\DecValTok{&amp;} \KeywordTok{<b>}\NormalTok{some bold}
\NormalTok{text.}\KeywordTok{</b></p><img}\OtherTok{ src=}\StringTok{'myimg.png'}\OtherTok{ width=}\StringTok{'100'}\OtherTok{ height=}\StringTok{'100'} \KeywordTok{/>}
\KeywordTok{</body>}
\end{Highlighting}
\end{Shaded}

However, like R code, you usually want to indent HTML to make the
structure more obvious.

There are over 100 HTML tags. But to illustrate HTML, we're going to
focus on just a few:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{\textless{}body\textgreater{}}: the top-level tag that all
  content is enclosed within
\item
  \texttt{\textless{}h1\textgreater{}}: creates a heading-1, the top
  level heading
\item
  \texttt{\textless{}p\textgreater{}}: creates a paragraph
\item
  \texttt{\textless{}b\textgreater{}}: emboldens text
\item
  \texttt{\textless{}img\textgreater{}}: embeds an image
\end{itemize}

(You probably guessed what these did already!)

Tags can also have named attributes. They look like
\texttt{\textless{}tag a="a" b="b"\textgreater{}\textless{}/tag\textgreater{}}.
Tag values should always be enclosed in either single or double quotes.
Two important attributes used with just about every tag are \texttt{id}
and \texttt{class}. These are used in conjunction with CSS (cascading
style sheets) in order to control the style of the document.

Some tags, like \texttt{\textless{}img\textgreater{}}, can't have any
content. These are called \textbf{void tags} and have a slightly
different syntax. Instead of writing
\texttt{\textless{}img\textgreater{}\textless{}/img\textgreater{}}, you
write \texttt{\textless{}img /\textgreater{}}. Since they have no
content, attributes are more important. In fact, \texttt{img} has three
that are used for almost every image: \texttt{src} (where the image
lives), \texttt{width}, and \texttt{height}.

Because \texttt{\textless{}} and \texttt{\textgreater{}} have special
meanings in HTML, you can't write them directly. Instead you have to use
the HTML escapes: \texttt{\&gt;} and \texttt{\&lt;}. And, since those
escapes use \texttt{\&}, if you want a literal ampersand you have to
escape with \texttt{\&amp;}.

\subsection{Goal}

Our goal is to make it easy to generate HTML from R. To give a concrete
example, we want to generate the following HTML with code that looks as
similar to the HTML as possible.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{<body>}
  \KeywordTok{<h1}\OtherTok{ id=}\StringTok{'first'}\KeywordTok{>}\NormalTok{A heading}\KeywordTok{</h1>}
  \KeywordTok{<p>}\NormalTok{Some text }\DecValTok{&amp;} \KeywordTok{<b>}\NormalTok{some bold text.}\KeywordTok{</b></p>}
  \KeywordTok{<img}\OtherTok{ src=}\StringTok{'myimg.png'}\OtherTok{ width=}\StringTok{'100'}\OtherTok{ height=}\StringTok{'100'} \KeywordTok{/>}
\KeywordTok{</body>}
\end{Highlighting}
\end{Shaded}

To do so, we will work our way up to the following DSL:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{body}\NormalTok{(}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"A heading"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"first"}\NormalTok{),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Some text &"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"some bold text."}\NormalTok{)),}
  \KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimg.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Note that the nesting of function calls is the same as the nesting of
tags: unnamed arguments become the content of the tag, and named
arguments become their attributes. Because tags and text are clearly
distinct in this API, we can automatically escape \texttt{\&} and other
special characters.

\subsection{Escaping}

Escaping is so fundamental to DSLs that it'll be our first topic. To
create a way of escaping characters, we need to give ``\&'' a special
meaning without ending up double-escaping. The easiest way to do this is
to create an S3 class that distinguishes between regular text (that
needs escaping) and HTML (that doesn't). \index{escaping}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{structure}\NormalTok{(x, }\DataTypeTok{class =} \StringTok{"html"}\NormalTok{)}
\NormalTok{print.html <-}\StringTok{ }\NormalTok{function(x, ...) \{}
  \NormalTok{out <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"<HTML> "}\NormalTok{, x)}
  \KeywordTok{cat}\NormalTok{(}\KeywordTok{paste}\NormalTok{(}\KeywordTok{strwrap}\NormalTok{(out), }\DataTypeTok{collapse =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{), }\StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We then write an escape method that leaves HTML unchanged and escapes
the special characters (\texttt{\&}, \texttt{\textless{}},
\texttt{\textgreater{}}) for ordinary text. We also add a list method
for convenience.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{escape <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{UseMethod}\NormalTok{(}\StringTok{"escape"}\NormalTok{)}
\NormalTok{escape.html <-}\StringTok{ }\NormalTok{function(x) x}
\NormalTok{escape.character <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"&"}\NormalTok{, }\StringTok{"&amp;"}\NormalTok{, x)}
  \NormalTok{x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{"<"}\NormalTok{, }\StringTok{"&lt;"}\NormalTok{, x)}
  \NormalTok{x <-}\StringTok{ }\KeywordTok{gsub}\NormalTok{(}\StringTok{">"}\NormalTok{, }\StringTok{"&gt;"}\NormalTok{, x)}

  \KeywordTok{html}\NormalTok{(x)}
\NormalTok{\}}
\NormalTok{escape.list <-}\StringTok{ }\NormalTok{function(x) \{}
  \KeywordTok{lapply}\NormalTok{(x, escape)}
\NormalTok{\}}

\CommentTok{# Now we check that it works}
\KeywordTok{escape}\NormalTok{(}\StringTok{"This is some text."}\NormalTok{)}
\CommentTok{#> <HTML> This is some text.}
\KeywordTok{escape}\NormalTok{(}\StringTok{"x > 1 & y < 2"}\NormalTok{)}
\CommentTok{#> <HTML> x &gt; 1 &amp; y &lt; 2}

\CommentTok{# Double escaping is not a problem}
\KeywordTok{escape}\NormalTok{(}\KeywordTok{escape}\NormalTok{(}\StringTok{"This is some text. 1 > 2"}\NormalTok{))}
\CommentTok{#> <HTML> This is some text. 1 &gt; 2}

\CommentTok{# And text we know is HTML doesn't get escaped.}
\KeywordTok{escape}\NormalTok{(}\KeywordTok{html}\NormalTok{(}\StringTok{"<hr />"}\NormalTok{))}
\CommentTok{#> <HTML> <hr />}
\end{Highlighting}
\end{Shaded}

Escaping is an important component for many DSLs.

\subsection{Basic tag functions}

Next, we'll write a few simple tag functions and then figure out how to
generalise this function to cover all possible HTML tags. Let's start
with \texttt{\textless{}p\textgreater{}}. HTML tags can have both
attributes (e.g., id or class) and children (like
\texttt{\textless{}b\textgreater{}} or
\texttt{\textless{}i\textgreater{}}). We need some way of separating
these in the function call. Given that attributes are named values and
children don't have names, it seems natural to separate using named
arguments from unnamed ones. For example, a call to \texttt{p()} might
look like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text."}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"some bold text"}\NormalTok{), }\DataTypeTok{class =} \StringTok{"mypara"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We could list all the possible attributes of the
\texttt{\textless{}p\textgreater{}} tag in the function definition.
However, that's hard not only because there are many attributes, but
also because it's possible to use
\href{http://html5doctor.com/html5-custom-data-attributes/}{custom
attributes}. Instead, we'll just use \texttt{...} and separate the
components based on whether or not they are named. To do this correctly,
we need to be aware of an inconsistency in \texttt{names()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{))}
\CommentTok{#> [1] "a" "b"}
\KeywordTok{names}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{#> [1] "a" ""}
\KeywordTok{names}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{))}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

With this in mind, we create two helper functions to extract the named
and unnamed components of a vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{named <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.null}\NormalTok{(}\KeywordTok{names}\NormalTok{(x))) }\KeywordTok{return}\NormalTok{(}\OtherTok{NULL}\NormalTok{)}
  \NormalTok{x[}\KeywordTok{names}\NormalTok{(x) !=}\StringTok{ ""}\NormalTok{]}
\NormalTok{\}}
\NormalTok{unnamed <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.null}\NormalTok{(}\KeywordTok{names}\NormalTok{(x))) }\KeywordTok{return}\NormalTok{(x)}
  \NormalTok{x[}\KeywordTok{names}\NormalTok{(x) ==}\StringTok{ ""}\NormalTok{]}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can now create our \texttt{p()} function. Notice that there's one new
function here: \texttt{html\_attributes()}. It uses a list of name-value
pairs to create the correct specification of HTML attributes. It's a
little complicated (in part, because it deals with some idiosyncracies
of HTML that I haven't mentioned.). However, because it's not that
important and doesn't introduce any new ideas, I won't discuss it here
(you can find the source online).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{source}\NormalTok{(}\StringTok{"dsl-html-attributes.r"}\NormalTok{, }\DataTypeTok{local =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{p <-}\StringTok{ }\NormalTok{function(...) \{}
  \NormalTok{args <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
  \NormalTok{attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(}\KeywordTok{named}\NormalTok{(args))}
  \NormalTok{children <-}\StringTok{ }\KeywordTok{unlist}\NormalTok{(}\KeywordTok{escape}\NormalTok{(}\KeywordTok{unnamed}\NormalTok{(args)))}

  \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
    \StringTok{"<p"}\NormalTok{, attribs, }\StringTok{">"}\NormalTok{,}
    \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
    \StringTok{"</p>"}
  \NormalTok{))}
\NormalTok{\}}

\KeywordTok{p}\NormalTok{(}\StringTok{"Some text"}\NormalTok{)}
\CommentTok{#> <HTML> <p>Some text</p>}
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"myid"}\NormalTok{)}
\CommentTok{#> <HTML> <p id = 'myid'>Some text</p>}
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text"}\NormalTok{, }\DataTypeTok{image =} \OtherTok{NULL}\NormalTok{)}
\CommentTok{#> <HTML> <p image>Some text</p>}
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text"}\NormalTok{, }\DataTypeTok{class =} \StringTok{"important"}\NormalTok{, }\StringTok{"data-value"} \NormalTok{=}\StringTok{ }\DecValTok{10}\NormalTok{)}
\CommentTok{#> <HTML> <p class = 'important' data-value = '10'>Some}
\CommentTok{#> text</p>}
\end{Highlighting}
\end{Shaded}

\subsection{Tag functions}

With this definition of \texttt{p()}, it's pretty easy to see how we can
apply this approach to different tags: we just need to replace
\texttt{"p"} with a variable. We'll use a closure to make it easy to
generate a tag function given a tag name:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag <-}\StringTok{ }\NormalTok{function(tag) \{}
  \KeywordTok{force}\NormalTok{(tag)}
  \NormalTok{function(...) \{}
    \NormalTok{args <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
    \NormalTok{attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(}\KeywordTok{named}\NormalTok{(args))}
    \NormalTok{children <-}\StringTok{ }\KeywordTok{unlist}\NormalTok{(}\KeywordTok{escape}\NormalTok{(}\KeywordTok{unnamed}\NormalTok{(args)))}

    \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}
      \StringTok{"<"}\NormalTok{, tag, attribs, }\StringTok{">"}\NormalTok{,}
      \KeywordTok{paste}\NormalTok{(children, }\DataTypeTok{collapse =} \StringTok{""}\NormalTok{),}
      \StringTok{"</"}\NormalTok{, tag, }\StringTok{">"}
    \NormalTok{))}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(We're forcing the evaluation of \texttt{tag} with the expectation that
we'll be calling this function from a loop. This will help to avoid
potential bugs caused by lazy evaluation.)

Now we can run our earlier example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"p"}\NormalTok{)}
\NormalTok{b <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"b"}\NormalTok{)}
\NormalTok{i <-}\StringTok{ }\KeywordTok{tag}\NormalTok{(}\StringTok{"i"}\NormalTok{)}
\KeywordTok{p}\NormalTok{(}\StringTok{"Some text."}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"Some bold text"}\NormalTok{), }\KeywordTok{i}\NormalTok{(}\StringTok{"Some italic text"}\NormalTok{),}
  \DataTypeTok{class =} \StringTok{"mypara"}\NormalTok{)}
\CommentTok{#> <HTML> <p class = 'mypara'>Some text.<b>Some bold}
\CommentTok{#> text</b><i>Some italic text</i></p>}
\end{Highlighting}
\end{Shaded}

Before we continue writing functions for every possible HTML tag, we
need to create a variant of \texttt{tag()} for void tags. It can be very
similar to \texttt{tag()}, but if there are any unnamed tags, it needs
to throw an error. Also note that the tag itself will look slightly
different:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{void_tag <-}\StringTok{ }\NormalTok{function(tag) \{}
  \KeywordTok{force}\NormalTok{(tag)}
  \NormalTok{function(...) \{}
    \NormalTok{args <-}\StringTok{ }\KeywordTok{list}\NormalTok{(...)}
    \NormalTok{if (}\KeywordTok{length}\NormalTok{(}\KeywordTok{unnamed}\NormalTok{(args)) >}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
      \KeywordTok{stop}\NormalTok{(}\StringTok{"Tag "}\NormalTok{, tag, }\StringTok{" can not have children"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
    \NormalTok{\}}
    \NormalTok{attribs <-}\StringTok{ }\KeywordTok{html_attributes}\NormalTok{(}\KeywordTok{named}\NormalTok{(args))}

    \KeywordTok{html}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag, attribs, }\StringTok{" />"}\NormalTok{))}
  \NormalTok{\}}
\NormalTok{\}}

\NormalTok{img <-}\StringTok{ }\KeywordTok{void_tag}\NormalTok{(}\StringTok{"img"}\NormalTok{)}
\KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimage.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\CommentTok{#> <HTML> <img src = 'myimage.png' width = '100' height =}
\CommentTok{#> '100' />}
\end{Highlighting}
\end{Shaded}

\subsection{Processing all tags}

Next we need a list of all the HTML tags:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"abbr"}\NormalTok{, }\StringTok{"address"}\NormalTok{, }\StringTok{"article"}\NormalTok{, }\StringTok{"aside"}\NormalTok{, }\StringTok{"audio"}\NormalTok{, }
  \StringTok{"b"}\NormalTok{,}\StringTok{"bdi"}\NormalTok{, }\StringTok{"bdo"}\NormalTok{, }\StringTok{"blockquote"}\NormalTok{, }\StringTok{"body"}\NormalTok{, }\StringTok{"button"}\NormalTok{, }\StringTok{"canvas"}\NormalTok{, }
  \StringTok{"caption"}\NormalTok{,}\StringTok{"cite"}\NormalTok{, }\StringTok{"code"}\NormalTok{, }\StringTok{"colgroup"}\NormalTok{, }\StringTok{"data"}\NormalTok{, }\StringTok{"datalist"}\NormalTok{, }
  \StringTok{"dd"}\NormalTok{, }\StringTok{"del"}\NormalTok{,}\StringTok{"details"}\NormalTok{, }\StringTok{"dfn"}\NormalTok{, }\StringTok{"div"}\NormalTok{, }\StringTok{"dl"}\NormalTok{, }\StringTok{"dt"}\NormalTok{, }\StringTok{"em"}\NormalTok{, }
  \StringTok{"eventsource"}\NormalTok{,}\StringTok{"fieldset"}\NormalTok{, }\StringTok{"figcaption"}\NormalTok{, }\StringTok{"figure"}\NormalTok{, }\StringTok{"footer"}\NormalTok{, }
  \StringTok{"form"}\NormalTok{, }\StringTok{"h1"}\NormalTok{, }\StringTok{"h2"}\NormalTok{, }\StringTok{"h3"}\NormalTok{, }\StringTok{"h4"}\NormalTok{, }\StringTok{"h5"}\NormalTok{, }\StringTok{"h6"}\NormalTok{, }\StringTok{"head"}\NormalTok{, }\StringTok{"header"}\NormalTok{, }
  \StringTok{"hgroup"}\NormalTok{, }\StringTok{"html"}\NormalTok{, }\StringTok{"i"}\NormalTok{,}\StringTok{"iframe"}\NormalTok{, }\StringTok{"ins"}\NormalTok{, }\StringTok{"kbd"}\NormalTok{, }\StringTok{"label"}\NormalTok{, }
  \StringTok{"legend"}\NormalTok{, }\StringTok{"li"}\NormalTok{, }\StringTok{"mark"}\NormalTok{, }\StringTok{"map"}\NormalTok{,}\StringTok{"menu"}\NormalTok{, }\StringTok{"meter"}\NormalTok{, }\StringTok{"nav"}\NormalTok{, }
  \StringTok{"noscript"}\NormalTok{, }\StringTok{"object"}\NormalTok{, }\StringTok{"ol"}\NormalTok{, }\StringTok{"optgroup"}\NormalTok{, }\StringTok{"option"}\NormalTok{, }\StringTok{"output"}\NormalTok{, }
  \StringTok{"p"}\NormalTok{, }\StringTok{"pre"}\NormalTok{, }\StringTok{"progress"}\NormalTok{, }\StringTok{"q"}\NormalTok{, }\StringTok{"ruby"}\NormalTok{, }\StringTok{"rp"}\NormalTok{,}\StringTok{"rt"}\NormalTok{, }\StringTok{"s"}\NormalTok{, }\StringTok{"samp"}\NormalTok{, }
  \StringTok{"script"}\NormalTok{, }\StringTok{"section"}\NormalTok{, }\StringTok{"select"}\NormalTok{, }\StringTok{"small"}\NormalTok{, }\StringTok{"span"}\NormalTok{, }\StringTok{"strong"}\NormalTok{, }
  \StringTok{"style"}\NormalTok{, }\StringTok{"sub"}\NormalTok{, }\StringTok{"summary"}\NormalTok{, }\StringTok{"sup"}\NormalTok{, }\StringTok{"table"}\NormalTok{, }\StringTok{"tbody"}\NormalTok{, }\StringTok{"td"}\NormalTok{, }
  \StringTok{"textarea"}\NormalTok{, }\StringTok{"tfoot"}\NormalTok{, }\StringTok{"th"}\NormalTok{, }\StringTok{"thead"}\NormalTok{, }\StringTok{"time"}\NormalTok{, }\StringTok{"title"}\NormalTok{, }\StringTok{"tr"}\NormalTok{,}
  \StringTok{"u"}\NormalTok{, }\StringTok{"ul"}\NormalTok{, }\StringTok{"var"}\NormalTok{, }\StringTok{"video"}\NormalTok{)}

\NormalTok{void_tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"area"}\NormalTok{, }\StringTok{"base"}\NormalTok{, }\StringTok{"br"}\NormalTok{, }\StringTok{"col"}\NormalTok{, }\StringTok{"command"}\NormalTok{, }\StringTok{"embed"}\NormalTok{,}
  \StringTok{"hr"}\NormalTok{, }\StringTok{"img"}\NormalTok{, }\StringTok{"input"}\NormalTok{, }\StringTok{"keygen"}\NormalTok{, }\StringTok{"link"}\NormalTok{, }\StringTok{"meta"}\NormalTok{, }\StringTok{"param"}\NormalTok{, }
  \StringTok{"source"}\NormalTok{, }\StringTok{"track"}\NormalTok{, }\StringTok{"wbr"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you look at this list carefully, you'll see there are quite a few
tags that have the same name as base R functions (\texttt{body},
\texttt{col}, \texttt{q}, \texttt{source}, \texttt{sub},
\texttt{summary}, \texttt{table}), and others that have the same name as
popular packages (e.g., \texttt{map}). This means we don't want to make
all the functions available by default, in either the global environment
or the package environment. Instead, we'll put them in a list and add
some additional code to make it easy to use them when desired. First, we
make a named list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag_fs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \KeywordTok{setNames}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(tags, tag), tags),}
  \KeywordTok{setNames}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(void_tags, void_tag), void_tags)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This gives us an explicit (but verbose) way to call tag functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tag_fs$}\KeywordTok{p}\NormalTok{(}\StringTok{"Some text."}\NormalTok{, tag_fs$}\KeywordTok{b}\NormalTok{(}\StringTok{"Some bold text"}\NormalTok{),}
  \NormalTok{tag_fs$}\KeywordTok{i}\NormalTok{(}\StringTok{"Some italic text"}\NormalTok{))}
\CommentTok{#> <HTML> <p>Some text.<b>Some bold text</b><i>Some}
\CommentTok{#> italic text</i></p>}
\end{Highlighting}
\end{Shaded}

We can then finish off our HTML DSL with a function that allows us to
evaluate code in the context of that list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{with_html <-}\StringTok{ }\NormalTok{function(code) \{}
  \KeywordTok{eval}\NormalTok{(}\KeywordTok{substitute}\NormalTok{(code), tag_fs)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This gives us a succinct API which allows us to write HTML when we need
it but doesn't clutter up the namespace when we don't.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with_html}\NormalTok{(}\KeywordTok{body}\NormalTok{(}
  \KeywordTok{h1}\NormalTok{(}\StringTok{"A heading"}\NormalTok{, }\DataTypeTok{id =} \StringTok{"first"}\NormalTok{),}
  \KeywordTok{p}\NormalTok{(}\StringTok{"Some text &"}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"some bold text."}\NormalTok{)),}
  \KeywordTok{img}\NormalTok{(}\DataTypeTok{src =} \StringTok{"myimg.png"}\NormalTok{, }\DataTypeTok{width =} \DecValTok{100}\NormalTok{, }\DataTypeTok{height =} \DecValTok{100}\NormalTok{)}
\NormalTok{))}
\CommentTok{#> <HTML> <body><h1 id = 'first'>A heading</h1><p>Some}
\CommentTok{#> text &amp;<b>some bold text.</b></p><img src =}
\CommentTok{#> 'myimg.png' width = '100' height = '100' /></body>}
\end{Highlighting}
\end{Shaded}

If you want to access the R function overridden by an HTML tag with the
same name inside \texttt{with\_html()}, you can use the full
\texttt{package::function} specification.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The escaping rules for \texttt{\textless{}script\textgreater{}} and
  \texttt{\textless{}style\textgreater{}} tags are different: you don't
  want to escape angle brackets or ampersands, but you do want to escape
  \texttt{\textless{}/script\textgreater{}} or
  \texttt{\textless{}/style\textgreater{}}. Adapt the code above to
  follow these rules.
\item
  The use of \texttt{...} for all functions has some big downsides.
  There's no input validation and there will be little information in
  the documentation or autocomplete about how they are used in the
  function. Create a new function that, when given a named list of tags
  and their\\attribute names (like below), creates functions which
  address this problem.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{a =} \KeywordTok{c}\NormalTok{(}\StringTok{"href"}\NormalTok{),}
  \DataTypeTok{img =} \KeywordTok{c}\NormalTok{(}\StringTok{"src"}\NormalTok{, }\StringTok{"width"}\NormalTok{, }\StringTok{"height"}\NormalTok{)}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

  All tags should get \texttt{class} and \texttt{id} attributes.
\item
  Currently the HTML doesn't look terribly pretty, and it's hard to see
  the structure. How could you adapt \texttt{tag()} to do indenting and
  formatting?
\end{enumerate}

\section{LaTeX}\label{latex}

The next DSL will convert R expressions into their LaTeX math
equivalents. (This is a bit like \texttt{?plotmath}, but for text
instead of plots.) LaTeX is the lingua franca of mathematicians and
statisticians: whenever you want to describe an equation in text (e.g.,
in an email), you write it as a LaTeX equation. Since many reports are
produced using both R and LaTeX, it might be useful to be able to
automatically convert mathematical expressions from one language to the
other. \index{LaTeX}

Because we need to convert both functions and names, this mathematical
DSL will be more complicated than the HTML DSL. We'll also need to
create a ``default'' conversion, so that functions we don't know about
get a standard conversion. Like the HTML DSL, we'll also write
functionals to make it easier to generate the translators.

Before we begin, let's quickly cover how formulas are expressed in
LaTeX.

\subsection{LaTeX mathematics}

LaTeX mathematics are complex. Fortunately, they are
\href{http://en.wikibooks.org/wiki/LaTeX/Mathematics}{well documented}.
That said, they have a fairly simple structure:

\begin{itemize}
\item
  Most simple mathematical equations are written in the same way you'd
  type them in R: \texttt{x * y}, \texttt{z \^{} 5}. Subscripts are
  written using \texttt{\_} (e.g., \texttt{x\_1}).
\item
  Special characters start with a \texttt{\textbackslash{}}:
  \texttt{\textbackslash{}pi} = π, \texttt{\textbackslash{}pm} = ±, and
  so on. There are a huge number of symbols available in LaTeX. Googling
  for \texttt{latex math symbols} will return many
  \href{http://www.sunilpatel.co.uk/latex-type/latex-math-symbols/}{lists}.
  There's even \href{http://detexify.kirelabs.org/classify.html}{a
  service} that will look up the symbol you sketch in the browser.
\item
  More complicated functions look like
  \texttt{\textbackslash{}name\{arg1\}\{arg2\}}. For example, to write a
  fraction you'd use \texttt{\textbackslash{}frac\{a\}\{b\}}. To write a
  square root, you'd use \texttt{\textbackslash{}sqrt\{a\}}.
\item
  To group elements together use \texttt{\{\}}: i.e.,
  \texttt{x \^{} a + b} vs. \texttt{x \^{} \{a + b\}}.
\item
  In good math typesetting, a distinction is made between variables and
  functions. But without extra information, LaTeX doesn't know whether
  \texttt{f(a * b)} represents calling the function \texttt{f} with
  input \texttt{a * b}, or is shorthand for \texttt{f * (a * b)}. If
  \texttt{f} is a function, you can tell LaTeX to typeset it using an
  upright font with \texttt{\textbackslash{}textrm\{f\}(a * b)}.
\end{itemize}

\subsection{Goal}

Our goal is to use these rules to automatically convert an R expression
to its appropriate LaTeX representation. We'll tackle this in four
stages:

\begin{itemize}
\item
  Convert known symbols: \texttt{pi} -\textgreater{}
  \texttt{\textbackslash{}pi}
\item
  Leave other symbols unchanged: \texttt{x} -\textgreater{} \texttt{x},
  \texttt{y} -\textgreater{} \texttt{y}
\item
  Convert known functions to their special forms:
  \texttt{sqrt(frac(a, b))} -\textgreater{}
  \texttt{\textbackslash{}sqrt\{\textbackslash{}frac\{a, b\}\}}
\item
  Wrap unknown functions with \texttt{\textbackslash{}textrm}:
  \texttt{f(a)} -\textgreater{} \texttt{\textbackslash{}textrm\{f\}(a)}
\end{itemize}

We'll code this translation in the opposite direction of what we did
with the HTML DSL. We'll start with infrastructure, because that makes
it easy to experiment with our DSL, and then work our way back down to
generate the desired output.

\subsection{\texttt{to\_math}}

To begin, we need a wrapper function that will convert R expressions
into LaTeX math expressions. This will work the same way as
\texttt{to\_html()}: capture the unevaluated expression and evaluate it
in a special environment. However, the special environment is no longer
fixed. It will vary depending on the expression. We do this in order to
be able to deal with symbols and functions that we haven't yet seen.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{to_math <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{expr <-}\StringTok{ }\KeywordTok{substitute}\NormalTok{(x)}
  \KeywordTok{eval}\NormalTok{(expr, }\KeywordTok{latex_env}\NormalTok{(expr))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Known symbols}

Our first step is to create an environment that will convert the special
LaTeX symbols used for Greek, e.g., \texttt{pi} to
\texttt{\textbackslash{}pi}. This is the same basic trick used in
\texttt{subset} that makes it possible to select column ranges by name
(\texttt{subset(mtcars, , cyl:wt)}): bind a name to a string in a
special environment.

We create that environment by naming a vector, converting the vector
into a list, and converting the list into an environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{greek <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}
  \StringTok{"alpha"}\NormalTok{, }\StringTok{"theta"}\NormalTok{, }\StringTok{"tau"}\NormalTok{, }\StringTok{"beta"}\NormalTok{, }\StringTok{"vartheta"}\NormalTok{, }\StringTok{"pi"}\NormalTok{, }\StringTok{"upsilon"}\NormalTok{,}
  \StringTok{"gamma"}\NormalTok{, }\StringTok{"gamma"}\NormalTok{, }\StringTok{"varpi"}\NormalTok{, }\StringTok{"phi"}\NormalTok{, }\StringTok{"delta"}\NormalTok{, }\StringTok{"kappa"}\NormalTok{, }\StringTok{"rho"}\NormalTok{,}
  \StringTok{"varphi"}\NormalTok{, }\StringTok{"epsilon"}\NormalTok{, }\StringTok{"lambda"}\NormalTok{, }\StringTok{"varrho"}\NormalTok{, }\StringTok{"chi"}\NormalTok{, }\StringTok{"varepsilon"}\NormalTok{,}
  \StringTok{"mu"}\NormalTok{, }\StringTok{"sigma"}\NormalTok{, }\StringTok{"psi"}\NormalTok{, }\StringTok{"zeta"}\NormalTok{, }\StringTok{"nu"}\NormalTok{, }\StringTok{"varsigma"}\NormalTok{, }\StringTok{"omega"}\NormalTok{, }\StringTok{"eta"}\NormalTok{,}
  \StringTok{"xi"}\NormalTok{, }\StringTok{"Gamma"}\NormalTok{, }\StringTok{"Lambda"}\NormalTok{, }\StringTok{"Sigma"}\NormalTok{, }\StringTok{"Psi"}\NormalTok{, }\StringTok{"Delta"}\NormalTok{, }\StringTok{"Xi"}\NormalTok{, }
  \StringTok{"Upsilon"}\NormalTok{, }\StringTok{"Omega"}\NormalTok{, }\StringTok{"Theta"}\NormalTok{, }\StringTok{"Pi"}\NormalTok{, }\StringTok{"Phi"}\NormalTok{)}
\NormalTok{greek_list <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{"}\NormalTok{, greek), greek)}
\NormalTok{greek_env <-}\StringTok{ }\KeywordTok{list2env}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(greek_list), }\DataTypeTok{parent =} \KeywordTok{emptyenv}\NormalTok{())}
\end{Highlighting}
\end{Shaded}

We can then check it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\NormalTok{function(expr) \{}
  \NormalTok{greek_env}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(pi)}
\CommentTok{#> [1] "\textbackslash{}\textbackslash{}pi"}
\KeywordTok{to_math}\NormalTok{(beta)}
\CommentTok{#> [1] "\textbackslash{}\textbackslash{}beta"}
\end{Highlighting}
\end{Shaded}

\subsection{Unknown symbols}

If a symbol isn't Greek, we want to leave it as is. This is tricky
because we don't know in advance what symbols will be used, and we can't
possibly generate them all. So we'll use a little bit of metaprogramming
to find out what symbols are present in an expression. The
\texttt{all\_names} function takes an expression and does the following:
if it's a name, it converts it to a string; if it's a call, it recurses
down through its arguments.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all_names <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x)) \{}
    \KeywordTok{character}\NormalTok{()}
  \NormalTok{\} else if (}\KeywordTok{is.name}\NormalTok{(x)) \{}
    \KeywordTok{as.character}\NormalTok{(x)}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \NormalTok{children <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(x[-}\DecValTok{1}\NormalTok{], all_names)}
    \KeywordTok{unique}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(children))}
  \NormalTok{\} else \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }
      \DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{all_names}\NormalTok{(}\KeywordTok{quote}\NormalTok{(x +}\StringTok{ }\NormalTok{y +}\StringTok{ }\KeywordTok{f}\NormalTok{(a, b, c, }\DecValTok{10}\NormalTok{)))}
\CommentTok{#> [1] "x" "y" "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

We now want to take that list of symbols, and convert it to an
environment so that each symbol is mapped to its corresponding string
representation (e.g., so \texttt{eval(quote(x), env)} yields
\texttt{"x"}). We again use the pattern of converting a named character
vector to a list, then converting the list to an environment.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\NormalTok{function(expr) \{}
  \NormalTok{names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
  \NormalTok{symbol_list <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(names), names)}
  \NormalTok{symbol_env <-}\StringTok{ }\KeywordTok{list2env}\NormalTok{(symbol_list)}

  \NormalTok{symbol_env}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(x)}
\CommentTok{#> [1] "x"}
\KeywordTok{to_math}\NormalTok{(longvariablename)}
\CommentTok{#> [1] "longvariablename"}
\KeywordTok{to_math}\NormalTok{(pi)}
\CommentTok{#> [1] "pi"}
\end{Highlighting}
\end{Shaded}

This works, but we need to combine it with the Greek symbols
environment. Since we want to give preference to Greek over defaults
(e.g., \texttt{to\_math(pi)} should give
\texttt{"\textbackslash{}\textbackslash{}pi"}, not \texttt{"pi"}),
\texttt{symbol\_env} needs to be the parent of \texttt{greek\_env}. To
do that, we need to make a copy of \texttt{greek\_env} with a new
parent. While R doesn't come with a function for cloning environments,
we can easily create one by combining two existing functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{clone_env <-}\StringTok{ }\NormalTok{function(env, }\DataTypeTok{parent =} \KeywordTok{parent.env}\NormalTok{(env)) \{}
  \KeywordTok{list2env}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(env), }\DataTypeTok{parent =} \NormalTok{parent)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This gives us a function that can convert both known (Greek) and unknown
symbols.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\NormalTok{function(expr) \{}
  \CommentTok{# Unknown symbols}
  \NormalTok{names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
  \NormalTok{symbol_list <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(names), names)}
  \NormalTok{symbol_env <-}\StringTok{ }\KeywordTok{list2env}\NormalTok{(symbol_list)}

  \CommentTok{# Known symbols}
  \KeywordTok{clone_env}\NormalTok{(greek_env, symbol_env)}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(x)}
\CommentTok{#> [1] "x"}
\KeywordTok{to_math}\NormalTok{(longvariablename)}
\CommentTok{#> [1] "longvariablename"}
\KeywordTok{to_math}\NormalTok{(pi)}
\CommentTok{#> [1] "\textbackslash{}\textbackslash{}pi"}
\end{Highlighting}
\end{Shaded}

\subsection{Known functions}

Next we'll add functions to our DSL. We'll start with a couple of helper
closures that make it easy to add new unary and binary operators. These
functions are very simple: they only assemble strings. (Again we use
\texttt{force()} to make sure the arguments are evaluated at the right
time.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unary_op <-}\StringTok{ }\NormalTok{function(left, right) \{}
  \KeywordTok{force}\NormalTok{(left)}
  \KeywordTok{force}\NormalTok{(right)}
  \NormalTok{function(e1) \{}
    \KeywordTok{paste0}\NormalTok{(left, e1, right)}
  \NormalTok{\}}
\NormalTok{\}}

\NormalTok{binary_op <-}\StringTok{ }\NormalTok{function(sep) \{}
  \KeywordTok{force}\NormalTok{(sep)}
  \NormalTok{function(e1, e2) \{}
    \KeywordTok{paste0}\NormalTok{(e1, sep, e2)}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Using these helpers, we can map a few illustrative examples of
converting R to LaTeX. Note that with R's lexical scoping rules helping
us, we can easily provide new meanings for standard functions like
\texttt{+}, \texttt{-}, and \texttt{*}, and even \texttt{(} and
\texttt{\{}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Binary operators}
\NormalTok{f_env <-}\StringTok{ }\KeywordTok{new.env}\NormalTok{(}\DataTypeTok{parent =} \KeywordTok{emptyenv}\NormalTok{())}
\NormalTok{f_env$}\StringTok{"+"} \NormalTok{<-}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" + "}\NormalTok{)}
\NormalTok{f_env$}\StringTok{"-"} \NormalTok{<-}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" - "}\NormalTok{)}
\NormalTok{f_env$}\StringTok{"*"} \NormalTok{<-}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" * "}\NormalTok{)}
\NormalTok{f_env$}\StringTok{"/"} \NormalTok{<-}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{" / "}\NormalTok{)}
\NormalTok{f_env$}\StringTok{"^"} \NormalTok{<-}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{"^"}\NormalTok{)}
\NormalTok{f_env$}\StringTok{"["} \NormalTok{<-}\StringTok{ }\KeywordTok{binary_op}\NormalTok{(}\StringTok{"_"}\NormalTok{)}

\CommentTok{# Grouping}
\NormalTok{f_env$}\StringTok{"\{"} \NormalTok{<-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left\{ "}\NormalTok{, }\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right\}"}\NormalTok{)}
\NormalTok{f_env$}\StringTok{"("} \NormalTok{<-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left( "}\NormalTok{, }\StringTok{" }\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right)"}\NormalTok{)}
\NormalTok{f_env$paste <-}\StringTok{ }\NormalTok{paste}

\CommentTok{# Other math functions}
\NormalTok{f_env$sqrt <-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sqrt\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{)}
\NormalTok{f_env$sin <-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{sin("}\NormalTok{, }\StringTok{")"}\NormalTok{)}
\NormalTok{f_env$log <-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{log("}\NormalTok{, }\StringTok{")"}\NormalTok{)}
\NormalTok{f_env$abs <-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{left| "}\NormalTok{, }\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{right| "}\NormalTok{)}
\NormalTok{f_env$frac <-}\StringTok{ }\NormalTok{function(a, b) \{}
  \KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{frac\{"}\NormalTok{, a, }\StringTok{"\}\{"}\NormalTok{, b, }\StringTok{"\}"}\NormalTok{)}
\NormalTok{\}}

\CommentTok{# Labelling}
\NormalTok{f_env$hat <-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{hat\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{)}
\NormalTok{f_env$tilde <-}\StringTok{ }\KeywordTok{unary_op}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{tilde\{"}\NormalTok{, }\StringTok{"\}"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We again modify \texttt{latex\_env()} to include this environment. It
should be the last environment R looks for names in: in other words,
\texttt{sin(sin)} should work.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\NormalTok{function(expr) \{}
  \CommentTok{# Known functions}
  \NormalTok{f_env}

  \CommentTok{# Default symbols}
  \NormalTok{names <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
  \NormalTok{symbol_list <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(names), names)}
  \NormalTok{symbol_env <-}\StringTok{ }\KeywordTok{list2env}\NormalTok{(symbol_list, }\DataTypeTok{parent =} \NormalTok{f_env)}

  \CommentTok{# Known symbols}
  \NormalTok{greek_env <-}\StringTok{ }\KeywordTok{clone_env}\NormalTok{(greek_env, }\DataTypeTok{parent =} \NormalTok{symbol_env)}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(x +}\StringTok{ }\NormalTok{pi))}
\CommentTok{#> [1] "\textbackslash{}\textbackslash{}sin(x + \textbackslash{}\textbackslash{}pi)"}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{log}\NormalTok{(x_i ^}\StringTok{ }\DecValTok{2}\NormalTok{))}
\CommentTok{#> [1] "\textbackslash{}\textbackslash{}log(x_i^2)"}
\KeywordTok{to_math}\NormalTok{(}\KeywordTok{sin}\NormalTok{(sin))}
\CommentTok{#> [1] "\textbackslash{}\textbackslash{}sin(sin)"}
\end{Highlighting}
\end{Shaded}

\subsection{Unknown functions}

Finally, we'll add a default for functions that we don't yet know about.
Like the unknown names, we can't know in advance what these will be, so
we again use a little metaprogramming to figure them out:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{all_calls <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (}\KeywordTok{is.atomic}\NormalTok{(x) ||}\StringTok{ }\KeywordTok{is.name}\NormalTok{(x)) \{}
    \KeywordTok{character}\NormalTok{()}
  \NormalTok{\} else if (}\KeywordTok{is.call}\NormalTok{(x)) \{}
    \NormalTok{fname <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(x[[}\DecValTok{1}\NormalTok{]])}
    \NormalTok{children <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(x[-}\DecValTok{1}\NormalTok{], all_calls)}
    \KeywordTok{unique}\NormalTok{(}\KeywordTok{c}\NormalTok{(fname, }\KeywordTok{unlist}\NormalTok{(children)))}
  \NormalTok{\} else if (}\KeywordTok{is.pairlist}\NormalTok{(x)) \{}
    \KeywordTok{unique}\NormalTok{(}\KeywordTok{unlist}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(x[-}\DecValTok{1}\NormalTok{], all_calls), }\DataTypeTok{use.names =} \OtherTok{FALSE}\NormalTok{))}
  \NormalTok{\} else \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"Don't know how to handle type "}\NormalTok{, }\KeywordTok{typeof}\NormalTok{(x), }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{all_calls}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{f}\NormalTok{(g +}\StringTok{ }\NormalTok{b, c, }\KeywordTok{d}\NormalTok{(a))))}
\CommentTok{#> [1] "f" "+" "d"}
\end{Highlighting}
\end{Shaded}

And we need a closure that will generate the functions for each unknown
call.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{unknown_op <-}\StringTok{ }\NormalTok{function(op) \{}
  \KeywordTok{force}\NormalTok{(op)}
  \NormalTok{function(...) \{}
    \NormalTok{contents <-}\StringTok{ }\KeywordTok{paste}\NormalTok{(..., }\DataTypeTok{collapse =} \StringTok{", "}\NormalTok{)}
    \KeywordTok{paste0}\NormalTok{(}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{mathrm\{"}\NormalTok{, op, }\StringTok{"\}("}\NormalTok{, contents, }\StringTok{")"}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And again we update \texttt{latex\_env()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{latex_env <-}\StringTok{ }\NormalTok{function(expr) \{}
  \NormalTok{calls <-}\StringTok{ }\KeywordTok{all_calls}\NormalTok{(expr)}
  \NormalTok{call_list <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{lapply}\NormalTok{(calls, unknown_op), calls)}
  \NormalTok{call_env <-}\StringTok{ }\KeywordTok{list2env}\NormalTok{(call_list)}

  \CommentTok{# Known functions}
  \NormalTok{f_env <-}\StringTok{ }\KeywordTok{clone_env}\NormalTok{(f_env, call_env)}

  \CommentTok{# Default symbols}
  \NormalTok{symbols <-}\StringTok{ }\KeywordTok{all_names}\NormalTok{(expr)}
  \NormalTok{symbol_list <-}\StringTok{ }\KeywordTok{setNames}\NormalTok{(}\KeywordTok{as.list}\NormalTok{(symbols), symbols)}
  \NormalTok{symbol_env <-}\StringTok{ }\KeywordTok{list2env}\NormalTok{(symbol_list, }\DataTypeTok{parent =} \NormalTok{f_env)}

  \CommentTok{# Known symbols}
  \NormalTok{greek_env <-}\StringTok{ }\KeywordTok{clone_env}\NormalTok{(greek_env, }\DataTypeTok{parent =} \NormalTok{symbol_env)}
\NormalTok{\}}

\KeywordTok{to_math}\NormalTok{(}\KeywordTok{f}\NormalTok{(a *}\StringTok{ }\NormalTok{b))}
\CommentTok{#> [1] "\textbackslash{}\textbackslash{}mathrm\{f\}(a * b)"}
\end{Highlighting}
\end{Shaded}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Add escaping. The special symbols that should be escaped by adding a
  backslash in front of them are \texttt{\textbackslash{}}, \texttt{\$},
  and \texttt{\%}. Just as with HTML, you'll need to make sure you don't
  end up double-escaping. So you'll need to create a small S3 class and
  then use that in function operators. That will also allow you to embed
  arbitrary LaTeX if needed.
\item
  Complete the DSL to support all the functions that \texttt{plotmath}
  supports.
\item
  There's a repeating pattern in \texttt{latex\_env()}: we take a
  character vector, do something to each piece, convert it to a list,
  and then convert the list to an environment. Write a function that
  automates this task, and then rewrite \texttt{latex\_env()}.
\item
  Study the source code for \texttt{dplyr}. An important part of its
  structure is \texttt{partial\_eval()} which helps manage expressions
  when some of the components refer to variables in the database while
  others refer to local R objects. Note that you could use very similar
  ideas if you needed to translate small R expressions into other
  languages, like JavaScript or Python.
\end{enumerate}
