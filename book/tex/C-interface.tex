\chapter{R's C interface}\label{c-api}

Reading R's source code is an extremely powerful technique for improving
your programming skills. However, many base R functions, and many
functions in older packages, are written in C. It's useful to be able to
figure out how those functions work, so this chapter will introduce you
to R's C API. You'll need some basic C knowledge, which you can get from
a standard C text (e.g.,
\href{http://amzn.com/0131101633?tag=devtools-20}{\emph{The C
Programming Language}} by Kernigan and Ritchie), or from
\hyperref[rcpp]{Rcpp}. You'll need a little patience, but it is possible
to read R's C source code, and you will learn a lot doing it. \index{C}

The contents of this chapter draw heavily from Section 5 (``System and
foreign language interfaces'') of
\href{http://cran.r-project.org/doc/manuals/R-exts.html}{Writing R
extensions}, but focus on best practices and modern tools. This means it
does not cover the old \texttt{.C} interface, the old API defined in
\texttt{Rdefines.h}, or rarely used language features. To see R's
complete C API, look at the header file \texttt{Rinternals.h}. It's
easiest to find and display this file from within R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{rinternals <-}\StringTok{ }\KeywordTok{file.path}\NormalTok{(}\KeywordTok{R.home}\NormalTok{(}\StringTok{"include"}\NormalTok{), }\StringTok{"Rinternals.h"}\NormalTok{)}
\KeywordTok{file.show}\NormalTok{(rinternals)}
\end{Highlighting}
\end{Shaded}

All functions are defined with either the prefix \texttt{Rf\_} or
\texttt{R\_} but are exported without it (unless
\texttt{\#define R\_NO\_REMAP} has been used).

I do not recommend using C for writing new high-performance code.
Instead write C++ with Rcpp. The Rcpp API protects you from many of the
historical idiosyncracies of the R API, takes care of memory management
for you, and provides many useful helper methods.

\paragraph{Outline}

\begin{itemize}
\item
  \hyperref[calling-c]{Calling C} shows the basics of creating and
  calling C functions with the inline package.
\item
  \hyperref[c-data-structures]{C data structures} shows how to translate
  data structure names from R to C.
\item
  \hyperref[c-vectors]{Creating and modifying vectors} teaches you how
  to create, modify, and coerce vectors in C.
\item
  \hyperref[c-pairlists]{Pairlists} shows you how to work with
  pairlists. You need to know this because the distinction between
  pairlists and list is more important in C than R.
\item
  \hyperref[c-input-validation]{Input validation} talks about the
  importance of input validation so that your C function doesn't crash
  R.
\item
  \hyperref[c-find-source]{Finding the C source for a function}
  concludes the chapter by showing you how to find the C source code for
  internal and primitive R functions.
\end{itemize}

\paragraph{Prerequisites}

To understand existing C code, it's useful to generate simple examples
of your own that you can experiment with. To that end, all examples in
this chapter use the \texttt{inline} package, which makes it extremely
easy to compile and link C code to your current R session. Get it by
running \texttt{install.packages("inline")}. To easily find the C code
associated with internal and primitive functions, you'll need a function
from pryr. Get the package with \texttt{install.packages("pryr")}.

You'll also need a C compiler. Windows users can use
\href{http://cran.r-project.org/bin/windows/Rtools/}{Rtools}. Mac users
will need the \href{http://developer.apple.com/}{Xcode command line
tools}. Most Linux distributions will come with the necessary compilers.

In Windows, it's necessary that the Rtools executables directory
(typically \texttt{C:\textbackslash{}Rtools\textbackslash{}bin}) and the
C compiler executables directory (typically
\texttt{C:\textbackslash{}Rtools\textbackslash{}gcc-4.6.3\textbackslash{}bin})
are included in the Windows \texttt{PATH} environment variable. You may
need to reboot Windows before R can recognise these values.

\hyperdef{}{calling-c}{\section{Calling C functions from
R}\label{calling-c}}

Generally, calling a C function from R requires two pieces: a C function
and an R wrapper function that uses \texttt{.Call()}. The simple
function below adds two numbers together and illustrates some of the
complexities of coding in C:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// In C ----------------------------------------}
\OtherTok{#include <R.h>}
\OtherTok{#include <Rinternals.h>}

\NormalTok{SEXP add(SEXP a, SEXP b) \{}
  \NormalTok{SEXP result = PROTECT(allocVector(REALSXP, }\DecValTok{1}\NormalTok{));}
  \NormalTok{REAL(result)[}\DecValTok{0}\NormalTok{] = asReal(a) + asReal(b);}
  \NormalTok{UNPROTECT(}\DecValTok{1}\NormalTok{);}

  \KeywordTok{return} \NormalTok{result;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# In R ----------------------------------------}
\NormalTok{add <-}\StringTok{ }\NormalTok{function(a, b) \{}
  \KeywordTok{.Call}\NormalTok{(}\StringTok{"add"}\NormalTok{, a, b)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(An alternative to using \texttt{.Call} is to use \texttt{.External}. It
is used almost identically, except that the C function will receive a
single argument containing a \texttt{LISTSXP}, a pairlist from which the
arguments can be extracted. This makes it possible to write functions
that take a variable number of arguments. However, it's not commonly
used in base R and \texttt{inline} does not currently support
\texttt{.External} functions so I don't discuss it further in this
chapter.) \indexc{.Call()} \indexc{.External()}

In this chapter we'll produce the two pieces in one step by using the
\texttt{inline} package. This allows us to write: \indexc{cfunction()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \StringTok{"integer"}\NormalTok{, }\DataTypeTok{b =} \StringTok{"integer"}\NormalTok{), }\StringTok{"}
\StringTok{  SEXP result = PROTECT(allocVector(REALSXP, 1));}
\StringTok{  REAL(result)[0] = asReal(a) + asReal(b);}
\StringTok{  UNPROTECT(1);}

\StringTok{  return result;}
\StringTok{"}\NormalTok{)}
\KeywordTok{add}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\CommentTok{#> [1] 6}
\end{Highlighting}
\end{Shaded}

Before we begin reading and writing C code, we need to know a little
about the basic data structures.

\hyperdef{}{c-data-structures}{\section{C data
structures}\label{c-data-structures}}

At the C-level, all R objects are stored in a common datatype, the
\texttt{SEXP}, or S-expression. All R objects are S-expressions so every
C function that you create must return a \texttt{SEXP} as output and
take \texttt{SEXP}s as inputs. (Technically, this is a pointer to a
structure with typedef \texttt{SEXPREC}.) A \texttt{SEXP} is a variant
type, with subtypes for all R's data structures. The most important
types are: \indexc{SEXP}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{REALSXP}: numeric vector
\item
  \texttt{INTSXP}: integer vector
\item
  \texttt{LGLSXP}: logical vector
\item
  \texttt{STRSXP}: character vector
\item
  \texttt{VECSXP}: list
\item
  \texttt{CLOSXP}: function (closure)
\item
  \texttt{ENVSXP}: environment
\end{itemize}

\textbf{Beware:} In C, lists are called \texttt{VECSXP}s not
\texttt{LISTSXP}s. This is because early implementations of lists were
Lisp-like linked lists, which are now known as ``pairlists''.

Character vectors are a little more complicated than the other atomic
vectors. A \texttt{STRSXP}s contains a vector of \texttt{CHARSXP}s,
where each \texttt{CHARSXP} points to C-style string stored in a global
pool. This design allows individual \texttt{CHARSXP}'s to be shared
between multiple character vectors, reducing memory usage. See
\hyperref[object-size]{object size} for more details.

There are also \texttt{SEXP}s for less common object types:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{CPLXSXP}: complex vectors
\item
  \texttt{LISTSXP}: ``pair'' lists. At the R level, you only need to
  care about the distinction lists and pairlists for function arguments,
  but internally they are used in many more places
\item
  \texttt{DOTSXP}: `\ldots{}'
\item
  \texttt{SYMSXP}: names/symbols
\item
  \texttt{NILSXP}: \texttt{NULL}
\end{itemize}

And \texttt{SEXP}s for internal objects, objects that are usually only
created and used by C functions, not R functions:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{LANGSXP}: language constructs
\item
  \texttt{CHARSXP}: ``scalar'' strings
\item
  \texttt{PROMSXP}: promises, lazily evaluated function arguments
\item
  \texttt{EXPRSXP}: expressions
\end{itemize}

There's no built-in R function to easily access these names, but pryr
provides \texttt{sexp\_type()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(pryr)}

\KeywordTok{sexp_type}\NormalTok{(10L)}
\CommentTok{#> [1] "INTSXP"}
\KeywordTok{sexp_type}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
\CommentTok{#> [1] "STRSXP"}
\KeywordTok{sexp_type}\NormalTok{(T)}
\CommentTok{#> [1] "LGLSXP"}
\KeywordTok{sexp_type}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] "VECSXP"}
\KeywordTok{sexp_type}\NormalTok{(}\KeywordTok{pairlist}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> [1] "LISTSXP"}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{c-vectors}{\section{Creating and modifying
vectors}\label{c-vectors}}

At the heart of every C function are conversions between R data
structures and C data structures. Inputs and output will always be R
data structures (\texttt{SEXP}s) and you will need to convert them to C
data structures in order to do any work. This section focusses on
vectors because they're the type of object you're most likely to work
with.

An additional complication is the garbage collector: if you don't
protect every R object you create, the garbage collector will think they
are unused and delete them.

\subsection{Creating vectors and garbage collection}

The simplest way to create a new R-level object is to use
\texttt{allocVector()}. It takes two arguments, the type of
\texttt{SEXP} (or \texttt{SEXPTYPE}) to create, and the length of the
vector. The following code creates a three element list containing a
logical vector, a numeric vector, and an integer vector, all of length
four: \indexc{PROTECT()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dummy <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\DataTypeTok{body =} \StringTok{'}
\StringTok{  SEXP dbls = PROTECT(allocVector(REALSXP, 4));}
\StringTok{  SEXP lgls = PROTECT(allocVector(LGLSXP, 4));}
\StringTok{  SEXP ints = PROTECT(allocVector(INTSXP, 4));}

\StringTok{  SEXP vec = PROTECT(allocVector(VECSXP, 3));}
\StringTok{  SET_VECTOR_ELT(vec, 0, dbls);}
\StringTok{  SET_VECTOR_ELT(vec, 1, lgls);}
\StringTok{  SET_VECTOR_ELT(vec, 2, ints);}

\StringTok{  UNPROTECT(4);}
\StringTok{  return vec;}
\StringTok{'}\NormalTok{)}
\KeywordTok{dummy}\NormalTok{()}
\CommentTok{#> [[1]]}
\CommentTok{#> [1] 6.95e-310 6.95e-310 6.95e-310  0.00e+00}
\CommentTok{#> }
\CommentTok{#> [[2]]}
\CommentTok{#> [1] TRUE TRUE TRUE TRUE}
\CommentTok{#> }
\CommentTok{#> [[3]]}
\CommentTok{#> [1] -738103480      32751 -738104536      32751}
\end{Highlighting}
\end{Shaded}

You might wonder what all the \texttt{PROTECT()} calls do. They tell R
that the object is in use and shouldn't be deleted if the garbage
collector is activated. (We don't need to protect objects that R already
knows we're using, like function arguments.)

You also need to make sure that every protected object is unprotected.
\texttt{UNPROTECT()} takes a single integer argument, \texttt{n}, and
unprotects the last n objects that were protected. The number of
protects and unprotects must match. If not, R will warn about a ``stack
imbalance in .Call''. Other specialised forms of protection are needed
in some circumstances:

\begin{itemize}
\item
  \texttt{UNPROTECT\_PTR()} unprotects the object pointed to by the
  \texttt{SEXP}s.
\item
  \texttt{PROTECT\_WITH\_INDEX()} saves an index of the protection
  location that can be used to replace the protected value using
  \texttt{REPROTECT()}.
\end{itemize}

Consult the R externals section on
\href{http://cran.r-project.org/doc/manuals/R-exts.html\#Garbage-Collection}{garbage
collection} for more details.

Properly protecting the R objects you allocate is extremely important!
Improper protection leads to difficulty diagnosing errors, typically
segfaults, but other corruption is possible as well. In general, if you
allocate a new R object, you must \texttt{PROTECT} it.

If you run \texttt{dummy()} a few times, you'll notice the output
varies. This is because \texttt{allocVector()} assigns memory to each
output, but it doesn't clean it out first. For real functions, you may
want to loop through each element in the vector and set it to a
constant. The most efficient way to do that is to use \texttt{memset()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{zeroes <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{n_ =} \StringTok{"integer"}\NormalTok{), }\StringTok{'}
\StringTok{  int n = asInteger(n_);}

\StringTok{  SEXP out = PROTECT(allocVector(INTSXP, n));}
\StringTok{  memset(INTEGER(out), 0, n * sizeof(int));}
\StringTok{  UNPROTECT(1);}

\StringTok{  return out;}
\StringTok{'}\NormalTok{)}
\KeywordTok{zeroes}\NormalTok{(}\DecValTok{10}\NormalTok{);}
\CommentTok{#>  [1] 0 0 0 0 0 0 0 0 0 0}
\end{Highlighting}
\end{Shaded}

\subsection{Missing and non-finite values}

Each atomic vector has a special constant for getting or setting missing
values:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{INTSXP}: \texttt{NA\_INTEGER}
\item
  \texttt{LGLSXP}: \texttt{NA\_LOGICAL}
\item
  \texttt{STRSXP}: \texttt{NA\_STRING}
\end{itemize}

Missing values are somewhat more complicated for \texttt{REALSXP}
because there is an existing protocol for missing values defined by the
floating point standard
(\href{http://en.wikipedia.org/wiki/IEEE_floating_point}{IEEE 754}). In
doubles, an \texttt{NA} is \texttt{NaN} with a special bit pattern (the
lowest word is 1954, the year Ross Ihaka was born), and there are other
special values for positive and negative infinity. Use \texttt{ISNA()},
\texttt{ISNAN()}, and \texttt{!R\_FINITE()} macros to check for missing,
NaN, or non-finite values. Use the constants \texttt{NA\_REAL},
\texttt{R\_NaN}, \texttt{R\_PosInf}, and \texttt{R\_NegInf} to set those
values. \index{missing values!in C}

We can use this knowledge to make a simple version of \texttt{is.NA()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_na <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"ANY"}\NormalTok{), }\StringTok{'}
\StringTok{  int n = length(x);}

\StringTok{  SEXP out = PROTECT(allocVector(LGLSXP, n));}

\StringTok{  for (int i = 0; i < n; i++) \{}
\StringTok{    switch(TYPEOF(x)) \{}
\StringTok{      case LGLSXP:}
\StringTok{        LOGICAL(out)[i] = (LOGICAL(x)[i] == NA_LOGICAL);}
\StringTok{        break;}
\StringTok{      case INTSXP:}
\StringTok{        LOGICAL(out)[i] = (INTEGER(x)[i] == NA_INTEGER);}
\StringTok{        break;}
\StringTok{      case REALSXP:}
\StringTok{        LOGICAL(out)[i] = ISNA(REAL(x)[i]);}
\StringTok{        break;}
\StringTok{      case STRSXP:}
\StringTok{        LOGICAL(out)[i] = (STRING_ELT(x, i) == NA_STRING);}
\StringTok{        break;}
\StringTok{      default:}
\StringTok{        LOGICAL(out)[i] = NA_LOGICAL;}
\StringTok{    \}}
\StringTok{  \}}
\StringTok{  UNPROTECT(1);}

\StringTok{  return out;}
\StringTok{'}\NormalTok{)}
\KeywordTok{is_na}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, 1L))}
\CommentTok{#> [1]  TRUE FALSE}
\KeywordTok{is_na}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{1}\NormalTok{))}
\CommentTok{#> [1]  TRUE FALSE}
\KeywordTok{is_na}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\StringTok{"a"}\NormalTok{))}
\CommentTok{#> [1]  TRUE FALSE}
\KeywordTok{is_na}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> [1]  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

Note that \texttt{base::is.na()} returns \texttt{TRUE} for both
\texttt{NA} and \texttt{NaN}s in a numeric vector, as opposed to the C
\texttt{ISNA()} macro, which returns \texttt{TRUE} only for
\texttt{NA\_REAL}s.

\subsection{Accessing vector data}

There is a helper function for each atomic vector that allows you to
access the C array which stores the data in a vector. Use
\texttt{REAL()}, \texttt{INTEGER()}, \texttt{LOGICAL()},
\texttt{COMPLEX()}, and \texttt{RAW()} to access the C array inside
numeric, integer, logical, complex, and raw vectors. The following
example shows how to use \texttt{REAL()} to inspect and modify a numeric
vector: \index{vectors!in C}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_one <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"numeric"}\NormalTok{), }\StringTok{"}
\StringTok{  int n = length(x);}
\StringTok{  SEXP out = PROTECT(allocVector(REALSXP, n));}
\StringTok{  }
\StringTok{  for (int i = 0; i < n; i++) \{}
\StringTok{    REAL(out)[i] = REAL(x)[i] + 1;}
\StringTok{  \}}
\StringTok{  UNPROTECT(1);}

\StringTok{  return out;}
\StringTok{"}\NormalTok{)}
\KeywordTok{add_one}\NormalTok{(}\KeywordTok{as.numeric}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{))}
\CommentTok{#>  [1]  2  3  4  5  6  7  8  9 10 11}
\end{Highlighting}
\end{Shaded}

When working with longer vectors, there's a performance advantage to
using the helper function once and saving the result in a pointer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_two <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"numeric"}\NormalTok{), }\StringTok{"}
\StringTok{  int n = length(x);}
\StringTok{  double *px, *pout;}

\StringTok{  SEXP out = PROTECT(allocVector(REALSXP, n));}

\StringTok{  px = REAL(x);}
\StringTok{  pout = REAL(out);}
\StringTok{  for (int i = 0; i < n; i++) \{}
\StringTok{    pout[i] = px[i] + 2;}
\StringTok{  \}}
\StringTok{  UNPROTECT(1);}

\StringTok{  return out;}
\StringTok{"}\NormalTok{)}
\KeywordTok{add_two}\NormalTok{(}\KeywordTok{as.numeric}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{))}
\CommentTok{#>  [1]  3  4  5  6  7  8  9 10 11 12}

\NormalTok{x <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(}\DecValTok{1}\NormalTok{:}\FloatTok{1e6}\NormalTok{)}
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{add_one}\NormalTok{(x),}
  \KeywordTok{add_two}\NormalTok{(x)}
\NormalTok{)}
\CommentTok{#> Unit: milliseconds}
\CommentTok{#>        expr  min   lq median   uq  max neval}
\CommentTok{#>  add_one(x) 5.03 5.45   6.17 7.77 38.4   100}
\CommentTok{#>  add_two(x) 1.20 1.46   2.15 3.74 36.7   100}
\end{Highlighting}
\end{Shaded}

On my computer, \texttt{add\_two()} is about twice as fast as
\texttt{add\_one()} for a million element vector. This is a common idiom
in base R.

\subsection{Character vectors and lists}

Strings and lists are more complicated because the individual elements
of a vector are \texttt{SEXP}s, not basic C data structures. Each
element of a \texttt{STRSXP} is a \texttt{CHARSXP}s, an immutable object
that contains a pointer to C string stored in a global pool. Use
\texttt{STRING\_ELT(x, i)} to extract the \texttt{CHARSXP}, and
\texttt{CHAR(STRING\_ELT(x, i))} to get the actual \texttt{const char*}
string. Set values with \texttt{SET\_STRING\_ELT(x, i, value)}. Use
\texttt{mkChar()} to turn a C string into a \texttt{CHARSXP} and
\texttt{mkString()} to turn a C string into a \texttt{STRSXP}. Use
\texttt{mkChar()} to create strings to insert in an existing vector, use
\texttt{mkString()} to create a new (length 1) vector.

The following function shows how to make a character vector containing
known strings:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{abc <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\OtherTok{NULL}\NormalTok{, }\StringTok{'}
\StringTok{  SEXP out = PROTECT(allocVector(STRSXP, 3));}

\StringTok{  SET_STRING_ELT(out, 0, mkChar("a"));}
\StringTok{  SET_STRING_ELT(out, 1, mkChar("b"));}
\StringTok{  SET_STRING_ELT(out, 2, mkChar("c"));}

\StringTok{  UNPROTECT(1);}

\StringTok{  return out;}
\StringTok{'}\NormalTok{)}
\KeywordTok{abc}\NormalTok{()}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

Things are a little harder if you want to modify the strings in the
vector because you need to know a lot about string manipulation in C
(which is hard, and harder to do right). For any problem that involves
any kind of string modification, you're better off using Rcpp.

The elements of a list can be any other \texttt{SEXP}, which generally
makes them hard to work with in C (you'll need lots of \texttt{switch}
statements to deal with the possibilities). The accessor functions for
lists are \texttt{VECTOR\_ELT(x, i)} and
\texttt{SET\_VECTOR\_ELT(x, i, value)}.

\subsection{Modifying inputs}

You must be very careful when modifying function inputs. The following
function has some rather unexpected behaviour:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_three <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"numeric"}\NormalTok{), }\StringTok{'}
\StringTok{  REAL(x)[0] = REAL(x)[0] + 3;}
\StringTok{  return x;}
\StringTok{'}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{y <-}\StringTok{ }\NormalTok{x}
\KeywordTok{add_three}\NormalTok{(x)}
\CommentTok{#> [1] 4}
\NormalTok{x}
\CommentTok{#> [1] 4}
\NormalTok{y}
\CommentTok{#> [1] 4}
\end{Highlighting}
\end{Shaded}

Not only has it modified the value of \texttt{x}, it has also modified
\texttt{y}! This happens because of R's lazy copy-on-modify semantics.
To avoid problems like this, always \texttt{duplicate()} inputs before
modifying them:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_four <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"numeric"}\NormalTok{), }\StringTok{'}
\StringTok{  SEXP x_copy = PROTECT(duplicate(x));}
\StringTok{  REAL(x_copy)[0] = REAL(x_copy)[0] + 4;}
\StringTok{  UNPROTECT(1);}
\StringTok{  return x_copy;}
\StringTok{'}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{y <-}\StringTok{ }\NormalTok{x}
\KeywordTok{add_four}\NormalTok{(x)}
\CommentTok{#> [1] 5}
\NormalTok{x}
\CommentTok{#> [1] 1}
\NormalTok{y}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

If you're working with lists, use \texttt{shallow\_duplicate()} to make
a shallow copy; \texttt{duplicate()} will also copy every element in the
list.

\subsection{Coercing scalars}

There are a few helper functions that turn length one R vectors into C
scalars:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{asLogical(x): LGLSXP -\textgreater{} int}
\item
  \texttt{asInteger(x): INTSXP -\textgreater{} int}
\item
  \texttt{asReal(x): REALSXP -\textgreater{} double}
\item
  \texttt{CHAR(asChar(x)): STRSXP -\textgreater{} const char*}
\end{itemize}

And helpers to go in the opposite direction:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{ScalarLogical(x): int -\textgreater{} LGLSXP}
\item
  \texttt{ScalarInteger(x): int -\textgreater{} INTSXP}
\item
  \texttt{ScalarReal(x): double -\textgreater{} REALSXP}
\item
  \texttt{mkString(x): const char* -\textgreater{} STRSXP}
\end{itemize}

These all create R-level objects, so they need to be
\texttt{PROTECT()}ed.

\subsection{Long vectors}

As of R 3.0.0, R vectors can have length greater than \(2 ^ 31 - 1\).
This means that vector lengths can no longer be reliably stored in an
\texttt{int} and if you want your code to work with long vectors, you
can't write code like \texttt{int n = length(x)}. Instead use the
\texttt{R\_xlen\_t} type and the \texttt{xlength()} function, and write
\texttt{R\_xlen\_t n = xlength(x)}. \index{long vectors!in C}

\hyperdef{}{c-pairlists}{\section{Pairlists}\label{c-pairlists}}

In R code, there are only a few instances when you need to care about
the difference between a pairlist and a list (as described in
\hyperref[pairlists]{Pairlists}). In C, pairlists play much more
important role because they are used for calls, unevaluated arguments,
attributes, and in \texttt{...}. In C, lists and pairlists differ
primarily in how you access and name elements. \index{pairlists}

Unlike lists (\texttt{VECSXP}s), pairlists (\texttt{LISTSXP}s) have no
way to index into an arbitrary location. Instead, R provides a set of
helper functions that navigate along a linked list. The basic helpers
are \texttt{CAR()}, which extracts the first element of the list, and
\texttt{CDR()}, which extracts the rest of the list. These can be
composed to get \texttt{CAAR()}, \texttt{CDAR()}, \texttt{CADDR()},
\texttt{CADDDR()}, and so on. Corresponding to the getters, R provides
setters \texttt{SETCAR()}, \texttt{SETCDR()}, etc.

The following example shows how \texttt{CAR()} and \texttt{CDR()} can
pull out pieces of a quoted function call:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{car <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"ANY"}\NormalTok{), }\StringTok{'return CAR(x);'}\NormalTok{)}
\NormalTok{cdr <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"ANY"}\NormalTok{), }\StringTok{'return CDR(x);'}\NormalTok{)}
\NormalTok{cadr <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"ANY"}\NormalTok{), }\StringTok{'return CADR(x);'}\NormalTok{)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{quote}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{))}
\CommentTok{# The first element}
\KeywordTok{car}\NormalTok{(x)}
\CommentTok{#> f}
\CommentTok{# Second and third elements}
\KeywordTok{cdr}\NormalTok{(x)}
\CommentTok{#> $a}
\CommentTok{#> [1] 1}
\CommentTok{#> }
\CommentTok{#> $b}
\CommentTok{#> [1] 2}
\CommentTok{# Second element}
\KeywordTok{car}\NormalTok{(}\KeywordTok{cdr}\NormalTok{(x))}
\CommentTok{#> [1] 1}
\KeywordTok{cadr}\NormalTok{(x)}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

Pairlists are always terminated with \texttt{R\_NilValue}. To loop over
all elements of a pairlist, use this template:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{count <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{x =} \StringTok{"ANY"}\NormalTok{), }\StringTok{'}
\StringTok{  SEXP el, nxt;}
\StringTok{  int i = 0;}

\StringTok{  for(nxt = x; nxt != R_NilValue; el = CAR(nxt), nxt = CDR(nxt)) \{}
\StringTok{    i++;}
\StringTok{  \}}
\StringTok{  return ScalarInteger(i);}
\StringTok{'}\NormalTok{)}
\KeywordTok{count}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{f}\NormalTok{(a, b, c)))}
\CommentTok{#> [1] 4}
\KeywordTok{count}\NormalTok{(}\KeywordTok{quote}\NormalTok{(}\KeywordTok{f}\NormalTok{()))}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

You can make new pairlists with \texttt{CONS()} and new calls with
\texttt{LCONS()}. Remember to set the last value to
\texttt{R\_NilValue}. Since these are R objects as well, they are
eligible for garbage collection and must be \texttt{PROTECT}ed. In fact,
it is unsafe to write code like the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_call <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\OtherTok{NULL}\NormalTok{, }\StringTok{'}
\StringTok{  return LCONS(install("+"), LCONS(}
\StringTok{    ScalarReal(10), LCONS(}
\StringTok{      ScalarReal(5), R_NilValue}
\StringTok{    )}
\StringTok{  ));}
\StringTok{'}\NormalTok{)}
\KeywordTok{gctorture}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{new_call}\NormalTok{()}
\CommentTok{#> 5 + 5}
\KeywordTok{gctorture}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

On my machine, I get the result \texttt{5 + 5} --- highly unexpected! In
fact, to be safe, we must \texttt{PROTECT} each \texttt{ScalarReal} that
is generated, as every R object allocation can trigger the garbage
collector.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_call <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\OtherTok{NULL}\NormalTok{, }\StringTok{'}
\StringTok{  SEXP REALSXP_10 = PROTECT(ScalarReal(10));}
\StringTok{  SEXP REALSXP_5 = PROTECT(ScalarReal(5));}
\StringTok{  SEXP out = PROTECT(LCONS(install("+"), LCONS(}
\StringTok{    REALSXP_10, LCONS(}
\StringTok{      REALSXP_5, R_NilValue}
\StringTok{    )}
\StringTok{  )));}
\StringTok{  UNPROTECT(3);}
\StringTok{  return out;}
\StringTok{'}\NormalTok{)}
\KeywordTok{gctorture}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{new_call}\NormalTok{()}
\CommentTok{#> 10 + 5}
\KeywordTok{gctorture}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\texttt{TAG()} and \texttt{SET\_TAG()} allow you to get and set the tag
(aka name) associated with an element of a pairlist. The tag should be a
symbol. To create a symbol (the equivalent of \texttt{as.symbol()} in
R), use \texttt{install()}.

Attributes are also pairlists, but come with the helper functions
\texttt{setAttrib()} and \texttt{getAttrib()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{set_attr <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{obj =} \StringTok{"SEXP"}\NormalTok{, }\DataTypeTok{attr =} \StringTok{"SEXP"}\NormalTok{, }\DataTypeTok{value =} \StringTok{"SEXP"}\NormalTok{), }\StringTok{'}
\StringTok{  const char* attr_s = CHAR(asChar(attr));}

\StringTok{  duplicate(obj);}
\StringTok{  setAttrib(obj, install(attr_s), value);}
\StringTok{  return obj;}
\StringTok{'}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{10}
\KeywordTok{set_attr}\NormalTok{(x, }\StringTok{"a"}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\CommentTok{#>  [1]  1  2  3  4  5  6  7  8  9 10}
\CommentTok{#> attr(,"a")}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

(Note that \texttt{setAttrib()} and \texttt{getAttrib()} must do a
linear search over the attributes pairlist.)

There are some (confusingly named) shortcuts for common setting
operations: \texttt{classgets()}, \texttt{namesgets()},
\texttt{dimgets()}, and \texttt{dimnamesgets()} are the internal
versions of the default methods of \texttt{class\textless{}-},
\texttt{names\textless{}-}, \texttt{dim\textless{}-}, and
\texttt{dimnames\textless{}-}.

\hyperdef{}{c-input-validation}{\section{Input
validation}\label{c-input-validation}}

If the user provides unexpected input to your function (e.g., a list
instead of a numeric vector), it's very easy to crash R. For this
reason, it's a good idea to write a wrapper function that checks
arguments are of the correct type. It's usually easier to do this at the
R level. For example, going back to our first example of C code, we
might rename the C function to \texttt{add\_} and write a wrapper around
it to check that the inputs are ok:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add_ <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{signature}\NormalTok{(}\DataTypeTok{a =} \StringTok{"integer"}\NormalTok{, }\DataTypeTok{b =} \StringTok{"integer"}\NormalTok{), }\StringTok{"}
\StringTok{  SEXP result = PROTECT(allocVector(REALSXP, 1));}
\StringTok{  REAL(result)[0] = asReal(a) + asReal(b);}
\StringTok{  UNPROTECT(1);}

\StringTok{  return result;}
\StringTok{"}\NormalTok{)}
\NormalTok{add <-}\StringTok{ }\NormalTok{function(a, b) \{}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{is.numeric}\NormalTok{(a), }\KeywordTok{is.numeric}\NormalTok{(b))}
  \KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{length}\NormalTok{(a) ==}\StringTok{ }\DecValTok{1}\NormalTok{, }\KeywordTok{length}\NormalTok{(b) ==}\StringTok{ }\DecValTok{1}\NormalTok{)}
  \KeywordTok{add_}\NormalTok{(a, b)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Alternatively, if we wanted to be more accepting of diverse inputs we
could do the following:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\NormalTok{function(a, b) \{}
  \NormalTok{a <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(a)}
  \NormalTok{b <-}\StringTok{ }\KeywordTok{as.numeric}\NormalTok{(b)}

  \NormalTok{if (}\KeywordTok{length}\NormalTok{(a) >}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{warning}\NormalTok{(}\StringTok{"Only first element of a used"}\NormalTok{)}
  \NormalTok{if (}\KeywordTok{length}\NormalTok{(b) >}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{warning}\NormalTok{(}\StringTok{"Only first element of b used"}\NormalTok{)}
  
  \KeywordTok{add_}\NormalTok{(a, b)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To coerce objects at the C level, use
\texttt{PROTECT(new = coerceVector(old, SEXPTYPE))}. This will return an
error if the \texttt{SEXP} can not be converted to the desired type.

To check if an object is of a specified type, you can use
\texttt{TYPEOF}, which returns a \texttt{SEXPTYPE}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{is_numeric <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"x"} \NormalTok{=}\StringTok{ "ANY"}\NormalTok{), }\StringTok{"}
\StringTok{  return ScalarLogical(TYPEOF(x) == REALSXP);}
\StringTok{"}\NormalTok{)}
\KeywordTok{is_numeric}\NormalTok{(}\DecValTok{7}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{is_numeric}\NormalTok{(}\StringTok{"a"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

There are also a number of helper functions which return 0 for FALSE and
1 for TRUE:

\begin{itemize}
\item
  For atomic vectors: \texttt{isInteger()}, \texttt{isReal()},
  \texttt{isComplex()}, \texttt{isLogical()}, \texttt{isString()}.
\item
  For combinations of atomic vectors: \texttt{isNumeric()} (integer,
  logical, real), \texttt{isNumber()} (integer, logical, real, complex),
  \texttt{isVectorAtomic()} (logical, integer, numeric, complex, string,
  raw).
\item
  For matrices (\texttt{isMatrix()}) and arrays (\texttt{isArray()}).
\item
  For more esoteric objects: \texttt{isEnvironment()},
  \texttt{isExpression()}, \texttt{isList()} (a pair list),
  \texttt{isNewList()} (a list), \texttt{isSymbol()}, \texttt{isNull()},
  \texttt{isObject()} (S4 objects), \texttt{isVector()} (atomic vectors,
  lists, expressions).
\end{itemize}

Note that some of these functions behave differently to similarly named
R functions with similar names. For example \texttt{isVector()} is true
for atomic vectors, lists, and expressions, where \texttt{is.vector()}
returns \texttt{TRUE} only if its input has no attributes apart from
names.

\hyperdef{}{c-find-source}{\section{Finding the C source code for a
function}\label{c-find-source}}

In the base package, R doesn't use \texttt{.Call()}. Instead, it uses
two special functions: \texttt{.Internal()} and \texttt{.Primitive()}.
Finding the source code for these functions is an arduous task: you
first need to look for their C function name in
\texttt{src/main/names.c} and then search the R source code.
\texttt{pryr::show\_c\_source()} automates this task using GitHub code
search: \indexc{.Internal()} \index{primitive functions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabulate}
\CommentTok{#> function (bin, nbins = max(1L, bin, na.rm = TRUE)) }
\CommentTok{#> \{}
\CommentTok{#>     if (!is.numeric(bin) && !is.factor(bin)) }
\CommentTok{#>         stop("'bin' must be numeric or a factor")}
\CommentTok{#>     if (typeof(bin) != "integer") }
\CommentTok{#>         bin <- as.integer(bin)}
\CommentTok{#>     if (nbins > .Machine$integer.max) }
\CommentTok{#>         stop("attempt to make a table with >= 2^31 elements")}
\CommentTok{#>     nbins <- as.integer(nbins)}
\CommentTok{#>     if (is.na(nbins)) }
\CommentTok{#>         stop("invalid value of 'nbins'")}
\CommentTok{#>     .Internal(tabulate(bin, nbins))}
\CommentTok{#> \}}
\CommentTok{#> <bytecode: 0x7fcd3c2a2838>}
\CommentTok{#> <environment: namespace:base>}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pryr::}\KeywordTok{show_c_source}\NormalTok{(}\KeywordTok{.Internal}\NormalTok{(}\KeywordTok{tabulate}\NormalTok{(bin, nbins)))}
\CommentTok{#> tabulate is implemented by do_tabulate with op = 0}
\end{Highlighting}
\end{Shaded}

This reveals the following C source code (slightly edited for clarity):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{SEXP attribute_hidden do_tabulate(SEXP call, SEXP op, SEXP args, }
                                  \NormalTok{SEXP rho) \{}
  \NormalTok{checkArity(op, args);}
  \NormalTok{SEXP in = CAR(args), nbin = CADR(args);}
  \KeywordTok{if} \NormalTok{(TYPEOF(in) != INTSXP)  error(}\StringTok{"invalid input"}\NormalTok{);}

  \NormalTok{R_xlen_t n = XLENGTH(in);}
  \CommentTok{/* FIXME: could in principle be a long vector */}
  \DataTypeTok{int} \NormalTok{nb = asInteger(nbin);}
  \KeywordTok{if} \NormalTok{(nb == NA_INTEGER || nb < }\DecValTok{0}\NormalTok{)}
    \NormalTok{error(_(}\StringTok{"invalid '%s' argument"}\NormalTok{), }\StringTok{"nbin"}\NormalTok{);}
  
  \NormalTok{SEXP ans = allocVector(INTSXP, nb);}
  \DataTypeTok{int} \NormalTok{*x = INTEGER(in), *y = INTEGER(ans);}
  \NormalTok{memset(y, }\DecValTok{0}\NormalTok{, nb * }\KeywordTok{sizeof}\NormalTok{(}\DataTypeTok{int}\NormalTok{));}
  \KeywordTok{for}\NormalTok{(R_xlen_t i = }\DecValTok{0} \NormalTok{; i < n ; i++) \{}
    \KeywordTok{if} \NormalTok{(x[i] != NA_INTEGER && x[i] > }\DecValTok{0} \NormalTok{&& x[i] <= nb) \{}
      \NormalTok{y[x[i] - }\DecValTok{1}\NormalTok{]++;}
    \NormalTok{\}}
  \NormalTok{\}}
     
  \KeywordTok{return} \NormalTok{ans;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Internal and primitive functions have a somewhat different interface
than \texttt{.Call()} functions. They always have four arguments:

\begin{itemize}
\item
  \texttt{SEXP call}: the complete call to the function.
  \texttt{CAR(call)} gives the name of the function (as a symbol);
  \texttt{CDR(call)} gives the arguments.
\item
  \texttt{SEXP op}: an ``offset pointer''. This is used when multiple R
  functions use the same C function. For example \texttt{do\_logic()}
  implements \texttt{\&}, \texttt{\textbar{}}, and \texttt{!}.
  \texttt{show\_c\_source()} prints this out for you.
\item
  \texttt{SEXP args}: a pairlist containing the unevaluated arguments to
  the function.
\item
  \texttt{SEXP rho}: the environment in which the call was executed.
\end{itemize}

This gives internal functions an incredible amount of flexibility as to
how and when the arguments are evaluated. For example, internal S3
generics call \texttt{DispatchOrEval()} which either calls the
appropriate S3 method or evaluates all the arguments in place. This
flexibility come at a price, because it makes the code harder to
understand. However, evaluating the arguments is usually the first step
and the rest of the function is straightforward.

The following code shows \texttt{do\_tabulate()} converted into standard
a \texttt{.Call()} interface:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabulate2 <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{bin =} \StringTok{"SEXP"}\NormalTok{, }\DataTypeTok{nbins =} \StringTok{"SEXP"}\NormalTok{), }\StringTok{'}
\StringTok{  if (TYPEOF(bin) != INTSXP)  error("invalid input");}
\StringTok{  }
\StringTok{  R_xlen_t n = XLENGTH(bin);}
\StringTok{  /* FIXME: could in principle be a long vector */}
\StringTok{  int nb = asInteger(nbins);}
\StringTok{  if (nb == NA_INTEGER || nb < 0)}
\StringTok{    error("invalid }\CharTok{\textbackslash{}'}\StringTok{%s}\CharTok{\textbackslash{}'}\StringTok{ argument", "nbin");}

\StringTok{  SEXP ans = allocVector(INTSXP, nb);}
\StringTok{  int *x = INTEGER(bin), *y = INTEGER(ans);}
\StringTok{  memset(y, 0, nb * sizeof(int));}
\StringTok{  for(R_xlen_t i = 0 ; i < n ; i++) \{}
\StringTok{    if (x[i] != NA_INTEGER && x[i] > 0 && x[i] <= nb) \{}
\StringTok{      y[x[i] - 1]++;}
\StringTok{    \}}
\StringTok{  \}}
\StringTok{     }
\StringTok{  return ans;}
\StringTok{'}\NormalTok{)}
\KeywordTok{tabulate2}\NormalTok{(}\KeywordTok{c}\NormalTok{(1L, 1L, 1L, 2L, 2L), }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 3 2 0}
\end{Highlighting}
\end{Shaded}

To get this to compile, I also removed the call to \texttt{\_()} which
is an internal R function used to translate error messages between
different languages.

The final version below moves more of the coercion logic into an
accompanying R function, and does some minor restructuring to make the
code a little easier to understand. I also added a \texttt{PROTECT()};
this is probably missing in the original because the author knew that it
would be safe.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tabulate_ <-}\StringTok{ }\KeywordTok{cfunction}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DataTypeTok{bin =} \StringTok{"SEXP"}\NormalTok{, }\DataTypeTok{nbins =} \StringTok{"SEXP"}\NormalTok{), }\StringTok{'  }
\StringTok{  int nb = asInteger(nbins);}

\StringTok{  // Allocate vector for output - assumes that there are }
\StringTok{  // less than 2^32 bins, and that each bin has less than }
\StringTok{  // 2^32 elements in it.}
\StringTok{  SEXP out = PROTECT(allocVector(INTSXP, nb));}
\StringTok{  int *pbin = INTEGER(bin), *pout = INTEGER(out);}
\StringTok{  memset(pout, 0, nb * sizeof(int));}

\StringTok{  R_xlen_t n = xlength(bin);}
\StringTok{  for(R_xlen_t i = 0; i < n; i++) \{}
\StringTok{    int val = pbin[i];}
\StringTok{    if (val != NA_INTEGER && val > 0 && val <= nb) \{}
\StringTok{      pout[val - 1]++; // C is zero-indexed}
\StringTok{    \}}
\StringTok{  \}}
\StringTok{  UNPROTECT(1);   }
\StringTok{  }
\StringTok{  return out;}
\StringTok{'}\NormalTok{)}

\NormalTok{tabulate3 <-}\StringTok{ }\NormalTok{function(bin, nbins) \{}
  \NormalTok{bin <-}\StringTok{ }\KeywordTok{as.integer}\NormalTok{(bin)}
  \NormalTok{if (}\KeywordTok{length}\NormalTok{(nbins) !=}\StringTok{ }\DecValTok{1} \NormalTok{||}\StringTok{ }\NormalTok{nbins <=}\StringTok{ }\DecValTok{0} \NormalTok{||}\StringTok{ }\KeywordTok{is.na}\NormalTok{(nbins)) \{}
    \KeywordTok{stop}\NormalTok{(}\StringTok{"nbins must be a positive integer"}\NormalTok{, }\DataTypeTok{call. =} \OtherTok{FALSE}\NormalTok{)}
  \NormalTok{\}}
  \KeywordTok{tabulate_}\NormalTok{(bin, nbins)}
\NormalTok{\}}
\KeywordTok{tabulate3}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{2}\NormalTok{), }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 3 2 0}
\end{Highlighting}
\end{Shaded}

