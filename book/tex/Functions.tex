\chapter{Functions}

Functions are a fundamental building block of R: to master many of the
more advanced techniques in this book, you need a solid foundation in
how functions work. You've probably already created many R functions,
and you're familiar with the basics of how they work. The focus of this
chapter is to turn your existing, informal knowledge of functions into a
rigorous understanding of what functions are and how they work. You'll
see some interesting tricks and techniques in this chapter, but most of
what you'll learn will be more important as the building blocks for more
advanced techniques. \index{functions}

The most important thing to understand about R is that functions are
objects in their own right. You can work with them exactly the same way
you work with any other type of object. This theme will be explored in
depth in \hyperref[functional-programming]{functional programming}.

\paragraph{Quiz}

Answer the following questions to see if you can safely skip this
chapter. You can find the answers at the end of the chapter in
\hyperref[function-answers]{answers}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What are the three components of a function?
\item
  What does the following code return?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{y <-}\StringTok{ }\DecValTok{10}
\NormalTok{f1 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{function() \{}
    \NormalTok{x +}\StringTok{ }\DecValTok{10}
  \NormalTok{\}}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{(}\DecValTok{1}\NormalTok{)()}
\end{Highlighting}
\end{Shaded}
\item
  How would you more typically write this code?

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{1}\NormalTok{, }\StringTok{`}\DataTypeTok{*}\StringTok{`}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  How could you make this call easier to read?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(, }\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  Does the following function throw an error when called? Why/why not?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\NormalTok{function(a, b) \{}
  \NormalTok{a *}\StringTok{ }\DecValTok{10}
\NormalTok{\}}
\KeywordTok{f2}\NormalTok{(}\DecValTok{10}\NormalTok{, }\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  What is an infix function? How do you write it? What's a replacement
  function? How do you write it?
\item
  What function do you use to ensure that a cleanup action occurs
  regardless of how a function terminates?
\end{enumerate}

\paragraph{Outline}

\begin{itemize}
\item
  \hyperref[function-components]{Function components} describes the
  three main components of a function.
\item
  \hyperref[lexical-scoping]{Lexical scoping} teaches you how R finds
  values from names, the process of lexical scoping.
\item
  \hyperref[all-calls]{Every operation in a function call} shows you
  that everything that happens in R is a result of a function call, even
  if it doesn't look like it.
\item
  \hyperref[function-arguments]{Function arguments} discusses the three
  ways of supplying arguments to a function, how to call a function
  given a list of arguments, and the impact of lazy evaluation.
\item
  \hyperref[special-calls]{Special calls} describes two special types of
  function: infix and replacement functions.
\item
  \hyperref[return-values]{Return values} discusses how and when
  functions return values, and how you can ensure that a function does
  something before it exits.
\end{itemize}

\paragraph{Prerequisites}

The only package you'll need is \texttt{pryr}, which is used to explore
what happens when modifying vectors in place. Install it with
\texttt{install.packages("pryr")}.

\hyperdef{}{function-components}{\section{Function
components}\label{function-components}}

All R functions have three parts: \index{functions!body}
\index{functions!formals} \index{functions!environment}

\begin{itemize}
\item
  the \texttt{body()}, the code inside the function.
\item
  the \texttt{formals()}, the list of arguments which controls how you
  can call the function.
\item
  the \texttt{environment()}, the ``map'' of the location of the
  function's variables.
\end{itemize}

When you print a function in R, it shows you these three important
components. If the environment isn't displayed, it means that the
function was created in the global environment. \indexc{formals()}
\indexc{body()} \index{environments!of a function}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) x^}\DecValTok{2}
\NormalTok{f}
\CommentTok{#> function(x) x^2}

\KeywordTok{formals}\NormalTok{(f)}
\CommentTok{#> $x}
\KeywordTok{body}\NormalTok{(f)}
\CommentTok{#> x^2}
\KeywordTok{environment}\NormalTok{(f)}
\CommentTok{#> <environment: R_GlobalEnv>}
\end{Highlighting}
\end{Shaded}

The assignment forms of \texttt{body()}, \texttt{formals()}, and
\texttt{environment()} can also be used to modify functions.

Like all objects in R, functions can also possess any number of
additional \texttt{attributes()}. One attribute used by base R is
``srcref'', short for source reference, which points to the source code
used to create the function. Unlike \texttt{body()}, this contains code
comments and other formatting. You can also add attributes to a
function. For example, you can set the \texttt{class()} and add a custom
\texttt{print()} method. \index{functions!attributes}

\subsection{Primitive functions}

There is one exception to the rule that functions have three components.
Primitive functions, like \texttt{sum()}, call C code directly with
\texttt{.Primitive()} and contain no R code. Therefore their
\texttt{formals()}, \texttt{body()}, and \texttt{environment()} are all
\texttt{NULL}: \index{primitive functions}
\index{functions!primitive|see{primitive functions}}
\index{.Primitive@\texttt{.Primitive()}|see{Primitive functions}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sum}
\CommentTok{#> function (..., na.rm = FALSE)  .Primitive("sum")}
\KeywordTok{formals}\NormalTok{(sum)}
\CommentTok{#> NULL}
\KeywordTok{body}\NormalTok{(sum)}
\CommentTok{#> NULL}
\KeywordTok{environment}\NormalTok{(sum)}
\CommentTok{#> NULL}
\end{Highlighting}
\end{Shaded}

Primitive functions are only found in the \texttt{base} package, and
since they operate at a low level, they can be more efficient (primitive
replacement functions don't have to make copies), and can have different
rules for argument matching (e.g., \texttt{switch} and \texttt{call}).
This, however, comes at a cost of behaving differently from all other
functions in R. Hence the R core team generally avoids creating them
unless there is no other option.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What function allows you to tell if an object is a function? What
  function allows you to tell if a function is a primitive function?
\item
  This code makes a list of all functions in the base package.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{objs <-}\StringTok{ }\KeywordTok{mget}\NormalTok{(}\KeywordTok{ls}\NormalTok{(}\StringTok{"package:base"}\NormalTok{), }\DataTypeTok{inherits =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{funs <-}\StringTok{ }\KeywordTok{Filter}\NormalTok{(is.function, objs)}
\end{Highlighting}
\end{Shaded}

  Use it to answer the following questions:

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Which base function has the most arguments?
  \item
    How many base functions have no arguments? What's special about
    those functions?
  \item
    How could you adapt the code to find all primitive functions?
  \end{enumerate}
\item
  What are the three important components of a function?
\item
  When does printing a function not show what environment it was created
  in?
\end{enumerate}

\hyperdef{}{lexical-scoping}{\section{Lexical
scoping}\label{lexical-scoping}}

Scoping is the set of rules that govern how R looks up the value of a
symbol. In the example below, scoping is the set of rules that R applies
to go from the symbol \texttt{x} to its value \texttt{10}:
\index{scoping!lexical|see{lexical scoping}} \index{lexical scoping}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}
\NormalTok{x}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

Understanding scoping allows you to:

\begin{itemize}
\item
  build tools by composing functions, as described in
  \hyperref[functional-programming]{functional programming}.
\item
  overrule the usual evaluation rules and do non-standard evaluation, as
  described in \hyperref[nse]{non-standard evaluation}.
\end{itemize}

R has two types of scoping: \textbf{lexical scoping}, implemented
automatically at the language level, and \textbf{dynamic scoping}, used
in select functions to save typing during interactive analysis. We
discuss lexical scoping here because it is intimately tied to function
creation. Dynamic scoping is described in more detail in
\hyperref[scoping-issues]{scoping issues}.

Lexical scoping looks up symbol values based on how functions were
nested when they were created, not how they are nested when they are
called. With lexical scoping, you don't need to know how the function is
called to figure out where the value of a variable will be looked up.
You just need to look at the function's definition.

The ``lexical'' in lexical scoping doesn't correspond to the usual
English definition (``of or relating to words or the vocabulary of a
language as distinguished from its grammar and construction'') but comes
from the computer science term ``lexing'', which is part of the process
that converts code represented as text to meaningful pieces that the
programming language understands.

There are four basic principles behind R's implementation of lexical
scoping:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  name masking
\item
  functions vs.~variables
\item
  a fresh start
\item
  dynamic lookup
\end{itemize}

You probably know many of these principles already, although you might
not have thought about them explicitly. Test your knowledge by mentally
running through the code in each block before looking at the answers.

\subsection{Name masking}

The following example illustrates the most basic principle of lexical
scoping, and you should have no problem predicting the output.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{x <-}\StringTok{ }\DecValTok{1}
  \NormalTok{y <-}\StringTok{ }\DecValTok{2}
  \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\KeywordTok{rm}\NormalTok{(f)}
\end{Highlighting}
\end{Shaded}

If a name isn't defined inside a function, R will look one level up.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{2}
\NormalTok{g <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{y <-}\StringTok{ }\DecValTok{1}
  \KeywordTok{c}\NormalTok{(x, y)}
\NormalTok{\}}
\KeywordTok{g}\NormalTok{()}
\KeywordTok{rm}\NormalTok{(x, g)}
\end{Highlighting}
\end{Shaded}

The same rules apply if a function is defined inside another function:
look inside the current function, then where that function was defined,
and so on, all the way up to the global environment, and then on to
other loaded packages. Run the following code in your head, then confirm
the output by running the R code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}
\NormalTok{h <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{y <-}\StringTok{ }\DecValTok{2}
  \NormalTok{i <-}\StringTok{ }\NormalTok{function() \{}
    \NormalTok{z <-}\StringTok{ }\DecValTok{3}
    \KeywordTok{c}\NormalTok{(x, y, z)}
  \NormalTok{\}}
  \KeywordTok{i}\NormalTok{()}
\NormalTok{\}}
\KeywordTok{h}\NormalTok{()}
\KeywordTok{rm}\NormalTok{(x, h)}
\end{Highlighting}
\end{Shaded}

The same rules apply to closures, functions created by other functions.
Closures will be described in more detail in
\hyperref[functional-programming]{functional programming}; here we'll
just look at how they interact with scoping. The following function,
\texttt{j()}, returns a function. What do you think this function will
return when we call it? \index{closures!scoping}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{y <-}\StringTok{ }\DecValTok{2}
  \NormalTok{function() \{}
    \KeywordTok{c}\NormalTok{(x, y)}
  \NormalTok{\}}
\NormalTok{\}}
\NormalTok{k <-}\StringTok{ }\KeywordTok{j}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\KeywordTok{k}\NormalTok{()}
\KeywordTok{rm}\NormalTok{(j, k)}
\end{Highlighting}
\end{Shaded}

This seems a little magical (how does R know what the value of
\texttt{y} is after the function has been called). It works because
\texttt{k} preserves the environment in which it was defined and because
the environment includes the value of \texttt{y}.
\hyperref[environments]{Environments} gives some pointers on how you can
dive in and figure out what values are stored in the environment
associated with each function.

\subsection{Functions vs.~variables}

The same principles apply regardless of the type of associated value ---
finding functions works exactly the same way as finding variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{l <-}\StringTok{ }\NormalTok{function(x) x +}\StringTok{ }\DecValTok{1}
\NormalTok{m <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{l <-}\StringTok{ }\NormalTok{function(x) x *}\StringTok{ }\DecValTok{2}
  \KeywordTok{l}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\NormalTok{\}}
\KeywordTok{m}\NormalTok{()}
\CommentTok{#> [1] 20}
\KeywordTok{rm}\NormalTok{(l, m)}
\end{Highlighting}
\end{Shaded}

For functions, there is one small tweak to the rule. If you are using a
name in a context where it's obvious that you want a function (e.g.,
\texttt{f(3)}), R will ignore objects that are not functions while it is
searching. In the following example \texttt{n} takes on a different
value depending on whether R is looking for a function or a variable.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\NormalTok{function(x) x /}\StringTok{ }\DecValTok{2}
\NormalTok{o <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{n <-}\StringTok{ }\DecValTok{10}
  \KeywordTok{n}\NormalTok{(n)}
\NormalTok{\}}
\KeywordTok{o}\NormalTok{()}
\CommentTok{#> [1] 5}
\KeywordTok{rm}\NormalTok{(n, o)}
\end{Highlighting}
\end{Shaded}

However, using the same name for functions and other objects will make
for confusing code, and is generally best avoided.

\subsection{A fresh start}\label{fresh-start}

What happens to the values in between invocations of a function? What
will happen the first time you run this function? What will happen the
second time? (If you haven't seen \texttt{exists()} before: it returns
\texttt{TRUE} if there's a variable of that name, otherwise it returns
\texttt{FALSE}.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{if (!}\KeywordTok{exists}\NormalTok{(}\StringTok{"a"}\NormalTok{)) \{}
    \NormalTok{a <-}\StringTok{ }\DecValTok{1}
  \NormalTok{\} else \{}
    \NormalTok{a <-}\StringTok{ }\NormalTok{a +}\StringTok{ }\DecValTok{1}
  \NormalTok{\}}
  \KeywordTok{print}\NormalTok{(a)}
\NormalTok{\}}
\KeywordTok{j}\NormalTok{()}
\KeywordTok{rm}\NormalTok{(j)}
\end{Highlighting}
\end{Shaded}

You might be surprised that it returns the same value, \texttt{1}, every
time. This is because every time a function is called, a new environment
is created to host execution. A function has no way to tell what
happened the last time it was run; each invocation is completely
independent. (We'll see some ways to get around this in
\hyperref[mutable-state]{mutable state}.)

\subsection{Dynamic lookup}

Lexical scoping determines where to look for values, not when to look
for them. R looks for values when the function is run, not when it's
created. This means that the output of a function can be different
depending on objects outside its environment:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function() x}
\NormalTok{x <-}\StringTok{ }\DecValTok{15}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> [1] 15}

\NormalTok{x <-}\StringTok{ }\DecValTok{20}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

You generally want to avoid this behaviour because it means the function
is no longer self-contained. This is a common error --- if you make a
spelling mistake in your code, you won't get an error when you create
the function, and you might not even get one when you run the function,
depending on what variables are defined in the global environment.

One way to detect this problem is the \texttt{findGlobals()} function
from \texttt{codetools}. This function lists all the external
dependencies of a function: \indexc{findGlobals()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function() x +}\StringTok{ }\DecValTok{1}
\NormalTok{codetools::}\KeywordTok{findGlobals}\NormalTok{(f)}
\CommentTok{#> [1] "+" "x"}
\end{Highlighting}
\end{Shaded}

Another way to try and solve the problem would be to manually change the
environment of the function to the \texttt{emptyenv()}, an environment
which contains absolutely nothing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{environment}\NormalTok{(f) <-}\StringTok{ }\KeywordTok{emptyenv}\NormalTok{()}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> Error: could not find function "+"}
\end{Highlighting}
\end{Shaded}

This doesn't work because R relies on lexical scoping to find
\emph{everything}, even the \texttt{+} operator. It's never possible to
make a function completely self-contained because you must always rely
on functions defined in base R or other packages.

You can use this same idea to do other things that are extremely
ill-advised. For example, since all of the standard operators in R are
functions, you can override them with your own alternatives. If you ever
are feeling particularly evil, run the following code while your friend
is away from their computer:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{(}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(e1) \{}
  \NormalTok{if (}\KeywordTok{is.numeric}\NormalTok{(e1) &&}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{1}\NormalTok{) <}\StringTok{ }\FloatTok{0.1}\NormalTok{) \{}
    \NormalTok{e1 +}\StringTok{ }\DecValTok{1}
  \NormalTok{\} else \{}
    \NormalTok{e1}
  \NormalTok{\}}
\NormalTok{\}}
\KeywordTok{replicate}\NormalTok{(}\DecValTok{50}\NormalTok{, (}\DecValTok{1} \NormalTok{+}\StringTok{ }\DecValTok{2}\NormalTok{))}
\CommentTok{#>  [1] 3 3 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 4 3 3 3 4 3}
\CommentTok{#> [30] 3 3 3 3 3 4 3 3 4 3 3 3 3 3 3 3 3 3 3 3 3}
\KeywordTok{rm}\NormalTok{(}\StringTok{"("}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This will introduce a particularly pernicious bug: 10\% of the time, 1
will be added to any numeric calculation inside parentheses. This is
another good reason to regularly restart with a clean R session!

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  What does the following code return? Why? What does each of the three
  \texttt{c}'s mean?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c <-}\StringTok{ }\DecValTok{10}
\KeywordTok{c}\NormalTok{(}\DataTypeTok{c =} \NormalTok{c)}
\end{Highlighting}
\end{Shaded}
\item
  What are the four principles that govern how R looks for values?
\item
  What does the following function return? Make a prediction before
  running the code yourself.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{f <-}\StringTok{ }\NormalTok{function(x) \{}
    \NormalTok{f <-}\StringTok{ }\NormalTok{function(x) \{}
      \NormalTok{x ^}\StringTok{ }\DecValTok{2}
    \NormalTok{\}}
    \KeywordTok{f}\NormalTok{(x) +}\StringTok{ }\DecValTok{1}
  \NormalTok{\}}
  \KeywordTok{f}\NormalTok{(x) *}\StringTok{ }\DecValTok{2}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hyperdef{}{all-calls}{\section{Every operation is a function
call}\label{all-calls}}

\begin{quote}
``To understand computations in R, two slogans are helpful:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Everything that exists is an object.
\item
  Everything that happens is a function call."
\end{itemize}

--- John Chambers
\end{quote}

The previous example of redefining \texttt{(} works because every
operation in R is a function call, whether or not it looks like one.
This includes infix operators like \texttt{+}, control flow operators
like \texttt{for}, \texttt{if}, and \texttt{while}, subsetting operators
like \texttt{{[}{]}} and \texttt{\$}, and even the curly brace
\texttt{\{}. This means that each pair of statements in the following
example is exactly equivalent. Note that \texttt{`}, the backtick, lets
you refer to functions or variables that have otherwise reserved or
illegal names: \index{reserved names} \indexc{`}
\index{backticks|see{\texttt{`}}}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10}\NormalTok{; y <-}\StringTok{ }\DecValTok{5}
\NormalTok{x +}\StringTok{ }\NormalTok{y}
\CommentTok{#> [1] 15}
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(x, y)}
\CommentTok{#> [1] 15}

\NormalTok{for (i in }\DecValTok{1}\NormalTok{:}\DecValTok{2}\NormalTok{) }\KeywordTok{print}\NormalTok{(i)}
\CommentTok{#> [1] 1}
\CommentTok{#> [1] 2}
\StringTok{`}\DataTypeTok{for}\StringTok{`}\NormalTok{(i, }\DecValTok{1}\NormalTok{:}\DecValTok{2}\NormalTok{, }\KeywordTok{print}\NormalTok{(i))}
\CommentTok{#> [1] 1}
\CommentTok{#> [1] 2}

\NormalTok{if (i ==}\StringTok{ }\DecValTok{1}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"yes!"}\NormalTok{) else }\KeywordTok{print}\NormalTok{(}\StringTok{"no."}\NormalTok{)}
\CommentTok{#> [1] "no."}
\StringTok{`}\DataTypeTok{if}\StringTok{`}\NormalTok{(i ==}\StringTok{ }\DecValTok{1}\NormalTok{, }\KeywordTok{print}\NormalTok{(}\StringTok{"yes!"}\NormalTok{), }\KeywordTok{print}\NormalTok{(}\StringTok{"no."}\NormalTok{))}
\CommentTok{#> [1] "no."}

\NormalTok{x[}\DecValTok{3}\NormalTok{]}
\CommentTok{#> [1] NA}
\StringTok{`}\DataTypeTok{[}\StringTok{`}\NormalTok{(x, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] NA}

\NormalTok{\{ }\KeywordTok{print}\NormalTok{(}\DecValTok{1}\NormalTok{); }\KeywordTok{print}\NormalTok{(}\DecValTok{2}\NormalTok{); }\KeywordTok{print}\NormalTok{(}\DecValTok{3}\NormalTok{) \}}
\CommentTok{#> [1] 1}
\CommentTok{#> [1] 2}
\CommentTok{#> [1] 3}
\StringTok{`}\DataTypeTok{\{}\StringTok{`}\NormalTok{(}\KeywordTok{print}\NormalTok{(}\DecValTok{1}\NormalTok{), }\KeywordTok{print}\NormalTok{(}\DecValTok{2}\NormalTok{), }\KeywordTok{print}\NormalTok{(}\DecValTok{3}\NormalTok{))}
\CommentTok{#> [1] 1}
\CommentTok{#> [1] 2}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

It is possible to override the definitions of these special functions,
but this is almost certainly a bad idea. However, there are occasions
when it might be useful: it allows you to do something that would have
otherwise been impossible. For example, this feature makes it possible
for the \texttt{dplyr} package to translate R expressions into SQL
expressions. \hyperref[dsl]{Domain specific languages} uses this idea to
create domain specific languages that allow you to concisely express new
concepts using existing R constructs.

It's more often useful to treat special functions as ordinary functions.
For example, we could use \texttt{sapply()} to add 3 to every element of
a list by first defining a function \texttt{add()}, like this:
\indexc{sapply()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\NormalTok{function(x, y) x +}\StringTok{ }\NormalTok{y}
\KeywordTok{sapply}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, add, }\DecValTok{3}\NormalTok{)}
\CommentTok{#>  [1]  4  5  6  7  8  9 10 11 12 13}
\end{Highlighting}
\end{Shaded}

But we can also get the same effect using the built-in \texttt{+}
function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sapply}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 4 5 6 7 8}
\KeywordTok{sapply}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\StringTok{"+"}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 4 5 6 7 8}
\end{Highlighting}
\end{Shaded}

Note the difference between \texttt{`+`} and \texttt{"+"}. The first one
is the value of the object called \texttt{+}, and the second is a string
containing the character \texttt{+}. The second version works because
\texttt{lapply} can be given the name of a function instead of the
function itself: if you read the source of \texttt{lapply()}, you'll see
the first line uses \texttt{match.fun()} to find functions given their
names.

A more useful application is to combine \texttt{lapply()} or
\texttt{sapply()} with subsetting:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{:}\DecValTok{9}\NormalTok{, }\DecValTok{10}\NormalTok{:}\DecValTok{12}\NormalTok{)}
\KeywordTok{sapply}\NormalTok{(x, }\StringTok{"["}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1]  2  5 11}

\CommentTok{# equivalent to}
\KeywordTok{sapply}\NormalTok{(x, function(x) x[}\DecValTok{2}\NormalTok{])}
\CommentTok{#> [1]  2  5 11}
\end{Highlighting}
\end{Shaded}

Remembering that everything that happens in R is a function call will
help you in \hyperref[expressions]{metaprogramming}.

\hyperdef{}{function-arguments}{\section{Function
arguments}\label{function-arguments}}

It's useful to distinguish between the formal arguments and the actual
arguments of a function. The formal arguments are a property of the
function, whereas the actual or calling arguments can vary each time you
call the function. This section discusses how calling arguments are
mapped to formal arguments, how you can call a function given a list of
arguments, how default arguments work, and the impact of lazy
evaluation.

\subsection{Calling functions}

When calling a function you can specify arguments by position, by
complete name, or by partial name. Arguments are matched first by exact
name (perfect matching), then by prefix matching, and finally by
position. \index{functions!arguments}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(abcdef, bcde1, bcde2) \{}
  \KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \NormalTok{abcdef, }\DataTypeTok{b1 =} \NormalTok{bcde1, }\DataTypeTok{b2 =} \NormalTok{bcde2)}
\NormalTok{\}}
\KeywordTok{str}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{))}
\CommentTok{#> List of 3}
\CommentTok{#>  $ a : num 1}
\CommentTok{#>  $ b1: num 2}
\CommentTok{#>  $ b2: num 3}
\KeywordTok{str}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{abcdef =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> List of 3}
\CommentTok{#>  $ a : num 1}
\CommentTok{#>  $ b1: num 2}
\CommentTok{#>  $ b2: num 3}

\CommentTok{# Can abbreviate long argument names:}
\KeywordTok{str}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{a =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> List of 3}
\CommentTok{#>  $ a : num 1}
\CommentTok{#>  $ b1: num 2}
\CommentTok{#>  $ b2: num 3}

\CommentTok{# But this doesn't work because abbreviation is ambiguous}
\KeywordTok{str}\NormalTok{(}\KeywordTok{f}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DataTypeTok{b =} \DecValTok{1}\NormalTok{))}
\CommentTok{#> Error: argument 3 matches multiple formal arguments}
\end{Highlighting}
\end{Shaded}

Generally, you only want to use positional matching for the first one or
two arguments; they will be the most commonly used, and most readers
will know what they are. Avoid using positional matching for less
commonly used arguments, and only use readable abbreviations with
partial matching. (If you are writing code for a package that you want
to publish on CRAN you can not use partial matching, and must use
complete names.) Named arguments should always come after unnamed
arguments. If a function uses \texttt{...} (discussed in more detail
below), you can only specify arguments listed after \texttt{...} with
their full name.

These are good calls:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{)}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{trim =} \FloatTok{0.05}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This is probably overkill:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

And these are just confusing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{n =} \NormalTok{T)}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, , }\OtherTok{FALSE}\NormalTok{)}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\FloatTok{0.05}\NormalTok{)}
\KeywordTok{mean}\NormalTok{(, }\OtherTok{TRUE}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\subsection{Calling a function given a list of arguments}

Suppose you had a list of function arguments: \indexc{do.call()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{args <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

How could you then send that list to \texttt{mean()}? You need
\texttt{do.call()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{do.call}\NormalTok{(mean, }\KeywordTok{list}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\CommentTok{#> [1] 5.5}
\CommentTok{# Equivalent to}
\KeywordTok{mean}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] 5.5}
\end{Highlighting}
\end{Shaded}

\subsection{Default and missing arguments}

Function arguments in R can have default values.
\index{functions!default values}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{) \{}
  \KeywordTok{c}\NormalTok{(a, b)}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> [1] 1 2}
\end{Highlighting}
\end{Shaded}

Since arguments in R are evaluated lazily (more on that below), the
default value can be defined in terms of other arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{g <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \NormalTok{a *}\StringTok{ }\DecValTok{2}\NormalTok{) \{}
  \KeywordTok{c}\NormalTok{(a, b)}
\NormalTok{\}}
\KeywordTok{g}\NormalTok{()}
\CommentTok{#> [1] 1 2}
\KeywordTok{g}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 10 20}
\end{Highlighting}
\end{Shaded}

Default arguments can even be defined in terms of variables created
within the function. This is used frequently in base R functions, but I
think it is bad practice, because you can't understand what the default
values will be without reading the complete source code.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{h <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \NormalTok{d) \{}
  \NormalTok{d <-}\StringTok{ }\NormalTok{(a +}\StringTok{ }\DecValTok{1}\NormalTok{) ^}\StringTok{ }\DecValTok{2}
  \KeywordTok{c}\NormalTok{(a, b)}
\NormalTok{\}}
\KeywordTok{h}\NormalTok{()}
\CommentTok{#> [1] 1 4}
\KeywordTok{h}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1]  10 121}
\end{Highlighting}
\end{Shaded}

You can determine if an argument was supplied or not with the
\texttt{missing()} function. \indexc{missing()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i <-}\StringTok{ }\NormalTok{function(a, b) \{}
  \KeywordTok{c}\NormalTok{(}\KeywordTok{missing}\NormalTok{(a), }\KeywordTok{missing}\NormalTok{(b))}
\NormalTok{\}}
\KeywordTok{i}\NormalTok{()}
\CommentTok{#> [1] TRUE TRUE}
\KeywordTok{i}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] FALSE  TRUE}
\KeywordTok{i}\NormalTok{(}\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\CommentTok{#> [1]  TRUE FALSE}
\KeywordTok{i}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] FALSE FALSE}
\end{Highlighting}
\end{Shaded}

Sometimes you want to add a non-trivial default value, which might take
several lines of code to compute. Instead of inserting that code in the
function definition, you could use \texttt{missing()} to conditionally
compute it if needed. However, this makes it hard to know which
arguments are required and which are optional without carefully reading
the documentation. Instead, I usually set the default value to
\texttt{NULL} and use \texttt{is.null()} to check if the argument was
supplied.

\subsection{Lazy evaluation}\label{lazy-evaluation}

By default, R function arguments are lazy --- they're only evaluated if
they're actually used: \index{lazy evaluation}
\index{functions!lazy evaluation}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) \{}
  \DecValTok{10}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{))}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

If you want to ensure that an argument is evaluated you can use
\texttt{force()}: \indexc{force()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) \{}
  \KeywordTok{force}\NormalTok{(x)}
  \DecValTok{10}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\KeywordTok{stop}\NormalTok{(}\StringTok{"This is an error!"}\NormalTok{))}
\CommentTok{#> Error: This is an error!}
\end{Highlighting}
\end{Shaded}

This is important when creating closures with \texttt{lapply()} or a
loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{function(y) x +}\StringTok{ }\NormalTok{y}
\NormalTok{\}}
\NormalTok{adders <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, add)}
\NormalTok{adders[[}\DecValTok{1}\NormalTok{]](}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 20}
\NormalTok{adders[[}\DecValTok{10}\NormalTok{]](}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

\texttt{x} is lazily evaluated the first time that you call one of the
adder functions. At this point, the loop is complete and the final value
of \texttt{x} is 10. Therefore all of the adder functions will add 10 on
to their input, probably not what you wanted! Manually forcing
evaluation fixes the problem:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\NormalTok{function(x) \{}
  \KeywordTok{force}\NormalTok{(x)}
  \NormalTok{function(y) x +}\StringTok{ }\NormalTok{y}
\NormalTok{\}}
\NormalTok{adders2 <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, add)}
\NormalTok{adders2[[}\DecValTok{1}\NormalTok{]](}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 11}
\NormalTok{adders2[[}\DecValTok{10}\NormalTok{]](}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 20}
\end{Highlighting}
\end{Shaded}

This code is exactly equivalent to

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{add <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x}
  \NormalTok{function(y) x +}\StringTok{ }\NormalTok{y}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

because the force function is defined as
\texttt{force \textless{}- function(x) x}. However, using this function
clearly indicates that you're forcing evaluation, not that you've
accidentally typed \texttt{x}.

Default arguments are evaluated inside the function. This means that if
the expression depends on the current environment the results will
differ depending on whether you use the default value or explicitly
provide one.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{x =} \KeywordTok{ls}\NormalTok{()) \{}
  \NormalTok{a <-}\StringTok{ }\DecValTok{1}
  \NormalTok{x}
\NormalTok{\}}

\CommentTok{# ls() evaluated inside f:}
\KeywordTok{f}\NormalTok{()}
\CommentTok{#> [1] "a" "x"}

\CommentTok{# ls() evaluated in global environment:}
\KeywordTok{f}\NormalTok{(}\KeywordTok{ls}\NormalTok{())}
\CommentTok{#>  [1] "add"      "adders"   "adders2"  "args"     "f"       }
\CommentTok{#>  [6] "funs"     "g"        "h"        "i"        "metadata"}
\CommentTok{#> [11] "objs"     "x"        "y"}
\end{Highlighting}
\end{Shaded}

More technically, an unevaluated argument is called a \textbf{promise},
or (less commonly) a thunk. A promise is made up of two parts:
\index{promises} \index{thunks|see{promises}}

\begin{itemize}
\item
  The expression which gives rise to the delayed computation. (It can be
  accessed with \texttt{substitute()}. See \hyperref[nse]{non-standard
  evaluation} for more details.)
\item
  The environment where the expression was created and where it should
  be evaluated.
\end{itemize}

The first time a promise is accessed the expression is evaluated in the
environment where it was created. This value is cached, so that
subsequent access to the evaluated promise does not recompute the value
(but the original expression is still associated with the value, so
\texttt{substitute()} can continue to access it). You can find more
information about a promise using \texttt{pryr::promise\_info()}. This
uses some C++ code to extract information about the promise without
evaluating it, which is impossible to do in pure R code.

Laziness is useful in if statements --- the second statement below will
be evaluated only if the first is true. If it wasn't, the statement
would return an error because \texttt{NULL \textgreater{} 0} is a
logical vector of length 0 and not a valid input to \texttt{if}.
\indexc{if}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{if (!}\KeywordTok{is.null}\NormalTok{(x) &&}\StringTok{ }\NormalTok{x >}\StringTok{ }\DecValTok{0}\NormalTok{) \{}

\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We could implement ``\&\&'' ourselves:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{&&}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(x, y) \{}
  \NormalTok{if (!x) }\KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}
  \NormalTok{if (!y) }\KeywordTok{return}\NormalTok{(}\OtherTok{FALSE}\NormalTok{)}

  \OtherTok{TRUE}
\NormalTok{\}}
\NormalTok{a <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{!}\KeywordTok{is.null}\NormalTok{(a) &&}\StringTok{ }\NormalTok{a >}\StringTok{ }\DecValTok{0}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

This function would not work without lazy evaluation because both
\texttt{x} and \texttt{y} would always be evaluated, testing
\texttt{a \textgreater{} 0} even when \texttt{a} was NULL.

Sometimes you can also use laziness to eliminate an if statement
altogether. For example, instead of:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{if (}\KeywordTok{is.null}\NormalTok{(a)) }\KeywordTok{stop}\NormalTok{(}\StringTok{"a is null"}\NormalTok{)}
\CommentTok{#> Error: a is null}
\end{Highlighting}
\end{Shaded}

You could write:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{!}\KeywordTok{is.null}\NormalTok{(a) ||}\StringTok{ }\KeywordTok{stop}\NormalTok{(}\StringTok{"a is null"}\NormalTok{)}
\CommentTok{#> Error: a is null}
\end{Highlighting}
\end{Shaded}

\subsection{\texttt{...}}

There is a special argument called \texttt{...} . This argument will
match any arguments not otherwise matched, and can be easily passed on
to other functions. This is useful if you want to collect arguments to
call another function, but you don't want to prespecify their possible
names. \texttt{...} is often used in conjunction with S3 generic
functions to allow individual methods to be more flexible. \indexc{...}

One relatively sophisticated user of \texttt{...} is the base
\texttt{plot()} function. \texttt{plot()} is a generic method with
arguments \texttt{x}, \texttt{y} and \texttt{...} . To understand what
\texttt{...} does for a given function we need to read the help:
``Arguments to be passed to methods, such as graphical parameters''.
Most simple invocations of \texttt{plot()} end up calling
\texttt{plot.default()} which has many more arguments, but also has
\texttt{...} . Again, reading the documentation reveals that
\texttt{...} accepts ``other graphical parameters'', which are listed in
the help for \texttt{par()}. This allows us to write code like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{col =} \StringTok{"red"}\NormalTok{)}
\KeywordTok{plot}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{cex =} \DecValTok{5}\NormalTok{, }\DataTypeTok{pch =} \DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This illustrates both the advantages and disadvantages of \texttt{...}:
it makes \texttt{plot()} very flexible, but to understand how to use it,
we have to carefully read the documentation. Additionally, if we read
the source code for \texttt{plot.default}, we can discover undocumented
features. It's possible to pass along other arguments to \texttt{Axis()}
and \texttt{box()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{plot}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{bty =} \StringTok{"u"}\NormalTok{)}
\KeywordTok{plot}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{, }\DataTypeTok{labels =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To capture \texttt{...} in a form that is easier to work with, you can
use \texttt{list(...)}. (See \hyperref[capturing-dots]{capturing
unevaluated dots} for other ways to capture \texttt{...} without
evaluating the arguments.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(...) \{}
  \KeywordTok{names}\NormalTok{(}\KeywordTok{list}\NormalTok{(...))}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] "a" "b"}
\end{Highlighting}
\end{Shaded}

Using \texttt{...} comes at a price --- any misspelled arguments will
not raise an error, and any arguments after \texttt{...} must be fully
named. This makes it easy for typos to go unnoticed:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DataTypeTok{na.mr =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{#> [1] NA}
\end{Highlighting}
\end{Shaded}

It's often better to be explicit rather than implicit, so you might
instead ask users to supply a list of additional arguments. That's
certainly easier if you're trying to use \texttt{...} with multiple
additional functions.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Clarify the following list of odd function calls:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{, }\DecValTok{20}\NormalTok{, }\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\NormalTok{y <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DataTypeTok{min =} \DecValTok{0}\NormalTok{, }\DataTypeTok{max =} \DecValTok{1}\NormalTok{, }\DecValTok{20}\NormalTok{)}
\KeywordTok{cor}\NormalTok{(}\DataTypeTok{m =} \StringTok{"k"}\NormalTok{, }\DataTypeTok{y =} \NormalTok{y, }\DataTypeTok{u =} \StringTok{"p"}\NormalTok{, }\DataTypeTok{x =} \NormalTok{x)}
\end{Highlighting}
\end{Shaded}
\item
  What does this function return? Why? Which principle does it
  illustrate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{x =} \NormalTok{\{y <-}\StringTok{ }\DecValTok{1}\NormalTok{; }\DecValTok{2}\NormalTok{\}, }\DataTypeTok{y =} \DecValTok{0}\NormalTok{) \{}
  \NormalTok{x +}\StringTok{ }\NormalTok{y}
\NormalTok{\}}
\KeywordTok{f1}\NormalTok{()}
\end{Highlighting}
\end{Shaded}
\item
  What does this function return? Why? Which principle does it
  illustrate?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f2 <-}\StringTok{ }\NormalTok{function(}\DataTypeTok{x =} \NormalTok{z) \{}
  \NormalTok{z <-}\StringTok{ }\DecValTok{100}
  \NormalTok{x}
\NormalTok{\}}
\KeywordTok{f2}\NormalTok{()}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hyperdef{}{special-calls}{\section{Special calls}\label{special-calls}}

R supports two additional syntaxes for calling special types of
functions: infix and replacement functions.

\hyperdef{}{infix-functions}{\subsection{Infix
functions}\label{infix-functions}}

Most functions in R are ``prefix'' operators: the name of the function
comes before the arguments. You can also create infix functions where
the function name comes in between its arguments, like \texttt{+} or
\texttt{-}. All user created infix functions must start and end with
\texttt{\%} and R comes with the following infix functions predefined:
\texttt{\%\%}, \texttt{\%*\%}, \texttt{\%/\%}, \texttt{\%in\%},
\texttt{\%o\%}, \texttt{\%x\%}. (The complete list of built-in infix
operators that don't need \texttt{\%} is:
\texttt{::, :::, \$, @, \^{}, *, /, +, -, \textgreater{}, \textgreater{}=, \textless{}, \textless{}=, ==, !=, !, \&, \&\&, \textbar{}, \textbar{}\textbar{}, \textasciitilde{}, \textless{}-, \textless{}\textless{}-})
\index{functions!infix} \index{infix functions} \indexc{\%\%}

For example, we could create a new operator that pastes together
strings:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%+%}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(a, b) }\KeywordTok{paste}\NormalTok{(a, b, }\DataTypeTok{sep =} \StringTok{""}\NormalTok{)}
\StringTok{"new"} \NormalTok{%+%}\StringTok{ " string"}
\CommentTok{#> [1] "new string"}
\end{Highlighting}
\end{Shaded}

Note that when creating the function, you have to put the name in
backticks because it's a special name. This is just a syntactic sugar
for an ordinary function call; as far as R is concerned there is no
difference between these two expressions:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"new"} \NormalTok{%+%}\StringTok{ " string"}
\CommentTok{#> [1] "new string"}
\StringTok{`}\DataTypeTok{%+%}\StringTok{`}\NormalTok{(}\StringTok{"new"}\NormalTok{, }\StringTok{" string"}\NormalTok{)}
\CommentTok{#> [1] "new string"}
\end{Highlighting}
\end{Shaded}

Or indeed between \indexc{`}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{1} \NormalTok{+}\StringTok{ }\DecValTok{5}
\CommentTok{#> [1] 6}
\StringTok{`}\DataTypeTok{+}\StringTok{`}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\CommentTok{#> [1] 6}
\end{Highlighting}
\end{Shaded}

The names of infix functions are more flexible than regular R functions:
they can contain any sequence of characters (except ``\%'', of course).
You will need to escape any special characters in the string used to
define the function, but not when you call it:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{% %}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(a, b) }\KeywordTok{paste}\NormalTok{(a, b)}
\StringTok{`}\DataTypeTok{%'%}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(a, b) }\KeywordTok{paste}\NormalTok{(a, b)}
\StringTok{`}\DataTypeTok{%/}\CharTok{\textbackslash{}\textbackslash{}}\DataTypeTok{%}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(a, b) }\KeywordTok{paste}\NormalTok{(a, b)}

\StringTok{"a"} \NormalTok{% %}\StringTok{ "b"}
\CommentTok{#> [1] "a b"}
\StringTok{"a"} \NormalTok{%'%}\StringTok{ "b"}
\CommentTok{#> [1] "a b"}
\StringTok{"a"} \NormalTok{%/\textbackslash{}%}\StringTok{ "b"}
\CommentTok{#> [1] "a b"}
\end{Highlighting}
\end{Shaded}

R's default precedence rules mean that infix operators are composed from
left to right:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%-%}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(a, b) }\KeywordTok{paste0}\NormalTok{(}\StringTok{"("}\NormalTok{, a, }\StringTok{" %-% "}\NormalTok{, b, }\StringTok{")"}\NormalTok{)}
\StringTok{"a"} \NormalTok{%-%}\StringTok{ "b"} \NormalTok{%-%}\StringTok{ "c"}
\CommentTok{#> [1] "((a %-% b) %-% c)"}
\end{Highlighting}
\end{Shaded}

There's one infix function that I use very often. It's inspired by
Ruby's \texttt{\textbar{}\textbar{}} logical or operator, although it
works a little differently in R because Ruby has a more flexible
definition of what evaluates to \texttt{TRUE} in an if statement. It's
useful as a way of providing a default value in case the output of
another function is \texttt{NULL}:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{%||%}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(a, b) if (!}\KeywordTok{is.null}\NormalTok{(a)) a else b}
\KeywordTok{function_that_might_return_null}\NormalTok{() %||%}\StringTok{ }\NormalTok{default value}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{replacement-functions}{\subsection{Replacement
functions}\label{replacement-functions}}

Replacement functions act like they modify their arguments in place, and
have the special name \texttt{xxx\textless{}-}. They typically have two
arguments (\texttt{x} and \texttt{value}), although they can have more,
and they must return the modified object. For example, the following
function allows you to modify the second element of a vector:
\index{replacement functions} \index{functions!replacement}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{second<-}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(x, value) \{}
  \NormalTok{x[}\DecValTok{2}\NormalTok{] <-}\StringTok{ }\NormalTok{value}
  \NormalTok{x}
\NormalTok{\}}
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{10}
\KeywordTok{second}\NormalTok{(x) <-}\StringTok{ }\NormalTok{5L}
\NormalTok{x}
\CommentTok{#>  [1]  1  5  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

When R evaluates the assignment \texttt{second(x) \textless{}- 5}, it
notices that the left hand side of the \texttt{\textless{}-} is not a
simple name, so it looks for a function named
\texttt{second\textless{}-} to do the replacement.
\index{assignment!replacement functions}

I say they ``act'' like they modify their arguments in place, because
they actually create a modified copy. We can see that by using
\texttt{pryr::address()} to find the memory address of the underlying
object.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(pryr)}
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{10}
\KeywordTok{address}\NormalTok{(x)}
\CommentTok{#> [1] "0x7fb3024fad48"}
\KeywordTok{second}\NormalTok{(x) <-}\StringTok{ }\NormalTok{6L}
\KeywordTok{address}\NormalTok{(x)}
\CommentTok{#> [1] "0x7fb3059d9888"}
\end{Highlighting}
\end{Shaded}

Built-in functions that are implemented using \texttt{.Primitive()} will
modify in place: \index{primitive functions}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{10}
\KeywordTok{address}\NormalTok{(x)}
\CommentTok{#> [1] "0x103945110"}

\NormalTok{x[}\DecValTok{2}\NormalTok{] <-}\StringTok{ }\NormalTok{7L}
\KeywordTok{address}\NormalTok{(x)}
\CommentTok{#> [1] "0x103945110"}
\end{Highlighting}
\end{Shaded}

It's important to be aware of this behaviour since it has important
performance implications.

If you want to supply additional arguments, they go in between
\texttt{x} and \texttt{value}:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{modify<-}\StringTok{`} \NormalTok{<-}\StringTok{ }\NormalTok{function(x, position, value) \{}
  \NormalTok{x[position] <-}\StringTok{ }\NormalTok{value}
  \NormalTok{x}
\NormalTok{\}}
\KeywordTok{modify}\NormalTok{(x, }\DecValTok{1}\NormalTok{) <-}\StringTok{ }\DecValTok{10}
\NormalTok{x}
\CommentTok{#>  [1] 10  6  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

When you call \texttt{modify(x, 1) \textless{}- 10}, behind the scenes R
turns it into:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ `}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{(x, }\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This means you can't do things like:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{modify}\NormalTok{(}\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\DecValTok{1}\NormalTok{) <-}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

because that gets turned into the invalid code:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{) <-}\StringTok{ `}\DataTypeTok{modify<-}\StringTok{`}\NormalTok{(}\KeywordTok{get}\NormalTok{(}\StringTok{"x"}\NormalTok{), }\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

It's often useful to combine replacement and subsetting:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{, }\DataTypeTok{c =} \DecValTok{3}\NormalTok{)}
\KeywordTok{names}\NormalTok{(x)}
\CommentTok{#> [1] "a" "b" "c"}
\KeywordTok{names}\NormalTok{(x)[}\DecValTok{2}\NormalTok{] <-}\StringTok{ "two"}
\KeywordTok{names}\NormalTok{(x)}
\CommentTok{#> [1] "a"   "two" "c"}
\end{Highlighting}
\end{Shaded}

This works because the expression
\texttt{names(x){[}2{]} \textless{}- "two"} is evaluated as if you had
written:

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`} \NormalTok{<-}\StringTok{ }\KeywordTok{names}\NormalTok{(x)}
\StringTok{`}\DataTypeTok{*tmp*}\StringTok{`}\NormalTok{[}\DecValTok{2}\NormalTok{] <-}\StringTok{ "two"}
\KeywordTok{names}\NormalTok{(x) <-}\StringTok{ `}\DataTypeTok{*tmp*}\StringTok{`}
\end{Highlighting}
\end{Shaded}

(Yes, it really does create a local variable named \texttt{*tmp*}, which
is removed afterwards.)

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Create a list of all the replacement functions found in the base
  package. Which ones are primitive functions?
\item
  What are valid names for user created infix functions?
\item
  Create an infix \texttt{xor()} operator.
\item
  Create infix versions of the set functions \texttt{intersect()},
  \texttt{union()}, and \texttt{setdiff()}.
\item
  Create a replacement function that modifies a random location in a
  vector.
\end{enumerate}

\hyperdef{}{return-values}{\section{Return values}\label{return-values}}

The last expression evaluated in a function becomes the return value,
the result of invoking the function. \index{functions!return value}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (x <}\StringTok{ }\DecValTok{10}\NormalTok{) \{}
    \DecValTok{0}
  \NormalTok{\} else \{}
    \DecValTok{10}
  \NormalTok{\}}
\NormalTok{\}}
\KeywordTok{f}\NormalTok{(}\DecValTok{5}\NormalTok{)}
\CommentTok{#> [1] 0}
\KeywordTok{f}\NormalTok{(}\DecValTok{15}\NormalTok{)}
\CommentTok{#> [1] 10}
\end{Highlighting}
\end{Shaded}

Generally, I think it's good style to reserve the use of an explicit
\texttt{return()} for when you are returning early, such as for an
error, or a simple case of the function. This style of programming can
also reduce the level of indentation, and generally make functions
easier to understand because you can reason about them locally.
\indexc{return()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x, y) \{}
  \NormalTok{if (!x) }\KeywordTok{return}\NormalTok{(y)}

  \CommentTok{# complicated processing here}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Functions can return only a single object. But this is not a limitation
because you can return a list containing any number of objects.

The functions that are the easiest to understand and reason about are
pure functions: functions that always map the same input to the same
output and have no other impact on the workspace. In other words, pure
functions have no \textbf{side effects}: they don't affect the state of
the world in any way apart from the value they return.
\index{pure functions}

R protects you from one type of side effect: most R objects have
copy-on-modify semantics. So modifying a function argument does not
change the original value: \index{copy-on-modify}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x$a <-}\StringTok{ }\DecValTok{2}
  \NormalTok{x}
\NormalTok{\}}
\NormalTok{x <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\NormalTok{)}
\KeywordTok{f}\NormalTok{(x)}
\CommentTok{#> $a}
\CommentTok{#> [1] 2}
\NormalTok{x$a}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

(There are two important exceptions to the copy-on-modify rule:
environments and reference classes. These can be modified in place, so
extra care is needed when working with them.)

This is notably different to languages like Java where you can modify
the inputs of a function. This copy-on-modify behaviour has important
performance consequences which are discussed in depth in
\hyperref[profiling]{profiling}. (Note that the performance consequences
are a result of R's implementation of copy-on-modify semantics; they are
not true in general. Clojure is a new language that makes extensive use
of copy-on-modify semantics with limited performance consequences.)

Most base R functions are pure, with a few notable exceptions:

\begin{itemize}
\item
  \texttt{library()} which loads a package, and hence modifies the
  search path.
\item
  \texttt{setwd()}, \texttt{Sys.setenv()}, \texttt{Sys.setlocale()}
  which change the working directory, environment variables, and the
  locale, respectively.
\item
  \texttt{plot()} and friends which produce graphical output.
\item
  \texttt{write()}, \texttt{write.csv()}, \texttt{saveRDS()}, etc. which
  save output to disk.
\item
  \texttt{options()} and \texttt{par()} which modify global settings.
\item
  S4 related functions which modify global tables of classes and
  methods.
\item
  Random number generators which produce different numbers each time you
  run them.
\end{itemize}

It's generally a good idea to minimise the use of side-effects, and
where possible, to minimise the footprint of side effects by separating
pure from impure functions. Pure functions are easier to test (because
all you need to worry about are the input values and the output), and
are less likely to work differently on different versions of R or on
different platforms. For example, this is one of the motivating
principles of ggplot2: most operations work on an object that represents
a plot, and only the final \texttt{print} or \texttt{plot} call has the
side effect of actually drawing the plot.

Functions can return \texttt{invisible} values, which are not printed
out by default when you call the function. \indexc{invisible()}
\index{functions!invisible results}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f1 <-}\StringTok{ }\NormalTok{function() }\DecValTok{1}
\NormalTok{f2 <-}\StringTok{ }\NormalTok{function() }\KeywordTok{invisible}\NormalTok{(}\DecValTok{1}\NormalTok{)}

\KeywordTok{f1}\NormalTok{()}
\CommentTok{#> [1] 1}
\KeywordTok{f2}\NormalTok{()}
\KeywordTok{f1}\NormalTok{() ==}\StringTok{ }\DecValTok{1}
\CommentTok{#> [1] TRUE}
\KeywordTok{f2}\NormalTok{() ==}\StringTok{ }\DecValTok{1}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

You can force an invisible value to be displayed by wrapping it in
parentheses:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(}\KeywordTok{f2}\NormalTok{())}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

The most common function that returns invisibly is
\texttt{\textless{}-}: \index{assignment}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\DecValTok{2}
\NormalTok{(a <-}\StringTok{ }\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

This is what makes it possible to assign one value to multiple
variables:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a <-}\StringTok{ }\NormalTok{b <-}\StringTok{ }\NormalTok{c <-}\StringTok{ }\NormalTok{d <-}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

because this is parsed as:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{(a <-}\StringTok{ }\NormalTok{(b <-}\StringTok{ }\NormalTok{(c <-}\StringTok{ }\NormalTok{(d <-}\StringTok{ }\DecValTok{2}\NormalTok{))))}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

\hyperdef{}{on-exit}{\subsection{On exit}\label{on-exit}}

As well as returning a value, functions can set up other triggers to
occur when the function is finished using \texttt{on.exit()}. This is
often used as a way to guarantee that changes to the global state are
restored when the function exits. The code in \texttt{on.exit()} is run
regardless of how the function exits, whether with an explicit (early)
return, an error, or simply reaching the end of the function body.
\indexc{on.exit()}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{in_dir <-}\StringTok{ }\NormalTok{function(dir, code) \{}
  \NormalTok{old <-}\StringTok{ }\KeywordTok{setwd}\NormalTok{(dir)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{setwd}\NormalTok{(old))}

  \KeywordTok{force}\NormalTok{(code)}
\NormalTok{\}}
\KeywordTok{getwd}\NormalTok{()}
\CommentTok{#> [1] "/Users/hadley/Documents/adv-r/adv-r"}
\KeywordTok{in_dir}\NormalTok{(}\StringTok{"~"}\NormalTok{, }\KeywordTok{getwd}\NormalTok{())}
\CommentTok{#> [1] "/Users/hadley"}
\end{Highlighting}
\end{Shaded}

The basic pattern is simple:

\begin{itemize}
\item
  We first set the directory to a new location, capturing the current
  location from the output of \texttt{setwd()}.
\item
  We then use \texttt{on.exit()} to ensure that the working directory is
  returned to the previous value regardless of how the function exits.
\item
  Finally, we explicitly force evaluation of the code. (We don't
  actually need \texttt{force()} here, but it makes it clear to readers
  what we're doing.)
\end{itemize}

\textbf{Caution}: If you're using multiple \texttt{on.exit()} calls
within a function, make sure to set \texttt{add = TRUE}. Unfortunately,
the default in \texttt{on.exit()} is \texttt{add = FALSE}, so that every
time you run it, it overwrites existing exit expressions. Because of the
way \texttt{on.exit()} is implemented, it's not possible to create a
variant with \texttt{add = TRUE}, so you must be careful when using it.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  How does the \texttt{chdir} parameter of \texttt{source()} compare to
  \texttt{in\_dir()}? Why might you prefer one approach to the other?
\item
  What function undoes the action of \texttt{library()}? How do you save
  and restore the values of \texttt{options()} and \texttt{par()}?
\item
  Write a function that opens a graphics device, runs the supplied code,
  and closes the graphics device (always, regardless of whether or not
  the plotting code worked).
\item
  We can use \texttt{on.exit()} to implement a simple version of
  \texttt{capture.output()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{capture.output2 <-}\StringTok{ }\NormalTok{function(code) \{}
  \NormalTok{temp <-}\StringTok{ }\KeywordTok{tempfile}\NormalTok{()}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{file.remove}\NormalTok{(temp), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}

  \KeywordTok{sink}\NormalTok{(temp)}
  \KeywordTok{on.exit}\NormalTok{(}\KeywordTok{sink}\NormalTok{(), }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}

  \KeywordTok{force}\NormalTok{(code)}
  \KeywordTok{readLines}\NormalTok{(temp)}
\NormalTok{\}}
\KeywordTok{capture.output2}\NormalTok{(}\KeywordTok{cat}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"}\CharTok{\textbackslash{}n}\StringTok{"}\NormalTok{))}
\CommentTok{#> [1] "a" "b" "c"}
\end{Highlighting}
\end{Shaded}

  Compare \texttt{capture.output()} to \texttt{capture.output2()}. How
  do the functions differ? What features have I removed to make the key
  ideas easier to see? How have I rewritten the key ideas to be easier
  to understand?
\end{enumerate}

\hyperdef{}{function-answers}{\section{Quiz
answers}\label{function-answers}}

\enlargethispage*{\baselineskip}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The three components of a function are its body, arguments, and
  environment.
\item
  \texttt{f1(1)()} returns 11.
\item
  You'd normally write it in infix style: \texttt{1 + (2 * 3)}.
\item
  Rewriting the call to \texttt{mean(c(1:10, NA), na.rm = TRUE)} is
  easier to understand.
\item
  No, it does not throw an error because the second argument is never
  used so it's never evaluated.
\item
  See \hyperref[infix-functions]{infix} and
  \hyperref[replacement-functions]{replacement functions}.
\item
  You use \texttt{on.exit()}; see \hyperref[on-exit]{on exit} for
  details.
\end{enumerate}
