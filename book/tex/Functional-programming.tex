\chapter{Functional programming}\label{functional-programming}

R, at its heart, is a functional programming (FP) language. This means
that it provides many tools for the creation and manipulation of
functions. In particular, R has what's known as first class functions.
You can do anything with functions that you can do with vectors: you can
assign them to variables, store them in lists, pass them as arguments to
other functions, create them inside functions, and even return them as
the result of a function. \index{functional programming}

The chapter starts by showing a motivating example, removing redundancy
and duplication in code used to clean and summarise data. Then you'll
learn about the three building blocks of functional programming:
anonymous functions, closures (functions written by functions), and
lists of functions. These pieces are twined together in the conclusion
which shows how to build a suite of tools for numerical integration,
starting from very simple primitives. This is a recurring theme in FP:
start with small, easy-to-understand building blocks, combine them into
more complex structures, and apply them with confidence.

The discussion of functional programming continues in the following two
chapters: \hyperref[functionals]{functionals} explores functions that
take functions as arguments and return vectors as output, and
\hyperref[function-operators]{function operators} explores functions
that take functions as input and return them as output.

\paragraph{Outline}

\begin{itemize}
\item
  \hyperref[fp-motivation]{Motivation} motivates functional programming
  using a common problem: cleaning and summarising data before serious
  analysis.
\item
  \hyperref[anonymous-functions]{Anonymous functions} shows you a side
  of functions that you might not have known about: you can use
  functions without giving them a name.
\item
  \hyperref[closures]{Closures} introduces the closure, a function
  written by another function. A closure can access its own arguments,
  and variables defined in its parent.
\item
  \hyperref[lists-of-functions]{Lists of functions} shows how to put
  functions in a list, and explains why you might care.
\item
  \hyperref[numerical-integration]{Numerical integration} concludes the
  chapter with a case study that uses anonymous functions, closures and
  lists of functions to build a flexible toolkit for numerical
  integration.
\end{itemize}

\paragraph{Prequisites}

You should be familiar with the basic rules of lexical scoping, as
described in \hyperref[lexical-scoping]{lexical scoping}. Make sure
you've installed the pryr package with \texttt{install.packages("pryr")}

\hyperdef{}{fp-motivation}{\section{Motivation}\label{fp-motivation}}

Imagine you've loaded a data file, like the one below, that uses \(-99\)
to represent missing values. You want to replace all the \(-99\)s with
\texttt{NA}s.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Generate a sample dataset}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1014}\NormalTok{)}
\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\KeywordTok{replicate}\NormalTok{(}\DecValTok{6}\NormalTok{, }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{:}\DecValTok{10}\NormalTok{, -}\DecValTok{99}\NormalTok{), }\DecValTok{6}\NormalTok{, }\DataTypeTok{rep =} \OtherTok{TRUE}\NormalTok{)))}
\KeywordTok{names}\NormalTok{(df) <-}\StringTok{ }\NormalTok{letters[}\DecValTok{1}\NormalTok{:}\DecValTok{6}\NormalTok{]}
\NormalTok{df}
\CommentTok{#>    a  b c   d   e f}
\CommentTok{#> 1  1  6 1   5 -99 1}
\CommentTok{#> 2 10  4 4 -99   9 3}
\CommentTok{#> 3  7  9 5   4   1 4}
\CommentTok{#> 4  2  9 3   8   6 8}
\CommentTok{#> 5  1 10 5   9   8 6}
\CommentTok{#> 6  6  2 1   3   8 5}
\end{Highlighting}
\end{Shaded}

When you first started writing R code, you might have solved the problem
with copy-and-paste:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df$a[df$a ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{df$b[df$b ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{df$c[df$c ==}\StringTok{ }\NormalTok{-}\DecValTok{98}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{df$d[df$d ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{df$e[df$e ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\NormalTok{df$f[df$g ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\end{Highlighting}
\end{Shaded}

One problem with copy-and-paste is that it's easy to make mistakes. Can
you spot the two in the block above? These mistakes are inconsistencies
that arose because we didn't have an authorative description of the
desired action (replace \(-99\) with \texttt{NA}). Duplicating an action
makes bugs more likely and makes it harder to change code. For example,
if the code for a missing value changes from \(-99\) to 9999, you'd need
to make the change in multiple places.

To prevent bugs and to make more flexible code, adopt the ``do not
repeat yourself'', or DRY, principle. Popularised by the
\href{http://pragprog.com/about}{``pragmatic programmers''}, Dave Thomas
and Andy Hunt, this principle states: ``every piece of knowledge must
have a single, unambiguous, authoritative representation within a
system''. FP tools are valuable because they provide tools to reduce
duplication.

We can start applying FP ideas by writing a function that fixes the
missing values in a single vector:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fix_missing <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x[x ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
  \NormalTok{x}
\NormalTok{\}}
\NormalTok{df$a <-}\StringTok{ }\KeywordTok{fix_missing}\NormalTok{(df$a)}
\NormalTok{df$b <-}\StringTok{ }\KeywordTok{fix_missing}\NormalTok{(df$b)}
\NormalTok{df$c <-}\StringTok{ }\KeywordTok{fix_missing}\NormalTok{(df$c)}
\NormalTok{df$d <-}\StringTok{ }\KeywordTok{fix_missing}\NormalTok{(df$d)}
\NormalTok{df$e <-}\StringTok{ }\KeywordTok{fix_missing}\NormalTok{(df$e)}
\NormalTok{df$f <-}\StringTok{ }\KeywordTok{fix_missing}\NormalTok{(df$e)}
\end{Highlighting}
\end{Shaded}

This reduces the scope of possible mistakes, but it doesn't eliminate
them: you can no longer accidentally type -98 instead of -99, but you
can still mess up the name of variable. The next step is to remove this
possible source of error by combining two functions. One function,
\texttt{fix\_missing()}, knows how to fix a single vector; the other,
\texttt{lapply()}, knows how to do something to each column in a data
frame.

\texttt{lapply()} takes three inputs: \texttt{x}, a list; \texttt{f}, a
function; and \texttt{...}, other arguments to pass to \texttt{f()}. It
applies the function to each element of the list and returns a new list.
\texttt{lapply(x, f, ...)} is equivalent to the following for loop:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{out <-}\StringTok{ }\KeywordTok{vector}\NormalTok{(}\StringTok{"list"}\NormalTok{, }\KeywordTok{length}\NormalTok{(x))}
\NormalTok{for (i in }\KeywordTok{seq_along}\NormalTok{(x)) \{}
  \NormalTok{out[[i]] <-}\StringTok{ }\KeywordTok{f}\NormalTok{(x[[i]], ...)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The real \texttt{lapply()} is rather more complicated since it's
implemented in C for efficiency, but the essence of the algorithm is the
same. \texttt{lapply()} is called a \textbf{functional}, because it
takes a function as an argument. Functionals are an important part of
functional programming. You'll learn more about them in
\hyperref[functionals]{functionals}.

We can apply \texttt{lapply()} to this problem because data frames are
lists. We just need a neat little trick to make sure we get back a data
frame, not a list. Instead of assigning the results of \texttt{lapply()}
to \texttt{df}, we'll assign them to \texttt{df{[}{]}}. R's usual rules
ensure that we get a data frame, not a list. (If this comes as a
surprise, you might want to read \hyperref[subassignment]{subsetting and
assignment}.) Putting these pieces together gives us:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fix_missing <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x[x ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
  \NormalTok{x}
\NormalTok{\}}
\NormalTok{df[] <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(df, fix_missing)}
\end{Highlighting}
\end{Shaded}

This code has five advantages over copy and paste:

\begin{itemize}
\item
  It's more compact.
\item
  If the code for a missing value changes, it only needs to be updated
  in one place.
\item
  It works for any number of columns. There is no way to accidentally
  miss a column.
\item
  There is no way to accidentally treat one column differently than
  another.
\item
  It is easy to generalise this technique to a subset of columns:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df[}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{] <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(df[}\DecValTok{1}\NormalTok{:}\DecValTok{5}\NormalTok{], fix_missing)}
\end{Highlighting}
\end{Shaded}
\end{itemize}

The key idea is function composition. Take two simple functions, one
which does something to every column and one which fixes missing values,
and combine them to fix missing values in every column. Writing simple
functions that can be understood in isolation and then composed is a
powerful technique.

What if different columns used different codes for missing values? You
might be tempted to copy-and-paste:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fix_missing_99 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x[x ==}\StringTok{ }\NormalTok{-}\DecValTok{99}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
  \NormalTok{x}
\NormalTok{\}}
\NormalTok{fix_missing_999 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x[x ==}\StringTok{ }\NormalTok{-}\DecValTok{999}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
  \NormalTok{x}
\NormalTok{\}}
\NormalTok{fix_missing_9999 <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{x[x ==}\StringTok{ }\NormalTok{-}\DecValTok{999}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
  \NormalTok{x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

As before, it's easy to create bugs. Instead we could use closures,
functions that make and return functions. Closures allow us to make
functions based on a template:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{missing_fixer <-}\StringTok{ }\NormalTok{function(na_value) \{}
  \NormalTok{function(x) \{}
    \NormalTok{x[x ==}\StringTok{ }\NormalTok{na_value] <-}\StringTok{ }\OtherTok{NA}
    \NormalTok{x}
  \NormalTok{\}}
\NormalTok{\}}
\NormalTok{fix_missing_99 <-}\StringTok{ }\KeywordTok{missing_fixer}\NormalTok{(-}\DecValTok{99}\NormalTok{)}
\NormalTok{fix_missing_999 <-}\StringTok{ }\KeywordTok{missing_fixer}\NormalTok{(-}\DecValTok{999}\NormalTok{)}

\KeywordTok{fix_missing_99}\NormalTok{(}\KeywordTok{c}\NormalTok{(-}\DecValTok{99}\NormalTok{, -}\DecValTok{999}\NormalTok{))}
\CommentTok{#> [1]   NA -999}
\KeywordTok{fix_missing_999}\NormalTok{(}\KeywordTok{c}\NormalTok{(-}\DecValTok{99}\NormalTok{, -}\DecValTok{999}\NormalTok{))}
\CommentTok{#> [1] -99  NA}
\end{Highlighting}
\end{Shaded}

\begin{shortbox}\Boxhead{Extra argument}

In this case, you could argue that we should just add another argument:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{fix_missing <-}\StringTok{ }\NormalTok{function(x, na.value) \{}
  \NormalTok{x[x ==}\StringTok{ }\NormalTok{na.value] <-}\StringTok{ }\OtherTok{NA}
  \NormalTok{x}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

That's a reasonable solution here, but it doesn't always work well in
every situation. We'll see more compelling uses for closures in
\hyperref[functionals-math]{MLE}.

\end{shortbox}

Now consider a related problem. Once you've cleaned up your data, you
might want to compute the same set of numerical summaries for each
variable. You could write code like this:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(df$a)}
\KeywordTok{median}\NormalTok{(df$a)}
\KeywordTok{sd}\NormalTok{(df$a)}
\KeywordTok{mad}\NormalTok{(df$a)}
\KeywordTok{IQR}\NormalTok{(df$a)}

\KeywordTok{mean}\NormalTok{(df$b)}
\KeywordTok{median}\NormalTok{(df$b)}
\KeywordTok{sd}\NormalTok{(df$b)}
\KeywordTok{mad}\NormalTok{(df$b)}
\KeywordTok{IQR}\NormalTok{(df$b)}
\end{Highlighting}
\end{Shaded}

But again, you'd be better off identifying and removing duplicate items.
Take a minute or two to think about how you might tackle this problem
before reading on.

One approach would be to write a summary function and then apply it to
each column:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summary <-}\StringTok{ }\NormalTok{function(x) \{}
  \KeywordTok{c}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x), }\KeywordTok{median}\NormalTok{(x), }\KeywordTok{sd}\NormalTok{(x), }\KeywordTok{mad}\NormalTok{(x), }\KeywordTok{IQR}\NormalTok{(x))}
\NormalTok{\}}
\KeywordTok{lapply}\NormalTok{(df, summary)}
\end{Highlighting}
\end{Shaded}

That's a great start, but there's still some duplication. It's easier to
see if we make the summary function more realistic:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summary <-}\StringTok{ }\NormalTok{function(x) \{}
 \KeywordTok{c}\NormalTok{(}\KeywordTok{mean}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
   \KeywordTok{median}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
   \KeywordTok{sd}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
   \KeywordTok{mad}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
   \KeywordTok{IQR}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

All five functions are called with the same arguments (\texttt{x} and
\texttt{na.rm}) repeated five times. As always, duplication makes our
code fragile: it's easier to introduce bugs and harder to adapt to
changing requirements.

To remove this source of duplication, you can take advantage of another
functional programming technique: storing functions in lists.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{summary <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{funs <-}\StringTok{ }\KeywordTok{c}\NormalTok{(mean, median, sd, mad, IQR)}
  \KeywordTok{lapply}\NormalTok{(funs, function(f) }\KeywordTok{f}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This chapter discusses these techniques in more detail. But before you
can start learning them, you need to learn the simplest FP tool, the
anonymous function.

\hyperdef{}{anonymous-functions}{\section{Anonymous
functions}\label{anonymous-functions}}

In R, functions are objects in their own right. They aren't
automatically bound to a name. Unlike many languages (e.g., C, C++,
Python, and Ruby), R doesn't have a special syntax for creating a named
function: when you create a function, you use the regular assignment
operator to give it a name. If you choose not to give the function a
name, you get an \textbf{anonymous function}.
\index{functions!anonymous} \index{anoynmous functions}

You use an anonymous function when it's not worth the effort to give it
a name:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(mtcars, function(x) }\KeywordTok{length}\NormalTok{(}\KeywordTok{unique}\NormalTok{(x)))}
\KeywordTok{Filter}\NormalTok{(function(x) !}\KeywordTok{is.numeric}\NormalTok{(x), mtcars)}
\KeywordTok{integrate}\NormalTok{(function(x) }\KeywordTok{sin}\NormalTok{(x) ^}\StringTok{ }\DecValTok{2}\NormalTok{, }\DecValTok{0}\NormalTok{, pi)}
\end{Highlighting}
\end{Shaded}

Like all functions in R, anonymous functions have \texttt{formals()}, a
\texttt{body()}, and a parent \texttt{environment()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{formals}\NormalTok{(function(}\DataTypeTok{x =} \DecValTok{4}\NormalTok{) }\KeywordTok{g}\NormalTok{(x) +}\StringTok{ }\KeywordTok{h}\NormalTok{(x))}
\CommentTok{#> $x}
\CommentTok{#> [1] 4}
\KeywordTok{body}\NormalTok{(function(}\DataTypeTok{x =} \DecValTok{4}\NormalTok{) }\KeywordTok{g}\NormalTok{(x) +}\StringTok{ }\KeywordTok{h}\NormalTok{(x))}
\CommentTok{#> g(x) + h(x)}
\KeywordTok{environment}\NormalTok{(function(}\DataTypeTok{x =} \DecValTok{4}\NormalTok{) }\KeywordTok{g}\NormalTok{(x) +}\StringTok{ }\KeywordTok{h}\NormalTok{(x))}
\CommentTok{#> <environment: R_GlobalEnv>}
\end{Highlighting}
\end{Shaded}

You can call an anonymous function without giving it a name, but the
code is a little tricky to read because you must use parentheses in two
different ways: first, to call a function, and second to make it clear
that you want to call the anonymous function itself, as opposed to
calling a (possibly invalid) function \emph{inside} the anonymous
function:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# This does not call the anonymous function.}
\CommentTok{# (Note that "3" is not a valid function.)}
\NormalTok{function(x) }\DecValTok{3}\NormalTok{()}
\CommentTok{#> function(x) 3()}

\CommentTok{# With appropriate parenthesis, the function is called:}
\NormalTok{(function(x) }\DecValTok{3}\NormalTok{)()}
\CommentTok{#> [1] 3}

\CommentTok{# So this anonymous function syntax}
\NormalTok{(function(x) x +}\StringTok{ }\DecValTok{3}\NormalTok{)(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 13}

\CommentTok{# behaves exactly the same as}
\NormalTok{f <-}\StringTok{ }\NormalTok{function(x) x +}\StringTok{ }\DecValTok{3}
\KeywordTok{f}\NormalTok{(}\DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 13}
\end{Highlighting}
\end{Shaded}

You can call anonymous functions with named arguments, but doing so is a
good sign that your function needs a name.

One of the most common uses for anonymous functions is to create
closures, functions made by other functions. Closures are described in
the next section.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Given a function, like \texttt{"mean"}, \texttt{match.fun()} lets you
  find a function. Given a function, can you find its name? Why doesn't
  that make sense in R?
\item
  Use \texttt{lapply()} and an anonymous function to find the
  coefficient of variation (the standard deviation divided by the mean)
  for all columns in the \texttt{mtcars} dataset.
\item
  Use \texttt{integrate()} and an anonymous function to find the area
  under the curve for the following functions. Use
  \href{http://www.wolframalpha.com/}{Wolfram Alpha} to check your
  answers.

  \begin{enumerate}
  \def\labelenumii{\arabic{enumii}.}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    \texttt{y = x \^{} 2 - x}, x in {[}0, 10{]}
  \item
    \texttt{y = sin(x) + cos(x)}, x in {[}-\(\pi\), \(\pi\){]}
  \item
    \texttt{y = exp(x) / x}, x in {[}10, 20{]}
  \end{enumerate}
\item
  A good rule of thumb is that an anonymous function should fit on one
  line and shouldn't need to use \texttt{\{\}}. Review your code. Where
  could you have used an anonymous function instead of a named function?
  Where should you have used a named function instead of an anonymous
  function?
\end{enumerate}

\hyperdef{}{closures}{\section{Closures}\label{closures}}

\begin{quote}
``An object is data with functions. A closure is a function with data.''
--- John D. Cook
\end{quote}

One use of anonymous functions is to create small functions that are not
worth naming. Another important use is to create closures, functions
written by functions. Closures get their name because they
\textbf{enclose} the environment of the parent function and can access
all its variables. This is useful because it allows us to have two
levels of parameters: a parent level that controls operation and a child
level that does the work. \index{closures}
\index{functions!closures|see{closures}}

The following example uses this idea to generate a family of power
functions in which a parent function (\texttt{power()}) creates two
child functions (\texttt{square()} and \texttt{cube()}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{power <-}\StringTok{ }\NormalTok{function(exponent) \{}
  \NormalTok{function(x) \{}
    \NormalTok{x ^}\StringTok{ }\NormalTok{exponent}
  \NormalTok{\}}
\NormalTok{\}}

\NormalTok{square <-}\StringTok{ }\KeywordTok{power}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\KeywordTok{square}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 4}
\KeywordTok{square}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\CommentTok{#> [1] 16}

\NormalTok{cube <-}\StringTok{ }\KeywordTok{power}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\KeywordTok{cube}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\CommentTok{#> [1] 8}
\KeywordTok{cube}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\CommentTok{#> [1] 64}
\end{Highlighting}
\end{Shaded}

When you print a closure, you don't see anything terribly useful:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{square}
\CommentTok{#> function(x) \{}
\CommentTok{#>     x ^ exponent}
\CommentTok{#>   \}}
\CommentTok{#> <environment: 0x7fc4e528d318>}
\NormalTok{cube}
\CommentTok{#> function(x) \{}
\CommentTok{#>     x ^ exponent}
\CommentTok{#>   \}}
\CommentTok{#> <environment: 0x7fc4e4dc6b10>}
\end{Highlighting}
\end{Shaded}

That's because the function itself doesn't change. The difference is the
enclosing environment, \texttt{environment(square)}. One way to see the
contents of the environment is to convert it to a list:
\index{environments!of a closure}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.list}\NormalTok{(}\KeywordTok{environment}\NormalTok{(square))}
\CommentTok{#> $exponent}
\CommentTok{#> [1] 2}
\KeywordTok{as.list}\NormalTok{(}\KeywordTok{environment}\NormalTok{(cube))}
\CommentTok{#> $exponent}
\CommentTok{#> [1] 3}
\end{Highlighting}
\end{Shaded}

Another way to see what's going on is to use \texttt{pryr::unenclose()}.
This function replaces variables defined in the enclosing environment
with their values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(pryr)}
\KeywordTok{unenclose}\NormalTok{(square)}
\CommentTok{#> function (x) }
\CommentTok{#> \{}
\CommentTok{#>     x^2}
\CommentTok{#> \}}
\KeywordTok{unenclose}\NormalTok{(cube)}
\CommentTok{#> function (x) }
\CommentTok{#> \{}
\CommentTok{#>     x^3}
\CommentTok{#> \}}
\end{Highlighting}
\end{Shaded}

The parent environment of a closure is the execution environment of the
function that created it, as shown by this code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{power <-}\StringTok{ }\NormalTok{function(exponent) \{}
  \KeywordTok{print}\NormalTok{(}\KeywordTok{environment}\NormalTok{())}
  \NormalTok{function(x) x ^}\StringTok{ }\NormalTok{exponent}
\NormalTok{\}}
\NormalTok{zero <-}\StringTok{ }\KeywordTok{power}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\CommentTok{#> <environment: 0x7fc4e4e38d88>}
\KeywordTok{environment}\NormalTok{(zero)}
\CommentTok{#> <environment: 0x7fc4e4e38d88>}
\end{Highlighting}
\end{Shaded}

The execution environment normally disappears after the function returns
a value. However, functions capture their enclosing environments. This
means when function a returns function b, function b captures and stores
the execution environment of function a, and it doesn't disappear. (This
has important consequences for memory use, see \hyperref[gc]{memory
usage} for details.)

In R, almost every function is a closure. All functions remember the
environment in which they were created, typically either the global
environment, if it's a function that you've written, or a package
environment, if it's a function that someone else has written. The only
exception is primitive functions, which call C code directly and don't
have an associated environment. \index{primitive functions}

Closures are useful for making function factories, and are one way to
manage mutable state in R.

\subsection{Function factories}

A function factory is a factory for making new functions. We've already
seen two examples of function factories, \texttt{missing\_fixer()} and
\texttt{power()}. You call it with arguments that describe the desired
actions, and it returns a function that will do the work for you. For
\texttt{missing\_fixer()} and \texttt{power()}, there's not much benefit
in using a function factory instead of a single function with multiple
arguments. Function factories are most useful when:
\index{function factories}

\begin{itemize}
\item
  The different levels are more complex, with multiple arguments and
  complicated bodies.
\item
  Some work only needs to be done once, when the function is generated.
\end{itemize}

Function factories are particularly well suited to maximum likelihood
problems, and you'll see a more compelling use of them in
\hyperref[functionals-math]{mathematical functionals}.

\subsection{Mutable state}\label{mutable-state}

Having variables at two levels allows you to maintain state across
function invocations. This is possible because while the execution
environment is refreshed every time, the enclosing environment is
constant. The key to managing variables at different levels is the
double arrow assignment operator (\texttt{\textless{}\textless{}-}).
Unlike the usual single arrow assignment (\texttt{\textless{}-}) that
always assigns in the current environment, the double arrow operator
will keep looking up the chain of parent environments until it finds a
matching name. (\hyperref[binding]{Binding names to values} has more
details on how it works.) \indexc{<<-} \index{copy-on-modify!exceptions}

Together, a static parent environment and
\texttt{\textless{}\textless{}-} make it possible to maintain state
across function calls. The following example shows a counter that
records how many times a function has been called. Each time
\texttt{new\_counter} is run, it creates an environment, initialises the
counter \texttt{i} in this environment, and then creates a new function.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{new_counter <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{i <-}\StringTok{ }\DecValTok{0}
  \NormalTok{function() \{}
    \NormalTok{i <<-}\StringTok{ }\NormalTok{i +}\StringTok{ }\DecValTok{1}
    \NormalTok{i}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The new function is a closure, and its enclosing environment is the
environment created when \texttt{new\_counter()} is run. Ordinarily,
function execution environments are temporary, but a closure maintains
access to the environment in which it was created. In the example below,
closures \texttt{counter\_one()} and \texttt{counter\_two()} each get
their own enclosing environments when run, so they can maintain
different counts.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{counter_one <-}\StringTok{ }\KeywordTok{new_counter}\NormalTok{()}
\NormalTok{counter_two <-}\StringTok{ }\KeywordTok{new_counter}\NormalTok{()}

\KeywordTok{counter_one}\NormalTok{()}
\CommentTok{#> [1] 1}
\KeywordTok{counter_one}\NormalTok{()}
\CommentTok{#> [1] 2}
\KeywordTok{counter_two}\NormalTok{()}
\CommentTok{#> [1] 1}
\end{Highlighting}
\end{Shaded}

The counters get around the ``fresh start'' limitation by not modifying
variables in their local environment. Since the changes are made in the
unchanging parent (or enclosing) environment, they are preserved across
function calls.

What happens if you don't use a closure? What happens if you use
\texttt{\textless{}-} instead of \texttt{\textless{}\textless{}-}? Make
predictions about what will happen if you replace
\texttt{new\_counter()} with the variants below, then run the code and
check your predictions.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{i <-}\StringTok{ }\DecValTok{0}
\NormalTok{new_counter2 <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{i <<-}\StringTok{ }\NormalTok{i +}\StringTok{ }\DecValTok{1}
  \NormalTok{i}
\NormalTok{\}}
\NormalTok{new_counter3 <-}\StringTok{ }\NormalTok{function() \{}
  \NormalTok{i <-}\StringTok{ }\DecValTok{0}
  \NormalTok{function() \{}
    \NormalTok{i <-}\StringTok{ }\NormalTok{i +}\StringTok{ }\DecValTok{1}
    \NormalTok{i}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Modifying values in a parent environment is an important technique
because it is one way to generate ``mutable state'' in R. Mutable state
is normally hard because every time it looks like you're modifying an
object, you're actually creating and then modifying a copy. However, if
you do need mutable objects and your code is not very simple, it's
usually better to use reference classes, as described in
\hyperref[rc]{RC}.

The power of closures is tightly coupled with the more advanced ideas in
\hyperref[functionals]{functionals} and
\hyperref[function-operators]{function operators}. You'll see many more
closures in those two chapters. The following section discusses the
third technique of functional programming in R: the ability to store
functions in a list.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Why are functions created by other functions called closures?
\item
  What does the following statistical function do? What would be a
  better name for it? (The existing name is a bit of a hint.)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{bc <-}\StringTok{ }\NormalTok{function(lambda) \{}
  \NormalTok{if (lambda ==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \NormalTok{function(x) }\KeywordTok{log}\NormalTok{(x)}
  \NormalTok{\} else \{}
    \NormalTok{function(x) (x ^}\StringTok{ }\NormalTok{lambda -}\StringTok{ }\DecValTok{1}\NormalTok{) /}\StringTok{ }\NormalTok{lambda}
  \NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}
\item
  What does \texttt{approxfun()} do? What does it return?
\item
  What does \texttt{ecdf()} do? What does it return?
\item
  Create a function that creates functions that compute the ith
  \href{http://en.wikipedia.org/wiki/Central_moment}{central moment} of
  a numeric vector. You can test it by running the following code:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{1}\NormalTok{)}
\NormalTok{m2 <-}\StringTok{ }\KeywordTok{moment}\NormalTok{(}\DecValTok{2}\NormalTok{)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\DecValTok{100}\NormalTok{)}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m1}\NormalTok{(x), }\DecValTok{0}\NormalTok{))}
\KeywordTok{stopifnot}\NormalTok{(}\KeywordTok{all.equal}\NormalTok{(}\KeywordTok{m2}\NormalTok{(x), }\KeywordTok{var}\NormalTok{(x) *}\StringTok{ }\DecValTok{99} \NormalTok{/}\StringTok{ }\DecValTok{100}\NormalTok{))}
\end{Highlighting}
\end{Shaded}
\item
  Create a function \texttt{pick()} that takes an index, \texttt{i}, as
  an argument and returns a function with an argument \texttt{x} that
  subsets \texttt{x} with \texttt{i}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(mtcars, }\KeywordTok{pick}\NormalTok{(}\DecValTok{5}\NormalTok{))}
\CommentTok{# should do the same as this}
\KeywordTok{lapply}\NormalTok{(mtcars, function(x) x[[}\DecValTok{5}\NormalTok{]])}
\end{Highlighting}
\end{Shaded}
\end{enumerate}

\hyperdef{}{lists-of-functions}{\section{Lists of
functions}\label{lists-of-functions}}

In R, functions can be stored in lists. This makes it easier to work
with groups of related functions, in the same way a data frame makes it
easier to work with groups of related vectors.
\index{lists!of functions}

We'll start with a simple benchmarking example. Imagine you are
comparing the performance of multiple ways of computing the arithmetic
mean. You could do this by storing each approach (function) in a list:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{compute_mean <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{base =} \NormalTok{function(x) }\KeywordTok{mean}\NormalTok{(x),}
  \DataTypeTok{sum =} \NormalTok{function(x) }\KeywordTok{sum}\NormalTok{(x) /}\StringTok{ }\KeywordTok{length}\NormalTok{(x),}
  \DataTypeTok{manual =} \NormalTok{function(x) \{}
    \NormalTok{total <-}\StringTok{ }\DecValTok{0}
    \NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x)}
    \NormalTok{for (i in }\KeywordTok{seq_along}\NormalTok{(x)) \{}
      \NormalTok{total <-}\StringTok{ }\NormalTok{total +}\StringTok{ }\NormalTok{x[i] /}\StringTok{ }\NormalTok{n}
    \NormalTok{\}}
    \NormalTok{total}
  \NormalTok{\}}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Calling a function from a list is straightforward. You extract it then
call it:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e5}\NormalTok{)}
\KeywordTok{system.time}\NormalTok{(compute_mean$}\KeywordTok{base}\NormalTok{(x))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.001   0.000   0.000}
\KeywordTok{system.time}\NormalTok{(compute_mean[[}\DecValTok{2}\NormalTok{]](x))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.000   0.000   0.001}
\KeywordTok{system.time}\NormalTok{(compute_mean[[}\StringTok{"manual"}\NormalTok{]](x))}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.054   0.003   0.057}
\end{Highlighting}
\end{Shaded}

To call each function (e.g., to check that they all return the same
results), use \texttt{lapply()}. We'll need either an anonymous function
or a new named function, since there isn't a built-in function to handle
this situation.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(compute_mean, function(f) }\KeywordTok{f}\NormalTok{(x))}
\CommentTok{#> $base}
\CommentTok{#> [1] 0.499}
\CommentTok{#> }
\CommentTok{#> $sum}
\CommentTok{#> [1] 0.499}
\CommentTok{#> }
\CommentTok{#> $manual}
\CommentTok{#> [1] 0.499}

\NormalTok{call_fun <-}\StringTok{ }\NormalTok{function(f, ...) }\KeywordTok{f}\NormalTok{(...)}
\KeywordTok{lapply}\NormalTok{(compute_mean, call_fun, x)}
\CommentTok{#> $base}
\CommentTok{#> [1] 0.499}
\CommentTok{#> }
\CommentTok{#> $sum}
\CommentTok{#> [1] 0.499}
\CommentTok{#> }
\CommentTok{#> $manual}
\CommentTok{#> [1] 0.499}
\end{Highlighting}
\end{Shaded}

To time each function, we can combine \texttt{lapply()} and
\texttt{system.time()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(compute_mean, function(f) }\KeywordTok{system.time}\NormalTok{(}\KeywordTok{f}\NormalTok{(x)))}
\CommentTok{#> $base}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>       0       0       0 }
\CommentTok{#> }
\CommentTok{#> $sum}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.001   0.000   0.000 }
\CommentTok{#> }
\CommentTok{#> $manual}
\CommentTok{#>    user  system elapsed }
\CommentTok{#>   0.048   0.001   0.049}
\end{Highlighting}
\end{Shaded}

Another use for a list of functions is to summarise an object in
multiple ways. To do that, we could store each summary function in a
list, and then run them all with \texttt{lapply()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\NormalTok{:}\DecValTok{10}
\NormalTok{funs <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{sum =} \NormalTok{sum,}
  \DataTypeTok{mean =} \NormalTok{mean,}
  \DataTypeTok{median =} \NormalTok{median}
\NormalTok{)}
\KeywordTok{lapply}\NormalTok{(funs, function(f) }\KeywordTok{f}\NormalTok{(x))}
\CommentTok{#> $sum}
\CommentTok{#> [1] 55}
\CommentTok{#> }
\CommentTok{#> $mean}
\CommentTok{#> [1] 5.5}
\CommentTok{#> }
\CommentTok{#> $median}
\CommentTok{#> [1] 5.5}
\end{Highlighting}
\end{Shaded}

What if we wanted our summary functions to automatically remove missing
values? One approach would be make a list of anonymous functions that
call our summary functions with the appropriate arguments:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{funs2 <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{sum =} \NormalTok{function(x, ...) }\KeywordTok{sum}\NormalTok{(x, ..., }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
  \DataTypeTok{mean =} \NormalTok{function(x, ...) }\KeywordTok{mean}\NormalTok{(x, ..., }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{),}
  \DataTypeTok{median =} \NormalTok{function(x, ...) }\KeywordTok{median}\NormalTok{(x, ..., }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{)}
\KeywordTok{lapply}\NormalTok{(funs2, function(f) }\KeywordTok{f}\NormalTok{(x))}
\CommentTok{#> $sum}
\CommentTok{#> [1] 55}
\CommentTok{#> }
\CommentTok{#> $mean}
\CommentTok{#> [1] 5.5}
\CommentTok{#> }
\CommentTok{#> $median}
\CommentTok{#> [1] 5.5}
\end{Highlighting}
\end{Shaded}

This, however, leads to a lot of duplication. Apart from a different
function name, each function is almost identical. A better approach
would be to modify our \texttt{lapply()} call to include the extra
argument:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{lapply}\NormalTok{(funs, function(f) }\KeywordTok{f}\NormalTok{(x, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\subsection{Moving lists of functions to the global environment}

From time to time you may create a list of functions that you want to be
available without having to use a special syntax. For example, imagine
you want to create HTML code by mapping each tag to an R function. The
following example uses a function factory to create functions for the
tags \texttt{\textless{}p\textgreater{}} (paragraph),
\texttt{\textless{}b\textgreater{}} (bold), and
\texttt{\textless{}i\textgreater{}} (italics).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simple_tag <-}\StringTok{ }\NormalTok{function(tag) \{}
  \KeywordTok{force}\NormalTok{(tag)}
  \NormalTok{function(...) \{}
    \KeywordTok{paste0}\NormalTok{(}\StringTok{"<"}\NormalTok{, tag, }\StringTok{">"}\NormalTok{, }\KeywordTok{paste0}\NormalTok{(...), }\StringTok{"</"}\NormalTok{, tag, }\StringTok{">"}\NormalTok{)}
  \NormalTok{\}}
\NormalTok{\}}
\NormalTok{tags <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"p"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"i"}\NormalTok{)}
\NormalTok{html <-}\StringTok{ }\KeywordTok{lapply}\NormalTok{(}\KeywordTok{setNames}\NormalTok{(tags, tags), simple_tag)}
\end{Highlighting}
\end{Shaded}

I've put the functions in a list because I don't want them to be
available all the time. The risk of a conflict between an existing R
function and an HTML tag is high. But keeping them in a list makes code
more verbose:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{html$}\KeywordTok{p}\NormalTok{(}\StringTok{"This is "}\NormalTok{, html$}\KeywordTok{b}\NormalTok{(}\StringTok{"bold"}\NormalTok{), }\StringTok{" text."}\NormalTok{)}
\CommentTok{#> [1] "<p>This is <b>bold</b> text.</p>"}
\end{Highlighting}
\end{Shaded}

Depending on how long we want the effect to last, you have three options
to eliminate the use of \texttt{html\$}:

\begin{itemize}
\item
  For a very temporary effect, you can use \texttt{with()}:
  \indexc{with()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{with}\NormalTok{(html, }\KeywordTok{p}\NormalTok{(}\StringTok{"This is "}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"bold"}\NormalTok{), }\StringTok{" text."}\NormalTok{))}
\CommentTok{#> [1] "<p>This is <b>bold</b> text.</p>"}
\end{Highlighting}
\end{Shaded}
\item
  For a longer effect, you can \texttt{attach()} the functions to the
  search path, then \texttt{detach()} when you're done:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{attach}\NormalTok{(html)}
\KeywordTok{p}\NormalTok{(}\StringTok{"This is "}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"bold"}\NormalTok{), }\StringTok{" text."}\NormalTok{)}
\CommentTok{#> [1] "<p>This is <b>bold</b> text.</p>"}
\KeywordTok{detach}\NormalTok{(html)}
\end{Highlighting}
\end{Shaded}
\item
  Finally, you could copy the functions to the global environment with
  \texttt{list2env()}. You can undo this by deleting the functions after
  you're done. \indexc{list2env()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{list2env}\NormalTok{(html, }\KeywordTok{environment}\NormalTok{())}
\CommentTok{#> <environment: R_GlobalEnv>}
\KeywordTok{p}\NormalTok{(}\StringTok{"This is "}\NormalTok{, }\KeywordTok{b}\NormalTok{(}\StringTok{"bold"}\NormalTok{), }\StringTok{" text."}\NormalTok{)}
\CommentTok{#> [1] "<p>This is <b>bold</b> text.</p>"}
\KeywordTok{rm}\NormalTok{(}\DataTypeTok{list =} \KeywordTok{names}\NormalTok{(html), }\DataTypeTok{envir =} \KeywordTok{environment}\NormalTok{())}
\end{Highlighting}
\end{Shaded}
\end{itemize}

I recommend the first option, using \texttt{with()}, because it makes it
very clear when code is being executed in a special context and what
that context is.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Implement a summary function that works like \texttt{base::summary()},
  but uses a list of functions. Modify the function so it returns a
  closure, making it possible to use it as a function factory.
\item
  Which of the following commands is equivalent to
  \texttt{with(x, f(z))}?

  \begin{enumerate}
  \def\labelenumii{(\alph{enumii})}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    \texttt{x\$f(x\$z)}.
  \item
    \texttt{f(x\$z)}.
  \item
    \texttt{x\$f(z)}.
  \item
    \texttt{f(z)}.
  \item
    It depends.
  \end{enumerate}
\end{enumerate}

\hyperdef{}{numerical-integration}{\section{Case study: numerical
integration}\label{numerical-integration}}

To conclude this chapter, I'll develop a simple numerical integration
tool using first-class functions. Each step in the development of the
tool is driven by a desire to reduce duplication and to make the
approach more general. \index{integration}

The idea behind numerical integration is simple: find the area under a
curve by approximating the curve with simpler components. The two
simplest approaches are the \textbf{midpoint} and \textbf{trapezoid}
rules. The midpoint rule approximates a curve with a rectangle. The
trapezoid rule uses a trapezoid. Each takes the function we want to
integrate, \texttt{f}, and a range of values, from \texttt{a} to
\texttt{b}, to integrate over. For this example, I'll try to integrate
\texttt{sin x} from 0 to \(\pi\). This is a good choice for testing
because it has a simple answer: 2.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{midpoint <-}\StringTok{ }\NormalTok{function(f, a, b) \{}
  \NormalTok{(b -}\StringTok{ }\NormalTok{a) *}\StringTok{ }\KeywordTok{f}\NormalTok{((a +}\StringTok{ }\NormalTok{b) /}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}

\NormalTok{trapezoid <-}\StringTok{ }\NormalTok{function(f, a, b) \{}
  \NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\DecValTok{2} \NormalTok{*}\StringTok{ }\NormalTok{(}\KeywordTok{f}\NormalTok{(a) +}\StringTok{ }\KeywordTok{f}\NormalTok{(b))}
\NormalTok{\}}

\KeywordTok{midpoint}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi)}
\CommentTok{#> [1] 3.14}
\KeywordTok{trapezoid}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi)}
\CommentTok{#> [1] 1.92e-16}
\end{Highlighting}
\end{Shaded}

Neither of these functions gives a very good approximation. To make them
more accurate using the idea that underlies calculus: we'll break up the
range into smaller pieces and integrate each piece using one of the
simple rules. This is called \textbf{composite integration}. I'll
implement it using two new functions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{midpoint_composite <-}\StringTok{ }\NormalTok{function(f, a, b, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{) \{}
  \NormalTok{points <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(a, b, }\DataTypeTok{length =} \NormalTok{n +}\StringTok{ }\DecValTok{1}\NormalTok{)}
  \NormalTok{h <-}\StringTok{ }\NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\NormalTok{n}

  \NormalTok{area <-}\StringTok{ }\DecValTok{0}
  \NormalTok{for (i in }\KeywordTok{seq_len}\NormalTok{(n)) \{}
    \NormalTok{area <-}\StringTok{ }\NormalTok{area +}\StringTok{ }\NormalTok{h *}\StringTok{ }\KeywordTok{f}\NormalTok{((points[i] +}\StringTok{ }\NormalTok{points[i +}\StringTok{ }\DecValTok{1}\NormalTok{]) /}\StringTok{ }\DecValTok{2}\NormalTok{)}
  \NormalTok{\}}
  \NormalTok{area}
\NormalTok{\}}

\NormalTok{trapezoid_composite <-}\StringTok{ }\NormalTok{function(f, a, b, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{) \{}
  \NormalTok{points <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(a, b, }\DataTypeTok{length =} \NormalTok{n +}\StringTok{ }\DecValTok{1}\NormalTok{)}
  \NormalTok{h <-}\StringTok{ }\NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\NormalTok{n}

  \NormalTok{area <-}\StringTok{ }\DecValTok{0}
  \NormalTok{for (i in }\KeywordTok{seq_len}\NormalTok{(n)) \{}
    \NormalTok{area <-}\StringTok{ }\NormalTok{area +}\StringTok{ }\NormalTok{h /}\StringTok{ }\DecValTok{2} \NormalTok{*}\StringTok{ }\NormalTok{(}\KeywordTok{f}\NormalTok{(points[i]) +}\StringTok{ }\KeywordTok{f}\NormalTok{(points[i +}\StringTok{ }\DecValTok{1}\NormalTok{]))}
  \NormalTok{\}}
  \NormalTok{area}
\NormalTok{\}}

\KeywordTok{midpoint_composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 2.01}
\KeywordTok{midpoint_composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{100}\NormalTok{)}
\CommentTok{#> [1] 2}
\KeywordTok{trapezoid_composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{)}
\CommentTok{#> [1] 1.98}
\KeywordTok{trapezoid_composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{100}\NormalTok{)}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

You'll notice that there's a lot of duplication between
\texttt{midpoint\_composite()} and \texttt{trapezoid\_composite()}.
Apart from the internal rule used to integrate over a range, they are
basically the same. From these specific functions you can extract a more
general composite integration function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{composite <-}\StringTok{ }\NormalTok{function(f, a, b, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{, rule) \{}
  \NormalTok{points <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(a, b, }\DataTypeTok{length =} \NormalTok{n +}\StringTok{ }\DecValTok{1}\NormalTok{)}

  \NormalTok{area <-}\StringTok{ }\DecValTok{0}
  \NormalTok{for (i in }\KeywordTok{seq_len}\NormalTok{(n)) \{}
    \NormalTok{area <-}\StringTok{ }\NormalTok{area +}\StringTok{ }\KeywordTok{rule}\NormalTok{(f, points[i], points[i +}\StringTok{ }\DecValTok{1}\NormalTok{])}
  \NormalTok{\}}

  \NormalTok{area}
\NormalTok{\}}

\KeywordTok{composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{, }\DataTypeTok{rule =} \NormalTok{midpoint)}
\CommentTok{#> [1] 2.01}
\KeywordTok{composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{, }\DataTypeTok{rule =} \NormalTok{trapezoid)}
\CommentTok{#> [1] 1.98}
\end{Highlighting}
\end{Shaded}

This function takes two functions as arguments: the function to
integrate and the integration rule. We can now add even better rules for
integrating over smaller ranges:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{simpson <-}\StringTok{ }\NormalTok{function(f, a, b) \{}
  \NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\DecValTok{6} \NormalTok{*}\StringTok{ }\NormalTok{(}\KeywordTok{f}\NormalTok{(a) +}\StringTok{ }\DecValTok{4} \NormalTok{*}\StringTok{ }\KeywordTok{f}\NormalTok{((a +}\StringTok{ }\NormalTok{b) /}\StringTok{ }\DecValTok{2}\NormalTok{) +}\StringTok{ }\KeywordTok{f}\NormalTok{(b))}
\NormalTok{\}}

\NormalTok{boole <-}\StringTok{ }\NormalTok{function(f, a, b) \{}
  \NormalTok{pos <-}\StringTok{ }\NormalTok{function(i) a +}\StringTok{ }\NormalTok{i *}\StringTok{ }\NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\DecValTok{4}
  \NormalTok{fi <-}\StringTok{ }\NormalTok{function(i) }\KeywordTok{f}\NormalTok{(}\KeywordTok{pos}\NormalTok{(i))}

  \NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\DecValTok{90} \NormalTok{*}
\StringTok{    }\NormalTok{(}\DecValTok{7} \NormalTok{*}\StringTok{ }\KeywordTok{fi}\NormalTok{(}\DecValTok{0}\NormalTok{) +}\StringTok{ }\DecValTok{32} \NormalTok{*}\StringTok{ }\KeywordTok{fi}\NormalTok{(}\DecValTok{1}\NormalTok{) +}\StringTok{ }\DecValTok{12} \NormalTok{*}\StringTok{ }\KeywordTok{fi}\NormalTok{(}\DecValTok{2}\NormalTok{) +}\StringTok{ }\DecValTok{32} \NormalTok{*}\StringTok{ }\KeywordTok{fi}\NormalTok{(}\DecValTok{3}\NormalTok{) +}\StringTok{ }\DecValTok{7} \NormalTok{*}\StringTok{ }\KeywordTok{fi}\NormalTok{(}\DecValTok{4}\NormalTok{))}
\NormalTok{\}}

\KeywordTok{composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{, }\DataTypeTok{rule =} \NormalTok{simpson)}
\CommentTok{#> [1] 2}
\KeywordTok{composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{, }\DataTypeTok{rule =} \NormalTok{boole)}
\CommentTok{#> [1] 2}
\end{Highlighting}
\end{Shaded}

It turns out that the midpoint, trapezoid, Simpson, and Boole rules are
all examples of a more general family called
\href{http://en.wikipedia.org/wiki/Newton\%E2\%80\%93Cotes_formulas}{Newton-Cotes
rules}. (They are polynomials of increasing complexity.) We can use this
common structure to write a function that can generate any general
Newton-Cotes rule:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{newton_cotes <-}\StringTok{ }\NormalTok{function(coef, }\DataTypeTok{open =} \OtherTok{FALSE}\NormalTok{) \{}
  \NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(coef) +}\StringTok{ }\NormalTok{open}

  \NormalTok{function(f, a, b) \{}
    \NormalTok{pos <-}\StringTok{ }\NormalTok{function(i) a +}\StringTok{ }\NormalTok{i *}\StringTok{ }\NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\NormalTok{n}
    \NormalTok{points <-}\StringTok{ }\KeywordTok{pos}\NormalTok{(}\KeywordTok{seq.int}\NormalTok{(}\DecValTok{0}\NormalTok{, }\KeywordTok{length}\NormalTok{(coef) -}\StringTok{ }\DecValTok{1}\NormalTok{))}

    \NormalTok{(b -}\StringTok{ }\NormalTok{a) /}\StringTok{ }\KeywordTok{sum}\NormalTok{(coef) *}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\KeywordTok{f}\NormalTok{(points) *}\StringTok{ }\NormalTok{coef)}
  \NormalTok{\}}
\NormalTok{\}}

\NormalTok{boole <-}\StringTok{ }\KeywordTok{newton_cotes}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{7}\NormalTok{, }\DecValTok{32}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{32}\NormalTok{, }\DecValTok{7}\NormalTok{))}
\NormalTok{milne <-}\StringTok{ }\KeywordTok{newton_cotes}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, -}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{), }\DataTypeTok{open =} \OtherTok{TRUE}\NormalTok{)}
\KeywordTok{composite}\NormalTok{(sin, }\DecValTok{0}\NormalTok{, pi, }\DataTypeTok{n =} \DecValTok{10}\NormalTok{, }\DataTypeTok{rule =} \NormalTok{milne)}
\CommentTok{#> [1] 1.99}
\end{Highlighting}
\end{Shaded}

Mathematically, the next step in improving numerical integration is to
move from a grid of evenly spaced points to a grid where the points are
closer together near the end of the range, such as Gaussian quadrature.
That's beyond the scope of this case study, but you could implement it
with similar techniques.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Instead of creating individual functions (e.g., \texttt{midpoint()},
  \texttt{trapezoid()}, \texttt{simpson()}, etc.), we could store them
  in a list. If we did that, how would that change the code? Can you
  create the list of functions from a list of coefficients for the
  Newton-Cotes formulae?
\item
  The trade-off between integration rules is that more complex rules are
  slower to compute, but need fewer pieces. For \texttt{sin()} in the
  range {[}0, \(\pi\){]}, determine the number of pieces needed so that
  each rule will be equally accurate. Illustrate your results with a
  graph. How do they change for different functions?
  \texttt{sin(1 / x\^{}2)} is particularly challenging.
\end{enumerate}
