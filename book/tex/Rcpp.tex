\chapter{High performance functions with Rcpp}\label{rcpp}

Sometimes R code just isn't fast enough. You've used profiling to figure
out where your bottlenecks are, and you've done everything you can in R,
but your code still isn't fast enough. In this chapter you'll learn how
to improve performance by rewriting key functions in C++. This magic
comes by way of the \href{http://www.rcpp.org/}{Rcpp} package, a
fantastic tool written by Dirk Eddelbuettel and Romain Francois (with
key contributions by Doug Bates, John Chambers, and JJ Allaire). Rcpp
makes it very simple to connect C++ to R. While it is \emph{possible} to
write C or Fortran code for use in R, it will be painful by comparison.
Rcpp provides a clean, approachable API that lets you write
high-performance code, insulated from R's arcane C API. \index{Rcpp}
\index{C++}

Typical bottlenecks that C++ can address include:

\begin{itemize}
\item
  Loops that can't be easily vectorised because subsequent iterations
  depend on previous ones.
\item
  Recursive functions, or problems which involve calling functions
  millions of times. The overhead of calling a function in C++ is much
  lower than that in R.
\item
  Problems that require advanced data structures and algorithms that R
  doesn't provide. Through the standard template library (STL), C++ has
  efficient implementations of many important data structures, from
  ordered maps to double-ended queues.
\end{itemize}

The aim of this chapter is to discuss only those aspects of C++ and Rcpp
that are absolutely necessary to help you eliminate bottlenecks in your
code. We won't spend much time on advanced features like object oriented
programming or templates because the focus is on writing small,
self-contained functions, not big programs. A working knowledge of C++
is helpful, but not essential. Many good tutorials and references are
freely available, including \url{http://www.learncpp.com/} and
\url{http://www.cplusplus.com/}. For more advanced topics, the
\emph{Effective C++} series by Scott Meyers is popular choice. You may
also enjoy Dirk Eddelbuettel's
\href{http://www.springer.com/statistics/computational+statistics/book/978-1-4614-6867-7}{\emph{Seamless
R and C++ integration with Rcpp}}, which goes into much greater detail
into all aspects of Rcpp.

\paragraph{Outline}

\begin{itemize}
\item
  \hyperref[rcpp-intro]{Getting started with C++} teaches you how to
  write C++ by converting simple R functions to their C++ equivalents.
  You'll learn how C++ differs from R, and what the key scalar, vector,
  and matrix classes are called.
\item
  \hyperref[sourceCpp]{Using sourceCpp} shows you how to use
  \texttt{sourceCpp()} to load a C++ file from disk in the same way you
  use \texttt{source()} to load a file of R code.
\item
  \hyperref[rcpp-classes]{Attributes \& other classes} discusses how to
  modify attributes from Rcpp, and mentions some of the other important
  classes.
\item
  \hyperref[rcpp-na]{Missing values} teaches you how to work with R's
  missing values in C++.
\item
  \hyperref[rcpp-sugar]{Rcpp sugar} discusses Rcpp ``sugar'', which
  allows you to avoid loops in C++ and write code that looks very
  similar to vectorised R code.
\item
  \hyperref[stl]{The STL} shows you how to use some of the most
  important data structures and algorithms from the standard template
  library, or STL, built-in to C++.
\item
  \hyperref[rcpp-case-studies]{Case studies} shows two real case studies
  where Rcpp was used to get considerable performance improvements.
\item
  \hyperref[rcpp-package]{Putting Rcpp in a package} teaches you how to
  add C++ code to a package.
\item
  \hyperref[rcpp-more]{Learning more} concludes the chapter with
  pointers to more resources to help you learn Rcpp and C++.
\end{itemize}

\paragraph{Prerequistes}

All examples in this chapter need version 0.10.1 or above of the
\texttt{Rcpp} package. This version includes \texttt{cppFunction()} and
\texttt{sourceCpp()}, which makes it very easy to connect C++ to R.
Install the latest version of Rcpp from CRAN with
\texttt{install.packages("Rcpp")}.

You'll also need a working C++ compiler. To get it:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  On Windows, install
  \href{http://cran.r-project.org/bin/windows/Rtools/}{Rtools}.
\item
  On Mac, install Xcode from the app store.
\item
  On Linux, \texttt{sudo apt-get install r-base-dev} or similar.
\end{itemize}

\hyperdef{}{rcpp-intro}{\section{Getting started with
C++}\label{rcpp-intro}}

\texttt{cppFunction()} allows you to write C++ functions in R:
\indexc{cppFunction()}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(Rcpp)}
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'int add(int x, int y, int z) \{}
\StringTok{  int sum = x + y + z;}
\StringTok{  return sum;}
\StringTok{\}'}\NormalTok{)}
\CommentTok{# add works like a regular R function}
\NormalTok{add}
\CommentTok{#> function (x, y, z) }
\CommentTok{#> .Primitive(".Call")(<pointer: 0x10839be30>, x, y, z)}
\KeywordTok{add}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{#> [1] 6}
\end{Highlighting}
\end{Shaded}

When you run this code, Rcpp will compile the C++ code and construct an
R function that connects to the compiled C++ function. We're going to
use this simple interface to learn how to write C++. C++ is a large
language, and there's no way to cover it all in just one chapter.
Instead, you'll get the basics so that you can start writing useful
functions to address bottlenecks in your R code.

The following sections will teach you the basics by translating simple R
functions to their C++ equivalents. We'll start simple with a function
that has no inputs and a scalar output, and then get progressively more
complicated:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Scalar input and scalar output
\item
  Vector input and scalar output
\item
  Vector input and vector output
\item
  Matrix input and vector output
\end{itemize}

\subsection{No inputs, scalar output}

Let's start with a very simple function. It has no arguments and always
returns the integer 1:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{one <-}\StringTok{ }\NormalTok{function() 1L}
\end{Highlighting}
\end{Shaded}

The equivalent C++ function is:

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int} \NormalTok{one() \{}
  \KeywordTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We can compile and use this from R with \texttt{cppFunction}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'int one() \{}
\StringTok{  return 1;}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This small function illustrates a number of important differences
between R and C++:

\begin{itemize}
\item
  The syntax to create a function looks like the syntax to call a
  function; you don't use assignment to create functions as you do in R.
\item
  You must declare the type of output the function returns. This
  function returns an \texttt{int} (a scalar integer). The classes for
  the most common types of R vectors are: \texttt{NumericVector},
  \texttt{IntegerVector}, \texttt{CharacterVector}, and
  \texttt{LogicalVector}.
\item
  Scalars and vectors are different. The scalar equivalents of numeric,
  integer, character, and logical vectors are: \texttt{double},
  \texttt{int}, \texttt{String}, and \texttt{bool}.
\item
  You must use an explicit \texttt{return} statement to return a value
  from a function.
\item
  Every statement is terminated by a \texttt{;}.
\end{itemize}

\subsection{Scalar input, scalar output}

The next example function implements a scalar version of the
\texttt{sign()} function which returns 1 if the input is positive, and
-1 if it's negative:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{signR <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{if (x >}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \DecValTok{1}
  \NormalTok{\} else if (x ==}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
    \DecValTok{0}
  \NormalTok{\} else \{}
    \NormalTok{-}\DecValTok{1}
  \NormalTok{\}}
\NormalTok{\}}

\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'int signC(int x) \{}
\StringTok{  if (x > 0) \{}
\StringTok{    return 1;}
\StringTok{  \} else if (x == 0) \{}
\StringTok{    return 0;}
\StringTok{  \} else \{}
\StringTok{    return -1;}
\StringTok{  \}}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the C++ version:

\begin{itemize}
\item
  We declare the type of each input in the same way we declare the type
  of the output. While this makes the code a little more verbose, it
  also makes it very obvious what type of input the function needs.
\item
  The \texttt{if} syntax is identical --- while there are some big
  differences between R and C++, there are also lots of similarities!
  C++ also has a \texttt{while} statement that works the same way as
  R's. As in R you can use \texttt{break} to exit the loop, but to skip
  one iteration you need to use \texttt{continue} instead of
  \texttt{next}.
\end{itemize}

\subsection{Vector input, scalar output}

One big difference between R and C++ is that the cost of loops is much
lower in C++. For example, we could implement the \texttt{sum} function
in R using a loop. If you've been programming in R a while, you'll
probably have a visceral reaction to this function!

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sumR <-}\StringTok{ }\NormalTok{function(x) \{}
  \NormalTok{total <-}\StringTok{ }\DecValTok{0}
  \NormalTok{for (i in }\KeywordTok{seq_along}\NormalTok{(x)) \{}
    \NormalTok{total <-}\StringTok{ }\NormalTok{total +}\StringTok{ }\NormalTok{x[i]}
  \NormalTok{\}}
  \NormalTok{total}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

In C++, loops have very little overhead, so it's fine to use them. In
\hyperref[stl]{STL}, you'll see alternatives to \texttt{for} loops that
more clearly express your intent; they're not faster, but they can make
your code easier to understand.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'double sumC(NumericVector x) \{}
\StringTok{  int n = x.size();}
\StringTok{  double total = 0;}
\StringTok{  for(int i = 0; i < n; ++i) \{}
\StringTok{    total += x[i];}
\StringTok{  \}}
\StringTok{  return total;}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The C++ version is similar, but:

\begin{itemize}
\item
  To find the length of the vector, we use the \texttt{.size()} method,
  which returns an integer. C++ methods are called with \texttt{.}
  (i.e., a full stop).
\item
  The \texttt{for} statement has a different syntax:
  \texttt{for(init; check; increment)}. This loop is initialised by
  creating a new variable called \texttt{i} with value 0. Before each
  iteration we check that \texttt{i \textless{} n}, and terminate the
  loop if it's not. After each iteration, we increment the value of
  \texttt{i} by one, using the special prefix operator \texttt{++} which
  increases the value of \texttt{i} by 1.
\item
  In C++, vector indices start at 0. I'll say this again because it's so
  important: \textbf{IN C++, VECTOR INDICES START AT 0}! This is a very
  common source of bugs when converting R functions to C++.
\item
  Use \texttt{=} for assignment, not \texttt{\textless{}-}.
\item
  C++ provides operators that modify in-place:
  \texttt{total += x{[}i{]}} is equivalent to
  \texttt{total = total + x{[}i{]}}. Similar in-place operators are
  \texttt{-=}, \texttt{*=}, and \texttt{/=}.
\end{itemize}

This is a good example of where C++ is much more efficient than R. As
shown by the following microbenchmark, \texttt{sumC()} is competitive
with the built-in (and highly optimised) \texttt{sum()}, while
\texttt{sumR()} is several orders of magnitude slower.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e3}\NormalTok{)}
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{sum}\NormalTok{(x),}
  \KeywordTok{sumC}\NormalTok{(x),}
  \KeywordTok{sumR}\NormalTok{(x)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>     expr    min     lq median     uq     max neval}
\CommentTok{#>   sum(x)   1.07   1.24   1.55   2.43    17.2   100}
\CommentTok{#>  sumC(x)   2.73   3.17   4.69   7.87    30.5   100}
\CommentTok{#>  sumR(x) 342.00 381.00 404.00 491.00 1,380.0   100}
\end{Highlighting}
\end{Shaded}

\subsection{Vector input, vector output}

Next we'll create a function that computes the Euclidean distance
between a value and a vector of values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pdistR <-}\StringTok{ }\NormalTok{function(x, ys) \{}
  \KeywordTok{sqrt}\NormalTok{((x -}\StringTok{ }\NormalTok{ys) ^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

It's not obvious that we want \texttt{x} to be a scalar from the
function definition. We'd need to make that clear in the documentation.
That's not a problem in the C++ version because we have to be explicit
about types:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'NumericVector pdistC(double x, NumericVector ys) \{}
\StringTok{  int n = ys.size();}
\StringTok{  NumericVector out(n);}

\StringTok{  for(int i = 0; i < n; ++i) \{}
\StringTok{    out[i] = sqrt(pow(ys[i] - x, 2.0));}
\StringTok{  \}}
\StringTok{  return out;}
\StringTok{\}'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This function introduces only a few new concepts:

\begin{itemize}
\item
  We create a new numeric vector of length \texttt{n} with a
  constructor: \texttt{NumericVector out(n)}. Another useful way of
  making a vector is to copy an existing one:
  \texttt{NumericVector zs = clone(ys)}.
\item
  C++ uses \texttt{pow()}, not \texttt{\^{}}, for exponentiation.
\end{itemize}

Note that because the R version is fully vectorised, it's already going
to be fast. On my computer, it takes around 8 ms with a 1 million
element \texttt{y} vector. The C++ function is twice as fast,
\textasciitilde{}4 ms, but assuming it took you 10 minutes to write the
C++ function, you'd need to run it \textasciitilde{}150,000 times to
make rewriting worthwhile. The reason why the C++ function is faster is
subtle, and relates to memory management. The R version needs to create
an intermediate vector the same length as y (\texttt{x - ys}), and
allocating memory is an expensive operation. The C++ function avoids
this overhead because it uses an intermediate scalar.

In the sugar section, you'll see how to rewrite this function to take
advantage of Rcpp's vectorised operations so that the C++ code is almost
as concise as R code.

\subsection{Matrix input, vector output}

Each vector type has a matrix equivalent: \texttt{NumericMatrix},
\texttt{IntegerMatrix}, \texttt{CharacterMatrix}, and
\texttt{LogicalMatrix}. Using them is straightforward. For example, we
could create a function that reproduces \texttt{rowSums()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cppFunction}\NormalTok{(}\StringTok{'NumericVector rowSumsC(NumericMatrix x) \{}
\StringTok{  int nrow = x.nrow(), ncol = x.ncol();}
\StringTok{  NumericVector out(nrow);}

\StringTok{  for (int i = 0; i < nrow; i++) \{}
\StringTok{    double total = 0;}
\StringTok{    for (int j = 0; j < ncol; j++) \{}
\StringTok{      total += x(i, j);}
\StringTok{    \}}
\StringTok{    out[i] = total;}
\StringTok{  \}}
\StringTok{  return out;}
\StringTok{\}'}\NormalTok{)}
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{1014}\NormalTok{)}
\NormalTok{x <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{sample}\NormalTok{(}\DecValTok{100}\NormalTok{), }\DecValTok{10}\NormalTok{)}
\KeywordTok{rowSums}\NormalTok{(x)}
\CommentTok{#>  [1] 458 558 488 458 536 537 488 491 508 528}
\KeywordTok{rowSumsC}\NormalTok{(x)}
\CommentTok{#>  [1] 458 558 488 458 536 537 488 491 508 528}
\end{Highlighting}
\end{Shaded}

The main differences:

\begin{itemize}
\item
  In C++, you subset a matrix with \texttt{()}, not \texttt{{[}{]}}.
\item
  Use \texttt{.nrow()} and \texttt{.ncol()} \emph{methods} to get the
  dimensions of a matrix.
\end{itemize}

\hyperdef{}{sourceCpp}{\subsection{Using sourceCpp}\label{sourceCpp}}

So far, we've used inline C++ with \texttt{cppFunction()}. This makes
presentation simpler, but for real problems, it's usually easier to use
stand-alone C++ files and then source them into R using
\texttt{sourceCpp()}. This lets you take advantage of text editor
support for C++ files (e.g., syntax highlighting) as well as making it
easier to identify the line numbers in compilation errors.
\indexc{sourceCpp()}

Your stand-alone C++ file should have extension \texttt{.cpp}, and needs
to start with:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}
\end{Highlighting}
\end{Shaded}

And for each function that you want available within R, you need to
prefix it with:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// [[Rcpp::export]]}
\end{Highlighting}
\end{Shaded}

Note that the space is mandatory.

If you're familiar with roxygen2, you might wonder how this relates to
\texttt{@export}. \texttt{Rcpp::export} controls whether a function is
exported from C++ to R; \texttt{@export} controls whether a function is
exported from a package and made available to the user.

You can embed R code in special C++ comment blocks. This is really
convenient if you want to run some test code:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/*** R}
\CommentTok{# This is R code}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

The R code is run with \texttt{source(echo = TRUE)} so you don't need to
explicitly print output.

To compile the C++ code, use \texttt{sourceCpp("path/to/file.cpp")}.
This will create the matching R functions and add them to your current
session. Note that these functions can not be saved in a \texttt{.Rdata}
file and reloaded in a later session; they must be recreated each time
you restart R. For example, running \texttt{sourceCpp()} on the
following file implements mean in C++ and then compares it to the
built-in \texttt{mean()}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double} \NormalTok{meanC(NumericVector x) \{}
  \DataTypeTok{int} \NormalTok{n = x.size();}
  \DataTypeTok{double} \NormalTok{total = }\DecValTok{0}\NormalTok{;}

  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{total += x[i];}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{total / n;}
\NormalTok{\}}

\CommentTok{/*** R}
\CommentTok{library(microbenchmark)}
\CommentTok{x <- runif(1e5)}
\CommentTok{microbenchmark(}
\CommentTok{  mean(x),}
\CommentTok{  meanC(x)}
\CommentTok{)}
\CommentTok{*/}
\end{Highlighting}
\end{Shaded}

NB: if you run this code yourself, you'll notice that \texttt{meanC()}
is much faster than the built-in \texttt{mean()}. This is because it
trades numerical accuracy for speed.

For the remainder of this chapter C++ code will be presented stand-alone
rather than wrapped in a call to \texttt{cppFunction}. If you want to
try compiling and/or modifying the examples you should paste them into a
C++ source file that includes the elements described above.

\subsection{Exercises}

With the basics of C++ in hand, it's now a great time to practice by
reading and writing some simple C++ functions. For each of the following
functions, read the code and figure out what the corresponding base R
function is. You might not understand every part of the code yet, but
you should be able to figure out the basics of what the function does.

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{double} \NormalTok{f1(NumericVector x) \{}
  \DataTypeTok{int} \NormalTok{n = x.size();}
  \DataTypeTok{double} \NormalTok{y = }\DecValTok{0}\NormalTok{;}

  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{y += x[i] / n;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{y;}
\NormalTok{\}}

\NormalTok{NumericVector f2(NumericVector x) \{}
  \DataTypeTok{int} \NormalTok{n = x.size();}
  \NormalTok{NumericVector out(n);}

  \NormalTok{out[}\DecValTok{0}\NormalTok{] = x[}\DecValTok{0}\NormalTok{];}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{1}\NormalTok{; i < n; ++i) \{}
    \NormalTok{out[i] = out[i - }\DecValTok{1}\NormalTok{] + x[i];}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}

\DataTypeTok{bool} \NormalTok{f3(LogicalVector x) \{}
  \DataTypeTok{int} \NormalTok{n = x.size();}

  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \KeywordTok{if} \NormalTok{(x[i]) }\KeywordTok{return} \KeywordTok{true}\NormalTok{;}
  \NormalTok{\}}
  \KeywordTok{return} \KeywordTok{false}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{int} \NormalTok{f4(Function pred, List x) \{}
  \DataTypeTok{int} \NormalTok{n = x.size();}

  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{LogicalVector res = pred(x[i]);}
    \KeywordTok{if} \NormalTok{(res[}\DecValTok{0}\NormalTok{]) }\KeywordTok{return} \NormalTok{i + }\DecValTok{1}\NormalTok{;}
  \NormalTok{\}}
  \KeywordTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\NormalTok{NumericVector f5(NumericVector x, NumericVector y) \{}
  \DataTypeTok{int} \NormalTok{n = std::max(x.size(), y.size());}
  \NormalTok{NumericVector x1 = rep_len(x, n);}
  \NormalTok{NumericVector y1 = rep_len(y, n);}

  \NormalTok{NumericVector out(n);}

  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{out[i] = std::min(x1[i], y1[i]);}
  \NormalTok{\}}

  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

To practice your function writing skills, convert the following
functions into C++. For now, assume the inputs have no missing values.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{all()}
\item
  \texttt{cumprod()}, \texttt{cummin()}, \texttt{cummax()}.
\item
  \texttt{diff()}. Start by assuming lag 1, and then generalise for lag
  \texttt{n}.
\item
  \texttt{range}.
\item
  \texttt{var}. Read about the approaches you can take on
  \href{http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance}{wikipedia}.
  Whenever implementing a numerical algorithm, it's always good to check
  what is already known about the problem.
\end{enumerate}

\hyperdef{}{rcpp-classes}{\section{Attributes and other
classes}\label{rcpp-classes}}

You've already seen the basic vector classes (\texttt{IntegerVector},
\texttt{NumericVector}, \texttt{LogicalVector},
\texttt{CharacterVector}) and their scalar (\texttt{int},
\texttt{double}, \texttt{bool}, \texttt{String}) and matrix
(\texttt{IntegerMatrix}, \texttt{NumericMatrix}, \texttt{LogicalMatrix},
\texttt{CharacterMatrix}) equivalents.

All R objects have attributes, which can be queried and modified with
\texttt{.attr()}. Rcpp also provides \texttt{.names()} as an alias for
the name attribute. The following code snippet illustrates these
methods. Note the use of \texttt{::create()}, a \emph{class} method.
This allows you to create an R vector from C++ scalar values:
\index{attributes!in C++ } \index{names!in C++}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector attribs() \{}
  \NormalTok{NumericVector out = NumericVector::create(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{);}

  \NormalTok{out.names() = CharacterVector::create(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{);}
  \NormalTok{out.attr(}\StringTok{"my-attr"}\NormalTok{) = }\StringTok{"my-value"}\NormalTok{;}
  \NormalTok{out.attr(}\StringTok{"class"}\NormalTok{) = }\StringTok{"my-class"}\NormalTok{;}

  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

For S4 objects, \texttt{.slot()} plays a similar role to
\texttt{.attr()}.

\subsection{Lists and data frames}

Rcpp also provides classes \texttt{List} and \texttt{DataFrame}, but
they are more useful for output than input. This is because lists and
data frames can contain arbitrary classes but C++ needs to know their
classes in advance. If the list has known structure (e.g., it's an S3
object), you can extract the components and manually convert them to
their C++ equivalents with \texttt{as()}. For example, the object
created by \texttt{lm()}, the function that fits a linear model, is a
list whose components are always of the same type. The following code
illustrates how you might extract the mean percentage error
(\texttt{mpe()}) of a linear model. This isn't a good example of when to
use C++, because it's so easily implemented in R, but it shows how to
work with an important S3 class. Note the use of \texttt{.inherits()}
and the \texttt{stop()} to check that the object really is a linear
model. \index{lists!in C++} \index{data frames!in C++}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double} \NormalTok{mpe(List mod) \{}
  \KeywordTok{if} \NormalTok{(!mod.inherits(}\StringTok{"lm"}\NormalTok{)) stop(}\StringTok{"Input must be a linear model"}\NormalTok{);}

  \NormalTok{NumericVector resid = as<NumericVector>(mod[}\StringTok{"residuals"}\NormalTok{]);}
  \NormalTok{NumericVector fitted = as<NumericVector>(mod[}\StringTok{"fitted.values"}\NormalTok{]);}

  \DataTypeTok{int} \NormalTok{n = resid.size();}
  \DataTypeTok{double} \NormalTok{err = }\DecValTok{0}\NormalTok{;}
  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{err += resid[i] / (fitted[i] + resid[i]);}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{err / n;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg ~}\StringTok{ }\NormalTok{wt, }\DataTypeTok{data =} \NormalTok{mtcars)}
\KeywordTok{mpe}\NormalTok{(mod)}
\CommentTok{#> [1] -0.0154}
\end{Highlighting}
\end{Shaded}

\subsection{Functions}\label{functions-rcpp}

You can put R functions in an object of type \texttt{Function}. This
makes calling an R function from C++ straightforward. We first define
our C++ function: \index{functions!in C++}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{RObject callWithOne(Function f) \{}
  \KeywordTok{return} \NormalTok{f(}\DecValTok{1}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Then call it from R:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{callWithOne}\NormalTok{(function(x) x +}\StringTok{ }\DecValTok{1}\NormalTok{)}
\CommentTok{#> [1] 2}
\KeywordTok{callWithOne}\NormalTok{(paste)}
\CommentTok{#> [1] "1"}
\end{Highlighting}
\end{Shaded}

What type of object does an R function return? We don't know, so we use
the catchall type \texttt{RObject}. An alternative is to return a
\texttt{List}. For example, the following code is a basic implementation
of \texttt{lapply} in C++:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List lapply1(List input, Function f) \{}
  \DataTypeTok{int} \NormalTok{n = input.size();}
  \NormalTok{List out(n);}

  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; i++) \{}
    \NormalTok{out[i] = f(input[i]);}
  \NormalTok{\}}

  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Calling R functions with positional arguments is obvious:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f(}\StringTok{"y"}\NormalTok{, }\DecValTok{1}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

But to use named arguments, you need a special syntax:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{f(_[}\StringTok{"x"}\NormalTok{] = }\StringTok{"y"}\NormalTok{, _[}\StringTok{"value"}\NormalTok{] = }\DecValTok{1}\NormalTok{);}
\end{Highlighting}
\end{Shaded}

\subsection{Other types}

There are also classes for many more specialised language objects:
\texttt{Environment}, \texttt{ComplexVector}, \texttt{RawVector},
\texttt{DottedPair}, \texttt{Language}, \texttt{Promise},
\texttt{Symbol}, \texttt{WeakReference}, and so on. These are beyond the
scope of this chapter and won't be discussed further.

\hyperdef{}{rcpp-na}{\section{Missing values}\label{rcpp-na}}

If you're working with missing values, you need to know two things:
\index{missing values!in C++}

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  how R's missing values behave in C++'s scalars (e.g.,
  \texttt{double}).
\item
  how to get and set missing values in vectors (e.g.,
  \texttt{NumericVector}).
\end{itemize}

\subsection{Scalars}

The following code explores what happens when you take one of R's
missing values, coerce it into a scalar, and then coerce back to an R
vector. Note that this kind of experimentation is a useful way to figure
out what any operation does.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List scalar_missings() \{}
  \DataTypeTok{int} \NormalTok{int_s = NA_INTEGER;}
  \NormalTok{String chr_s = NA_STRING;}
  \DataTypeTok{bool} \NormalTok{lgl_s = NA_LOGICAL;}
  \DataTypeTok{double} \NormalTok{num_s = NA_REAL;}

  \KeywordTok{return} \NormalTok{List::create(int_s, chr_s, lgl_s, num_s);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{scalar_missings}\NormalTok{())}
\CommentTok{#> List of 4}
\CommentTok{#>  $ : int NA}
\CommentTok{#>  $ : chr NA}
\CommentTok{#>  $ : logi TRUE}
\CommentTok{#>  $ : num NA}
\end{Highlighting}
\end{Shaded}

With the exception of \texttt{bool}, things look pretty good here: all
of the missing values have been preserved. However, as we'll see in the
following sections, things are not quite as straightforward as they
seem.

\subsubsection{Integers}

With integers, missing values are stored as the smallest integer. If you
don't do anything to them, they'll be preserved. But, since C++ doesn't
know that the smallest integer has this special behaviour, if you do
anything to it you're likely to get an incorrect value: for example,
\texttt{evalCpp(\textquotesingle{}NA\_INTEGER + 1\textquotesingle{})}
gives -2147483647.

So if you want to work with missing values in integers, either use a
length one \texttt{IntegerVector} or be very careful with your code.

\subsubsection{Doubles}

With doubles, you may be able to get away with ignoring missing values
and working with NaNs (not a number). This is because R's NA is a
special type of IEEE 754 floating point number NaN. So any logical
expression that involves a NaN (or in C++, NAN) always evaluates as
FALSE:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN == 1"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN < 1"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN > 1"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN == NAN"}\NormalTok{)}
\CommentTok{#> [1] FALSE}
\end{Highlighting}
\end{Shaded}

But be careful when combining then with boolean values:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN && TRUE"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN || FALSE"}\NormalTok{)}
\CommentTok{#> [1] TRUE}
\end{Highlighting}
\end{Shaded}

However, in numeric contexts NaNs will propagate NAs:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN + 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN - 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN / 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\KeywordTok{evalCpp}\NormalTok{(}\StringTok{"NAN * 1"}\NormalTok{)}
\CommentTok{#> [1] NaN}
\end{Highlighting}
\end{Shaded}

\subsection{Strings}

\texttt{String} is a scalar string class introduced by Rcpp, so it knows
how to deal with missing values.

\subsection{Boolean}

While C++'s \texttt{bool} has two possible values (\texttt{true} or
\texttt{false}), a logical vector in R has three (\texttt{TRUE},
\texttt{FALSE}, and \texttt{NA}). If you coerce a length 1 logical
vector, make sure it doesn't contain any missing values otherwise they
will be converted to TRUE.

\subsection{Vectors}\label{vectors-rcpp}

With vectors, you need to use a missing value specific to the type of
vector, \texttt{NA\_REAL}, \texttt{NA\_INTEGER}, \texttt{NA\_LOGICAL},
\texttt{NA\_STRING}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List missing_sampler() \{}
  \KeywordTok{return} \NormalTok{List::create(}
    \NormalTok{NumericVector::create(NA_REAL),}
    \NormalTok{IntegerVector::create(NA_INTEGER),}
    \NormalTok{LogicalVector::create(NA_LOGICAL),}
    \NormalTok{CharacterVector::create(NA_STRING));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(}\KeywordTok{missing_sampler}\NormalTok{())}
\CommentTok{#> List of 4}
\CommentTok{#>  $ : num NA}
\CommentTok{#>  $ : int NA}
\CommentTok{#>  $ : logi NA}
\CommentTok{#>  $ : chr NA}
\end{Highlighting}
\end{Shaded}

To check if a value in a vector is missing, use the class method
\texttt{::is\_na()}:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector is_naC(NumericVector x) \{}
  \DataTypeTok{int} \NormalTok{n = x.size();}
  \NormalTok{LogicalVector out(n);}

  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{out[i] = NumericVector::is_na(x[i]);}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_naC}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\FloatTok{5.4}\NormalTok{, }\FloatTok{3.2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\CommentTok{#> [1]  TRUE FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

Another alternative is the sugar function \texttt{is\_na()}, which takes
a vector and returns a logical vector.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector is_naC2(NumericVector x) \{}
  \KeywordTok{return} \NormalTok{is_na(x);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is_naC2}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\FloatTok{5.4}\NormalTok{, }\FloatTok{3.2}\NormalTok{, }\OtherTok{NA}\NormalTok{))}
\CommentTok{#> [1]  TRUE FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Rewrite any of the functions from the first exercise to deal with
  missing values. If \texttt{na.rm} is true, ignore the missing values.
  If \texttt{na.rm} is false, return a missing value if the input
  contains any missing values. Some good functions to practice with are
  \texttt{min()}, \texttt{max()}, \texttt{range()}, \texttt{mean()}, and
  \texttt{var()}.
\item
  Rewrite \texttt{cumsum()} and \texttt{diff()} so they can handle
  missing values. Note that these functions have slightly more
  complicated behaviour.
\end{enumerate}

\hyperdef{}{rcpp-sugar}{\section{Rcpp sugar}\label{rcpp-sugar}}

Rcpp provides a lot of syntactic ``sugar'' to ensure that C++ functions
work very similarly to their R equivalents. In fact, Rcpp sugar makes it
possible to write efficient C++ code that looks almost identical to its
R equivalent. If there's a sugar version of the function you're
interested in, you should use it: it'll be both expressive and well
tested. Sugar functions aren't always faster than a handwritten
equivalent, but they will get faster in the future as more time is spent
on optimising Rcpp.

Sugar functions can be roughly broken down into

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  arithmetic and logical operators
\item
  logical summary functions
\item
  vector views
\item
  other useful functions
\end{itemize}

\subsection{Arithmetic and logical operators}

All the basic arithmetic and logical operators are vectorised:
\texttt{+} \texttt{*}, \texttt{-}, \texttt{/}, \texttt{pow},
\texttt{\textless{}}, \texttt{\textless{}=}, \texttt{\textgreater{}},
\texttt{\textgreater{}=}, \texttt{==}, \texttt{!=}, \texttt{!}. For
example, we could use sugar to considerably simplify the implementation
of \texttt{pdistC()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pdistR <-}\StringTok{ }\NormalTok{function(x, ys) \{}
  \KeywordTok{sqrt}\NormalTok{((x -}\StringTok{ }\NormalTok{ys) ^}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector pdistC2(}\DataTypeTok{double} \NormalTok{x, NumericVector ys) \{}
  \KeywordTok{return} \NormalTok{sqrt(pow((x - ys), }\DecValTok{2}\NormalTok{));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\subsection{Logical summary functions}

The sugar function \texttt{any()} and \texttt{all()} are fully lazy so
that \texttt{any(x == 0)}, for example, might only need to evaluate one
element of a vector, and return a special type that can be converted
into a \texttt{bool} using \texttt{.is\_true()}, \texttt{.is\_false()},
or \texttt{.is\_na()}. We could also use this sugar to write an
efficient function to determine whether or not a numeric vector contains
any missing values. To do this in R, we could use
\texttt{any(is.na(x))}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{any_naR <-}\StringTok{ }\NormalTok{function(x) }\KeywordTok{any}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(x))}
\end{Highlighting}
\end{Shaded}

However, this will do the same amount of work regardless of the location
of the missing value. Here's the C++ implementation:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{bool} \NormalTok{any_naC(NumericVector x) \{}
  \KeywordTok{return} \NormalTok{is_true(any(is_na(x)));}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x0 <-}\StringTok{ }\KeywordTok{runif}\NormalTok{(}\FloatTok{1e5}\NormalTok{)}
\NormalTok{x1 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(x0, }\OtherTok{NA}\NormalTok{)}
\NormalTok{x2 <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, x0)}

\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{any_naR}\NormalTok{(x0), }\KeywordTok{any_naC}\NormalTok{(x0),}
  \KeywordTok{any_naR}\NormalTok{(x1), }\KeywordTok{any_naC}\NormalTok{(x1),}
  \KeywordTok{any_naR}\NormalTok{(x2), }\KeywordTok{any_naC}\NormalTok{(x2)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>         expr    min     lq median     uq     max neval}
\CommentTok{#>  any_naR(x0) 254.00 263.00 285.00 410.00 1,590.0   100}
\CommentTok{#>  any_naC(x0) 336.00 347.00 365.00 467.00   632.0   100}
\CommentTok{#>  any_naR(x1) 253.00 264.00 284.00 365.00 1,390.0   100}
\CommentTok{#>  any_naC(x1) 336.00 347.00 391.00 472.00   639.0   100}
\CommentTok{#>  any_naR(x2)  87.10  95.10 107.00 135.00 1,390.0   100}
\CommentTok{#>  any_naC(x2)   1.85   2.64   3.51   4.56    13.2   100}
\end{Highlighting}
\end{Shaded}

\subsection{Vector views}

A number of helpful functions provide a ``view'' of a vector:
\texttt{head()}, \texttt{tail()}, \texttt{rep\_each()},
\texttt{rep\_len()}, \texttt{rev()}, \texttt{seq\_along()}, and
\texttt{seq\_len()}. In R these would all produce copies of the vector,
but in Rcpp they simply point to the existing vector and override the
subsetting operator (\texttt{{[}}) to implement special behaviour. This
makes them very efficient: for instance, \texttt{rep\_len(x, 1e6)} does
not have to make a million copies of x.

\subsection{Other useful functions}

Finally, there's a grab bag of sugar functions that mimic frequently
used R functions:

\begin{itemize}
\item
  Math functions: \texttt{abs()}, \texttt{acos()}, \texttt{asin()},
  \texttt{atan()}, \texttt{beta()}, \texttt{ceil()}, \texttt{ceiling()},
  \texttt{choose()}, \texttt{cos()}, \texttt{cosh()},
  \texttt{digamma()}, \texttt{exp()}, \texttt{expm1()},
  \texttt{factorial()}, \texttt{floor()}, \texttt{gamma()},
  \texttt{lbeta()}, \texttt{lchoose()}, \texttt{lfactorial()},
  \texttt{lgamma()}, \texttt{log()}, \texttt{log10()}, \texttt{log1p()},
  \texttt{pentagamma()}, \texttt{psigamma()}, \texttt{round()},
  \texttt{signif()}, \texttt{sin()}, \texttt{sinh()}, \texttt{sqrt()},
  \texttt{tan()}, \texttt{tanh()}, \texttt{tetragamma()},
  \texttt{trigamma()}, \texttt{trunc()}.
\item
  Scalar summaries: \texttt{mean()}, \texttt{min()}, \texttt{max()},
  \texttt{sum()}, \texttt{sd()}, and (for vectors) \texttt{var()}.
\item
  Vector summaries: \texttt{cumsum()}, \texttt{diff()}, \texttt{pmin()},
  and \texttt{pmax()}.
\item
  Finding values: \texttt{match()}, \texttt{self\_match()},
  \texttt{which\_max()}, \texttt{which\_min()}.
\item
  Dealing with duplicates: \texttt{duplicated()}, \texttt{unique()}.
\item
  \texttt{d/q/p/r} for all standard distributions.
\end{itemize}

Finally, \texttt{noNA(x)} asserts that the vector \texttt{x} does not
contain any missing values, and allows optimisation of some mathematical
operations.

\hyperdef{}{stl}{\section{The STL}\label{stl}}

The real strength of C++ shows itself when you need to implement more
complex algorithms. The standard template library (STL) provides a set
of extremely useful data structures and algorithms. This section will
explain some of the most important algorithms and data structures and
point you in the right direction to learn more. I can't teach you
everything you need to know about the STL, but hopefully the examples
will show you the power of the STL, and persuade you that it's useful to
learn more. \index{standard template library}

If you need an algorithm or data structure that isn't implemented in
STL, a good place to look is \href{http://www.boost.org/doc/}{boost}.
Installing boost on your computer is beyond the scope of this chapter,
but once you have it installed, you can use boost data structures and
algorithms by including the appropriate header file with (e.g.)
\texttt{\#include \textless{}boost/array.hpp\textgreater{}}.

\subsection{Using iterators}

Iterators are used extensively in the STL: many functions either accept
or return iterators. They are the next step up from basic loops,
abstracting away the details of the underlying data structure. Iterators
have three main operators: \index{iterators}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Advance with \texttt{++}.
\item
  Get the value they refer to, or \textbf{dereference}, with \texttt{*}.
\item
  Compare with \texttt{==}.
\end{enumerate}

For example we could re-write our sum function using iterators:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double} \NormalTok{sum3(NumericVector x) \{}
  \DataTypeTok{double} \NormalTok{total = }\DecValTok{0}\NormalTok{;}
  
  \NormalTok{NumericVector::iterator it;}
  \KeywordTok{for}\NormalTok{(it = x.begin(); it != x.end(); ++it) \{}
    \NormalTok{total += *it;}
  \NormalTok{\}}
  \KeywordTok{return} \NormalTok{total;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The main changes are in the for loop:

\begin{itemize}
\item
  We start at \texttt{x.begin()} and loop until we get to
  \texttt{x.end()}. A small optimization is to store the value of the
  end iterator so we don't need to look it up each time. This only saves
  about 2 ns per iteration, so it's only important when the calculations
  in the loop are very simple.
\item
  Instead of indexing into x, we use the dereference operator to get its
  current value: \texttt{*it}.
\item
  Notice the type of the iterator: \texttt{NumericVector::iterator}.
  Each vector type has its own iterator type:
  \texttt{LogicalVector::iterator}, \texttt{CharacterVector::iterator},
  etc.
\end{itemize}

Iterators also allow us to use the C++ equivalents of the apply family
of functions. For example, we could again rewrite \texttt{sum()} to use
the \texttt{accumulate()} function, which takes a starting and an ending
iterator, and adds up all the values in the vector. The third argument
to accumulate gives the initial value: it's particularly important
because this also determines the data type that accumulate uses (so we
use \texttt{0.0} and not \texttt{0} so that accumulate uses a
\texttt{double}, not an \texttt{int}.). To use \texttt{accumulate()} we
need to include the \texttt{\textless{}numeric\textgreater{}} header.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <numeric>}
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\DataTypeTok{double} \NormalTok{sum4(NumericVector x) \{}
  \KeywordTok{return} \NormalTok{std::accumulate(x.begin(), x.end(), }\FloatTok{0.}\DecValTok{0}\NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\texttt{accumulate()} (along with the other functions in
\texttt{\textless{}numeric\textgreater{}}, like
\texttt{adjacent\_difference()}, \texttt{inner\_product()}, and
\texttt{partial\_sum()}) is not that important in Rcpp because Rcpp
sugar provides equivalents.

\subsection{Algorithms}

The \texttt{\textless{}algorithm\textgreater{}} header provides a large
number of algorithms that work with iterators. A good reference is
available at \url{http://www.cplusplus.com/reference/algorithm/}. For
example, we could write a basic Rcpp version of \texttt{findInterval()}
that takes two arguments a vector of values and a vector of breaks, and
locates the bin that each x falls into. This shows off a few more
advanced iterator features. Read the code below and see if you can
figure out how it works. \indexc{findInterval()}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <algorithm>}
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{IntegerVector findInterval2(NumericVector x, NumericVector breaks) \{}
  \NormalTok{IntegerVector out(x.size());}

  \NormalTok{NumericVector::iterator it, pos;}
  \NormalTok{IntegerVector::iterator out_it;}

  \KeywordTok{for}\NormalTok{(it = x.begin(), out_it = out.begin(); it != x.end(); }
      \NormalTok{++it, ++out_it) \{}
    \NormalTok{pos = std::upper_bound(breaks.begin(), breaks.end(), *it);}
    \NormalTok{*out_it = std::distance(breaks.begin(), pos);}
  \NormalTok{\}}

  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The key points are:

\begin{itemize}
\item
  We step through two iterators (input and output) simultaneously.
\item
  We can assign into an dereferenced iterator (\texttt{out\_it}) to
  change the values in \texttt{out}.
\item
  \texttt{upper\_bound()} returns an iterator. If we wanted the value of
  the \texttt{upper\_bound()} we could dereference it; to figure out its
  location, we use the \texttt{distance()} function.
\item
  Small note: if we want this function to be as fast as
  \texttt{findInterval()} in R (which uses handwritten C code), we need
  to compute the calls to \texttt{.begin()} and \texttt{.end()} once and
  save the results. This is easy, but it distracts from this example so
  it has been omitted. Making this change yields a function that's
  slightly faster than R's \texttt{findInterval()} function, but is
  about 1/10 of the code.
\end{itemize}

It's generally better to use algorithms from the STL than hand rolled
loops. In \emph{Effective STL}, Scott Meyers gives three reasons:
efficiency, correctness, and maintainability. Algorithms from the STL
are written by C++ experts to be extremely efficient, and they have been
around for a long time so they are well tested. Using standard
algorithms also makes the intent of your code more clear, helping to
make it more readable and more maintainable.

\subsection{Data structures}\label{data-structures-rcpp}

The STL provides a large set of data structures: \texttt{array},
\texttt{bitset}, \texttt{list}, \texttt{forward\_list}, \texttt{map},
\texttt{multimap}, \texttt{multiset}, \texttt{priority\_queue},
\texttt{queue}, \texttt{dequeue}, \texttt{set}, \texttt{stack},
\texttt{unordered\_map}, \texttt{unordered\_set},
\texttt{unordered\_multimap}, \texttt{unordered\_multiset}, and
\texttt{vector}. The most important of these data structures are the
\texttt{vector}, the \texttt{unordered\_set}, and the
\texttt{unordered\_map}. We'll focus on these three in this section, but
using the others is similar: they just have different performance
trade-offs. For example, the \texttt{deque} (pronounced ``deck'') has a
very similar interface to vectors but a different underlying
implementation that has different performance trade-offs. You may want
to try them for your problem. A good reference for STL data structures
is \url{http://www.cplusplus.com/reference/stl/} --- I recommend you
keep it open while working with the STL.

Rcpp knows how to convert from many STL data structures to their R
equivalents, so you can return them from your functions without
explicitly converting to R data structures.

\subsection{Vectors}\label{vectors-stl}

An STL vector is very similar to an R vector, except that it grows
efficiently. This makes vectors appropriate to use when you don't know
in advance how big the output will be. Vectors are templated, which
means that you need to specify the type of object the vector will
contain when you create it: \texttt{vector\textless{}int\textgreater{}},
\texttt{vector\textless{}bool\textgreater{}},
\texttt{vector\textless{}double\textgreater{}},
\texttt{vector\textless{}String\textgreater{}}. You can access
individual elements of a vector using the standard \texttt{{[}{]}}
notation, and you can add a new element to the end of the vector using
\texttt{.push\_back()}. If you have some idea in advance how big the
vector will be, you can use \texttt{.reserve()} to allocate sufficient
storage. \index{vectors!in C++}

The following code implements run length encoding (\texttt{rle()}). It
produces two vectors of output: a vector of values, and a vector
\texttt{lengths} giving how many times each element is repeated. It
works by looping through the input vector \texttt{x} comparing each
value to the previous: if it's the same, then it increments the last
value in \texttt{lengths}; if it's different, it adds the value to the
end of \texttt{values}, and sets the corresponding length to 1.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{List rleC(NumericVector x) \{}
  \NormalTok{std::vector<}\DataTypeTok{int}\NormalTok{> lengths;}
  \NormalTok{std::vector<}\DataTypeTok{double}\NormalTok{> values;}

  \CommentTok{// Initialise first value}
  \DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{;}
  \DataTypeTok{double} \NormalTok{prev = x[}\DecValTok{0}\NormalTok{];}
  \NormalTok{values.push_back(prev);}
  \NormalTok{lengths.push_back(}\DecValTok{1}\NormalTok{);}

  \NormalTok{NumericVector::iterator it;}
  \KeywordTok{for}\NormalTok{(it = x.begin() + }\DecValTok{1}\NormalTok{; it != x.end(); ++it) \{}
    \KeywordTok{if} \NormalTok{(prev == *it) \{}
      \NormalTok{lengths[i]++;}
    \NormalTok{\} }\KeywordTok{else} \NormalTok{\{}
      \NormalTok{values.push_back(*it);}
      \NormalTok{lengths.push_back(}\DecValTok{1}\NormalTok{);}

      \NormalTok{i++;}
      \NormalTok{prev = *it;}
    \NormalTok{\}}
  \NormalTok{\}}

  \KeywordTok{return} \NormalTok{List::create(}
    \NormalTok{_[}\StringTok{"lengths"}\NormalTok{] = lengths, }
    \NormalTok{_[}\StringTok{"values"}\NormalTok{] = values}
  \NormalTok{);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(An alternative implementation would be to replace \texttt{i} with the
iterator \texttt{lengths.rbegin()} which always points to the last
element of the vector. You might want to try implementing that
yourself.)

Other methods of a vector are described at
\url{http://www.cplusplus.com/reference/vector/vector/}.

\subsection{Sets}

Sets maintain a unique set of values, and can efficiently tell if you've
seen a value before. They are useful for problems that involve
duplicates or unique values (like \texttt{unique}, \texttt{duplicated},
or \texttt{in}). C++ provides both ordered (\texttt{std::set}) and
unordered sets (\texttt{std::unordered\_set}), depending on whether or
not order matters for you. Unordered sets tend to be much faster
(because they use a hash table internally rather than a tree), so even
if you need an ordered set, you should consider using an unordered set
and then sorting the output. Like vectors, sets are templated, so you
need to request the appropriate type of set for your purpose:
\texttt{unordered\_set\textless{}int\textgreater{}},
\texttt{unordered\_set\textless{}bool\textgreater{}}, etc. More details
are available at \url{http://www.cplusplus.com/reference/set/set/} and
\url{http://www.cplusplus.com/reference/unordered_set/unordered_set/}.
\index{sets}

The following function uses an unordered set to implement an equivalent
to \texttt{duplicated()} for integer vectors. Note the use of
\texttt{seen.insert(x{[}i{]}).second}. \texttt{insert()} returns a pair,
the \texttt{.first} value is an iterator that points to element and the
\texttt{.second} value is a boolean that's true if the value was a new
addition to the set.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{// [[Rcpp::plugins(cpp11)]]}
\OtherTok{#include <Rcpp.h>}
\OtherTok{#include <unordered_set>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{LogicalVector duplicatedC(IntegerVector x) \{}
  \NormalTok{std::unordered_set<}\DataTypeTok{int}\NormalTok{> seen;}
  \DataTypeTok{int} \NormalTok{n = x.size();}
  \NormalTok{LogicalVector out(n);}

  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{out[i] = !seen.insert(x[i]).second;}
  \NormalTok{\}}

  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that unordered sets are only available in C++ 11, which means we
need to use the \texttt{cpp11} plugin,
\texttt{{[}{[}Rcpp::plugins(cpp11){]}{]}}.

\subsection{Map}

A map is similar to a set, but instead of storing presence or absence,
it can store additional data. It's useful for functions like
\texttt{table()} or \texttt{match()} that need to look up a value. As
with sets, there are ordered (\texttt{std::map}) and unordered
(\texttt{std::unordered\_map}) versions. Since maps have a value and a
key, you need to specify both types when initialising a map:
\texttt{map\textless{}double, int\textgreater{}},
\texttt{unordered\_map\textless{}int, double\textgreater{}}, and so on.
The following example shows how you could use a \texttt{map} to
implement \texttt{table()} for numeric vectors: \index{maps}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{std::map<}\DataTypeTok{double}\NormalTok{, }\DataTypeTok{int}\NormalTok{> tableC(NumericVector x) \{}
  \NormalTok{std::map<}\DataTypeTok{double}\NormalTok{, }\DataTypeTok{int}\NormalTok{> counts;}

  \DataTypeTok{int} \NormalTok{n = x.size();}
  \KeywordTok{for} \NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; i++) \{}
    \NormalTok{counts[x[i]]++;}
  \NormalTok{\}}

  \KeywordTok{return} \NormalTok{counts;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Note that unordered maps are only available in C++ 11, so to use them,
you'll again need \texttt{{[}{[}Rcpp::plugins(cpp11){]}{]}}.

\subsection{Exercises}

To practice using the STL algorithms and data structures, implement the
following using R functions in C++, using the hints provided:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{median.default()} using \texttt{partial\_sort}.
\item
  \texttt{\%in\%} using \texttt{unordered\_set} and the \texttt{find()}
  or \texttt{count()} methods.
\item
  \texttt{unique()} using an \texttt{unordered\_set} (challenge: do it
  in one line!).
\item
  \texttt{min()} using \texttt{std::min()}, or \texttt{max()} using
  \texttt{std::max()}.
\item
  \texttt{which.min()} using \texttt{min\_element}, or
  \texttt{which.max()} using \texttt{max\_element}.
\item
  \texttt{setdiff()}, \texttt{union()}, and \texttt{intersect()} for
  integers using sorted ranges and \texttt{set\_union},
  \texttt{set\_intersection} and \texttt{set\_difference}.
\end{enumerate}

\hyperdef{}{rcpp-case-studies}{\section{Case
studies}\label{rcpp-case-studies}}

The following case studies illustrate some real life uses of C++ to
replace slow R code.

\subsection{Gibbs sampler}

The following case study updates an example
\href{http://dirk.eddelbuettel.com/blog/2011/07/14/}{blogged about} by
Dirk Eddelbuettel, illustrating the conversion of a Gibbs sampler in R
to C++. The R and C++ code shown below is very similar (it only took a
few minutes to convert the R version to the C++ version), but runs about
20 times faster on my computer. Dirk's blog post also shows another way
to make it even faster: using the faster random number generator
functions in GSL (easily accessible from R through the RcppGSL package)
can make it another 2--3x faster. \index{Gibbs sampler}

The R code is as follows:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{gibbs_r <-}\StringTok{ }\NormalTok{function(N, thin) \{}
  \NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{nrow =} \NormalTok{N, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{)}
  \NormalTok{x <-}\StringTok{ }\NormalTok{y <-}\StringTok{ }\DecValTok{0}

  \NormalTok{for (i in }\DecValTok{1}\NormalTok{:N) \{}
    \NormalTok{for (j in }\DecValTok{1}\NormalTok{:thin) \{}
      \NormalTok{x <-}\StringTok{ }\KeywordTok{rgamma}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, y *}\StringTok{ }\NormalTok{y +}\StringTok{ }\DecValTok{4}\NormalTok{)}
      \NormalTok{y <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{1} \NormalTok{/}\StringTok{ }\NormalTok{(x +}\StringTok{ }\DecValTok{1}\NormalTok{), }\DecValTok{1} \NormalTok{/}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2} \NormalTok{*}\StringTok{ }\NormalTok{(x +}\StringTok{ }\DecValTok{1}\NormalTok{)))}
    \NormalTok{\}}
    \NormalTok{mat[i, ] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(x, y)}
  \NormalTok{\}}
  \NormalTok{mat}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

This is straightforward to convert to C++. We:

\begin{itemize}
\item
  add type declarations to all variables
\item
  use \texttt{(} instead of \texttt{{[}} to index into the matrix
\item
  subscript the results of \texttt{rgamma} and \texttt{rnorm} to convert
  from a vector into a scalar
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericMatrix gibbs_cpp(}\DataTypeTok{int} \NormalTok{N, }\DataTypeTok{int} \NormalTok{thin) \{}
  \NormalTok{NumericMatrix mat(N, }\DecValTok{2}\NormalTok{);}
  \DataTypeTok{double} \NormalTok{x = }\DecValTok{0}\NormalTok{, y = }\DecValTok{0}\NormalTok{;}

  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < N; i++) \{}
    \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{j = }\DecValTok{0}\NormalTok{; j < thin; j++) \{}
      \NormalTok{x = rgamma(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1} \NormalTok{/ (y * y + }\DecValTok{4}\NormalTok{))[}\DecValTok{0}\NormalTok{];}
      \NormalTok{y = rnorm(}\DecValTok{1}\NormalTok{, }\DecValTok{1} \NormalTok{/ (x + }\DecValTok{1}\NormalTok{), }\DecValTok{1} \NormalTok{/ sqrt(}\DecValTok{2} \NormalTok{* (x + }\DecValTok{1}\NormalTok{)))[}\DecValTok{0}\NormalTok{];}
    \NormalTok{\}}
    \NormalTok{mat(i, }\DecValTok{0}\NormalTok{) = x;}
    \NormalTok{mat(i, }\DecValTok{1}\NormalTok{) = y;}
  \NormalTok{\}}

  \KeywordTok{return}\NormalTok{(mat);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Benchmarking the two implementations yields:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \KeywordTok{gibbs_r}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{),}
  \KeywordTok{gibbs_cpp}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>                expr   min    lq median    uq    max neval}
\CommentTok{#>    gibbs_r(100, 10) 6,810 8,150  8,300 8,490 45,000   100}
\CommentTok{#>  gibbs_cpp(100, 10)   251   267    274   284  1,460   100}
\end{Highlighting}
\end{Shaded}

\subsection{R vectorisation vs.~C++ vectorisation}

This example is adapted from
\href{http://www.babelgraph.org/wp/?p=358}{``Rcpp is smoking fast for
agent-based models in data frames''}. The challenge is to predict a
model response from three inputs. The basic R version of the predictor
looks like:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vacc1a <-}\StringTok{ }\NormalTok{function(age, female, ily) \{}
  \NormalTok{p <-}\StringTok{ }\FloatTok{0.25} \NormalTok{+}\StringTok{ }\FloatTok{0.3} \NormalTok{*}\StringTok{ }\DecValTok{1} \NormalTok{/}\StringTok{ }\NormalTok{(}\DecValTok{1} \NormalTok{-}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\FloatTok{0.04} \NormalTok{*}\StringTok{ }\NormalTok{age)) +}\StringTok{ }\FloatTok{0.1} \NormalTok{*}\StringTok{ }\NormalTok{ily}
  \NormalTok{p <-}\StringTok{ }\NormalTok{p *}\StringTok{ }\NormalTok{if (female) }\FloatTok{1.25} \NormalTok{else }\FloatTok{0.75}
  \NormalTok{p <-}\StringTok{ }\KeywordTok{max}\NormalTok{(}\DecValTok{0}\NormalTok{, p)}
  \NormalTok{p <-}\StringTok{ }\KeywordTok{min}\NormalTok{(}\DecValTok{1}\NormalTok{, p)}
  \NormalTok{p}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We want to be able to apply this function to many inputs, so we might
write a vector-input version using a for loop.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vacc1 <-}\StringTok{ }\NormalTok{function(age, female, ily) \{}
  \NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(age)}
  \NormalTok{out <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(n)}
  \NormalTok{for (i in }\KeywordTok{seq_len}\NormalTok{(n)) \{}
    \NormalTok{out[i] <-}\StringTok{ }\KeywordTok{vacc1a}\NormalTok{(age[i], female[i], ily[i])}
  \NormalTok{\}}
  \NormalTok{out}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

If you're familiar with R, you'll have a gut feeling that this will be
slow, and indeed it is. There are two ways we could attack this problem.
If you have a good R vocabulary, you might immediately see how to
vectorise the function (using \texttt{ifelse()}, \texttt{pmin()}, and
\texttt{pmax()}). Alternatively, we could rewrite \texttt{vacc1a()} and
\texttt{vacc1()} in C++, using our knowledge that loops and function
calls have much lower overhead in C++.

Either approach is fairly straightforward. In R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vacc2 <-}\StringTok{ }\NormalTok{function(age, female, ily) \{}
  \NormalTok{p <-}\StringTok{ }\FloatTok{0.25} \NormalTok{+}\StringTok{ }\FloatTok{0.3} \NormalTok{*}\StringTok{ }\DecValTok{1} \NormalTok{/}\StringTok{ }\NormalTok{(}\DecValTok{1} \NormalTok{-}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\FloatTok{0.04} \NormalTok{*}\StringTok{ }\NormalTok{age)) +}\StringTok{ }\FloatTok{0.1} \NormalTok{*}\StringTok{ }\NormalTok{ily}
  \NormalTok{p <-}\StringTok{ }\NormalTok{p *}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(female, }\FloatTok{1.25}\NormalTok{, }\FloatTok{0.75}\NormalTok{)}
  \NormalTok{p <-}\StringTok{ }\KeywordTok{pmax}\NormalTok{(}\DecValTok{0}\NormalTok{, p)}
  \NormalTok{p <-}\StringTok{ }\KeywordTok{pmin}\NormalTok{(}\DecValTok{1}\NormalTok{, p)}
  \NormalTok{p}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

(If you've worked R a lot you might recognise some potential bottlenecks
in this code: \texttt{ifelse}, \texttt{pmin}, and \texttt{pmax} are
known to be slow, and could be replaced with
\texttt{p + 0.75 + 0.5 * female},
\texttt{p{[}p \textless{} 0{]} \textless{}- 0},
\texttt{p{[}p \textgreater{} 1{]} \textless{}- 1}. You might want to try
timing those variations yourself.)

Or in C++:

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{#include <Rcpp.h>}
\KeywordTok{using} \KeywordTok{namespace} \NormalTok{Rcpp;}

\DataTypeTok{double} \NormalTok{vacc3a(}\DataTypeTok{double} \NormalTok{age, }\DataTypeTok{bool} \NormalTok{female, }\DataTypeTok{bool} \NormalTok{ily)\{}
  \DataTypeTok{double} \NormalTok{p = }\FloatTok{0.}\DecValTok{25} \NormalTok{+ }\FloatTok{0.}\DecValTok{3} \NormalTok{* }\DecValTok{1} \NormalTok{/ (}\DecValTok{1} \NormalTok{- exp(}\FloatTok{0.}\BaseNTok{04} \NormalTok{* age)) + }\FloatTok{0.}\DecValTok{1} \NormalTok{* ily;}
  \NormalTok{p = p * (female ? }\FloatTok{1.}\DecValTok{25} \NormalTok{: }\FloatTok{0.}\DecValTok{75}\NormalTok{);}
  \NormalTok{p = std::max(p, }\FloatTok{0.}\DecValTok{0}\NormalTok{);}
  \NormalTok{p = std::min(p, }\FloatTok{1.}\DecValTok{0}\NormalTok{);}
  \KeywordTok{return} \NormalTok{p;}
\NormalTok{\}}

\CommentTok{// [[Rcpp::export]]}
\NormalTok{NumericVector vacc3(NumericVector age, LogicalVector female, }
                    \NormalTok{LogicalVector ily) \{}
  \DataTypeTok{int} \NormalTok{n = age.size();}
  \NormalTok{NumericVector out(n);}

  \KeywordTok{for}\NormalTok{(}\DataTypeTok{int} \NormalTok{i = }\DecValTok{0}\NormalTok{; i < n; ++i) \{}
    \NormalTok{out[i] = vacc3a(age[i], female[i], ily[i]);}
  \NormalTok{\}}

  \KeywordTok{return} \NormalTok{out;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

We next generate some sample data, and check that all three versions
return the same values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\DecValTok{1000}
\NormalTok{age <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(n, }\DataTypeTok{mean =} \DecValTok{50}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{10}\NormalTok{)}
\NormalTok{female <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F), n, }\DataTypeTok{rep =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{ily <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(}\KeywordTok{c}\NormalTok{(T, F), n, }\DataTypeTok{prob =} \KeywordTok{c}\NormalTok{(}\FloatTok{0.8}\NormalTok{, }\FloatTok{0.2}\NormalTok{), }\DataTypeTok{rep =} \OtherTok{TRUE}\NormalTok{)}

\KeywordTok{stopifnot}\NormalTok{(}
  \KeywordTok{all.equal}\NormalTok{(}\KeywordTok{vacc1}\NormalTok{(age, female, ily), }\KeywordTok{vacc2}\NormalTok{(age, female, ily)),}
  \KeywordTok{all.equal}\NormalTok{(}\KeywordTok{vacc1}\NormalTok{(age, female, ily), }\KeywordTok{vacc3}\NormalTok{(age, female, ily))}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The original blog post forgot to do this, and introduced a bug in the
C++ version: it used \texttt{0.004} instead of \texttt{0.04}. Finally,
we can benchmark our three approaches:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{microbenchmark}\NormalTok{(}
  \DataTypeTok{vacc1 =} \KeywordTok{vacc1}\NormalTok{(age, female, ily),}
  \DataTypeTok{vacc2 =} \KeywordTok{vacc2}\NormalTok{(age, female, ily),}
  \DataTypeTok{vacc3 =} \KeywordTok{vacc3}\NormalTok{(age, female, ily)}
\NormalTok{)}
\CommentTok{#> Unit: microseconds}
\CommentTok{#>   expr     min      lq  median      uq     max neval}
\CommentTok{#>  vacc1 3,780.0 4,000.0 4,180.0 5,160.0 6,610.0   100}
\CommentTok{#>  vacc2   320.0   333.0   357.0   377.0   667.0   100}
\CommentTok{#>  vacc3    15.6    17.8    20.4    24.1    39.7   100}
\end{Highlighting}
\end{Shaded}

Not surprisingly, our original approach with loops is very slow.
Vectorising in R gives a huge speedup, and we can eke out even more
performance (\textasciitilde{}10x) with the C++ loop. I was a little
surprised that the C++ was so much faster, but it is because the R
version has to create 11 vectors to store intermediate results, where
the C++ code only needs to create 1.

\hyperdef{}{rcpp-package}{\section{Using Rcpp in a
package}\label{rcpp-package}}

The same C++ code that is used with \texttt{sourceCpp()} can also be
bundled into a package. There are several benefits of moving code from a
stand-alone C++ source file to a package: \index{Rcpp!in a package}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Your code can be made available to users without C++ development
  tools.
\item
  Multiple source files and their dependencies are handled automatically
  by the R package build system.
\item
  Packages provide additional infrastructure for testing, documentation,
  and consistency.
\end{enumerate}

To add \texttt{Rcpp} to an existing package, you put your C++ files in
the \texttt{src/} directory and modify/create the following
configuration files:

\begin{itemize}
\item
  In \texttt{DESCRIPTION} add

\begin{verbatim}
LinkingTo: Rcpp
Imports: Rcpp
\end{verbatim}
\item
  Make sure your \texttt{NAMESPACE} includes:

\begin{verbatim}
useDynLib(mypackage)
importFrom(Rcpp, sourceCpp)
\end{verbatim}

  We need to import something (anything) from Rcpp so that internal Rcpp
  code is properly loaded. This is a bug in R and hopefully will be
  fixed in the future.
\end{itemize}

To generate a new Rcpp package that includes a simple ``hello world''
function you can use \texttt{Rcpp.package.skeleton()}:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Rcpp.package.skeleton}\NormalTok{(}\StringTok{"NewPackage"}\NormalTok{, }\DataTypeTok{attributes =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

To generate a package based on C++ files that you've been using with
\texttt{sourceCpp()}, use the \texttt{cpp\_files} parameter:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{Rcpp.package.skeleton}\NormalTok{(}\StringTok{"NewPackage"}\NormalTok{, }\DataTypeTok{example_code =} \OtherTok{FALSE}\NormalTok{,}
                      \DataTypeTok{cpp_files =} \KeywordTok{c}\NormalTok{(}\StringTok{"convolve.cpp"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Before building the packge, you'll need to run
\texttt{Rcpp::compileAttributes()}. This function scans the C++ files
for \texttt{Rcpp::export} attributes and generates the code required to
make the functions available in R. Re-run \texttt{compileAttributes()}
whenever functions are added, removed, or have their signatures changed.
This is done automatically by the devtools package and by Rstudio.

For more details see the Rcpp package vignette,
\texttt{vignette("Rcpp-package")}.

\hyperdef{}{rcpp-more}{\section{Learning more}\label{rcpp-more}}

This chapter has only touched on a small part of Rcpp, giving you the
basic tools to rewrite poorly performing R code in C++. The
\href{http://www.rcpp.org/book}{Rcpp book} is the best reference to
learn more about Rcpp. As noted, Rcpp has many other capabilities that
make it easy to interface R to existing C++ code, including:

\begin{itemize}
\item
  Additional features of attributes including specifying default
  arguments, linking in external C++ dependencies, and exporting C++
  interfaces from packages. These features and more are covered in the
  Rcpp attributes vignette, \texttt{vignette("Rcpp-attributes")}.
\item
  Automatically creating wrappers between C++ data structures and R data
  structures, including mapping C++ classes to reference classes. A good
  introduction to this topic is Rcpp modules vignette,
  \texttt{vignette("Rcpp-modules")}
\item
  The Rcpp quick reference guide, \texttt{vignette("Rcpp-quickref")},
  contains a useful summary of Rcpp classes and common programming
  idioms.
\end{itemize}

I strongly recommend keeping an eye on the
\href{http://www.rcpp.org}{Rcpp homepage} and
\href{http://dirk.eddelbuettel.com/code/rcpp.html}{Dirk's Rcpp page} as
well as signing up for the
\href{http://lists.r-forge.r-project.org/cgi-bin/mailman/listinfo/rcpp-devel}{Rcpp
mailing list}. Rcpp is still under active development, and is getting
better with every release.

Other resources I've found helpful in learning C++ are:

\begin{itemize}
\item
  \href{http://amzn.com/0321334876?tag=devtools-20}{\emph{Effective
  C++}} and
  \href{http://amzn.com/0201749629?tag=devtools-20}{\emph{Effective
  STL}} by Scott Meyers.
\item
  \href{http://www.icce.rug.nl/documents/cplusplus/cplusplus.html}{\emph{C++
  Annotations}}, aimed at ``knowledgeable users of C (or any other
  language using a C-like grammar, like Perl or Java) who would like to
  know more about, or make the transition to, C++''.
\item
  \href{http://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/}{\emph{Algorithm
  Libraries}}, which provides a more technical, but still concise,
  description of important STL concepts. (Follow the links under notes).
\end{itemize}

Writing performance code may also require you to rethink your basic
approach: a solid understanding of basic data structures and algorithms
is very helpful here. That's beyond the scope of this book, but I'd
suggest the
\href{http://amzn.com/0387948600?tag=devtools-20}{\emph{Algorithm Design
Manual}}, MIT's
\href{http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/}{\emph{Introduction
to Algorithms}}, \emph{Algorithms} by Robert Sedgewick and Kevin Wayne
which has a free \href{http://algs4.cs.princeton.edu/home/}{online
textbook} and a matching
\href{https://www.coursera.org/course/algs4partI}{coursera course}.

\section{Acknowledgments}

I'd like to thank the Rcpp-mailing list for many helpful conversations,
particularly Romain Francois and Dirk Eddelbuettel who have not only
provided detailed answers to many of my questions, but have been
incredibly responsive at improving Rcpp. This chapter would not have
been possible without JJ Allaire; he encouraged me to learn C++ and then
answered many of my dumb questions along the way.
